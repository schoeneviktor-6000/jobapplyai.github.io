<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>jobmejob â€¢ Dashboard</title>


<link rel="stylesheet" href="./shared.css" />
<style>
/* Dashboard-specific UI (kept local; shared.css covers the base UI) */
.chips{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.chip{
border:1px solid rgba(17,19,24,.14);
background:rgba(17,19,24,.04);
color:var(--muted);
padding:8px 10px;
border-radius:999px;
font-weight:850;
font-size:12px;
cursor:pointer;
transition:.15s ease;
}
.chip:hover{transform:translateY(-1px); background:rgba(17,19,24,.06)}
.chip.active{border-color:rgba(34,197,94,.55); background:rgba(34,197,94,.16); color:#0a3d1f}

.small{font-size:12px;color:var(--muted2);font-weight:650}
.mono{
font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
font-size:12px;
word-break:break-all;
color:rgba(17,19,24,.64);
}

.meter{
width:100%;
height:10px;
border-radius:999px;
border:1px solid rgba(17,19,24,.14);
background:rgba(17,19,24,.04);
overflow:hidden;
margin-top:10px;
}
.meter > div{
height:100%;
width:0%;
background: linear-gradient(135deg, var(--accent), var(--accent2));
border-radius:999px;
transition:width .25s ease;
}

.errorTop{
margin:12px 0 12px 0;
padding:12px 14px;
border-radius:16px;
border:1px solid rgba(255,61,113,.25);
background:rgba(255,61,113,.10);
color:#5a1130;
font-weight:800;
display:none;
}
.error{
margin-top:10px;
padding:10px 12px;
border-radius:14px;
border:1px solid rgba(255,61,113,.25);
background:rgba(255,61,113,.10);
color:#5a1130;
font-weight:750;
font-size:13px;
}

.kpiBoard{
display:grid;
grid-template-columns: 2fr 1fr 1fr 1fr;
gap:14px;
margin:12px 0 16px 0;
align-items:stretch;
}
.kpiBoard .card{height:100%}

.grid{
display:grid;
grid-template-columns:repeat(12, minmax(0,1fr));
gap:16px;
align-items:start;
}
.grid > section.card{grid-column:span 8;}
.grid > aside.card{grid-column:span 4;position:sticky;top:92px}

.sectionHeader{
background:var(--surface2);
border-bottom:1px solid rgba(17,19,24,.10);
padding:14px;
}
.sectionBody{padding:14px}

.list{display:flex;flex-direction:column;gap:12px}
.listGrid{
display:grid;
grid-template-columns:repeat(2, minmax(0,1fr));
gap:12px;
}
.item{
border:1px solid rgba(17,19,24,.12);
background:var(--surface3);
border-radius:16px;
padding:14px;
}
.itemTop{
display:flex;
justify-content:space-between;
gap:10px;
align-items:flex-start;
}

.badgeGroup{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
.itemTitle{font-weight:950;line-height:1.2}
.itemMeta{
margin-top:6px;
display:flex;
flex-wrap:wrap;
gap:8px;
color:var(--muted2);
font-size:12px;
font-weight:750;
}
.tagRow{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px;}
.tag{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;border:1px solid rgba(17,19,24,.12);background:rgba(17,19,24,.04);font-size:11px;font-weight:800;color:var(--muted2);}
.tag.ok{border-color:rgba(0,184,98,.25);background:rgba(0,184,98,.08);}
.tag.warn{border-color:rgba(255,179,0,.28);background:rgba(255,179,0,.10);}
.tag.bad{border-color:rgba(239,68,68,.25);background:rgba(239,68,68,.08);}

.itemActions{
margin-top:10px;
display:flex;
gap:10px;
flex-wrap:wrap;
}
.itemActions .btn{flex:1 1 auto;justify-content:center}

/* Table swipe */
.tableWrap{
overflow-x:auto;
overflow-y:hidden;
-webkit-overflow-scrolling:touch;
touch-action:pan-x pan-y;
border-radius:16px;
border:1px solid rgba(17,19,24,.12);
background:rgba(17,19,24,.03);
}
.table{
width:100%;
min-width:1100px;
border-collapse:separate;
border-spacing:0;
}
.table th,.table td{
text-align:left;
padding:10px 10px;
font-size:13px;
border-bottom:1px solid rgba(17,19,24,.10);
vertical-align:top;
}
.table th{
background:rgba(17,19,24,.06);
font-weight:950;
position:sticky;
top:0;
}
.table tr:last-child td{border-bottom:0}
.table a{color:var(--accent2);text-decoration:underline}

.skeleton{
border-radius:12px;
height:12px;
background:linear-gradient(90deg, rgba(17,19,24,.10), rgba(17,19,24,.04), rgba(17,19,24,.10));
background-size:200% 100%;
animation:shimmer 1.2s linear infinite;
}
.skeleton.block{height:140px;border-radius:16px}
@keyframes shimmer{
0%{background-position:200% 0}
100%{background-position:-200% 0}
}

/* Modal */
.field{
display:flex;
flex-direction:column;
gap:6px;
margin-top:10px;
}
label{font-size:12px;color:var(--muted);font-weight:800}
select,textarea{
border:1px solid rgba(17,19,24,.14);
background:rgba(17,19,24,.04);
color:var(--text);
border-radius:12px;
padding:10px 12px;
outline:none;
}
textarea{min-height:80px;resize:vertical}
.modalActions .btn{flex:0 0 auto}

/* Tailor controls + CV preview */
.tailorControls{display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; margin:10px 0 10px}
.tailorControls .ctrl{display:flex; flex-direction:column; gap:6px; min-width:160px}
.tailorControls input[type="range"]{width:100%}
.pillRow{display:flex; gap:8px; flex-wrap:wrap}
.pillRow .pill{cursor:pointer; user-select:none}

.cvPreview{white-space:normal; font-size:13px; line-height:1.45; max-height:60vh; overflow:auto; background:rgba(255,255,255,.95); border:1px solid rgba(17,19,24,.14); padding:14px; border-radius:14px}
.cvPaper{max-width:820px; margin:0 auto; font-family:Arial, Helvetica, sans-serif; color:#111318}
.cvName{font-size:34px; font-weight:900; letter-spacing:-.6px; color:rgba(17,19,24,.72)}
.cvRole{margin-top:2px; font-size:14px; font-weight:800; color:rgba(17,19,24,.55)}
.cvContact{margin-top:6px; font-size:12.5px; color:rgba(17,19,24,.62)}
.cvSection{margin-top:16px}
.cvSectionTitle{font-size:14px; font-weight:900; letter-spacing:.08em; text-transform:uppercase; border-bottom:3px solid #111318; padding-bottom:6px; margin:0 0 8px 0}
.cvItem{margin:0 0 12px 0}
.cvItemTitle{font-weight:900}
.cvItemSub{margin-top:2px; font-weight:800; color:rgba(17,19,24,.62)}
.cvMetaLine{margin-top:2px; font-size:12.5px; color:rgba(17,19,24,.62)}
.cvUl{margin:6px 0 0 18px; padding:0}
.cvUl li{margin:0 0 3px 0}
.cvSkillGroup{margin:0 0 6px 0}
.cvSkillLabel{font-weight:900}
.cvMuted{color:rgba(17,19,24,.62)}

.footer{
max-width:var(--max);
margin:0 auto;
padding:18px 16px 30px;
color:var(--muted2);
font-size:13px;
}

@media (max-width:1100px){
.grid{grid-template-columns:1fr}
.grid > section.card{grid-column:auto}
.grid > aside.card{grid-column:auto;position:static}
.kpiBoard{grid-template-columns:1fr 1fr}
.listGrid{grid-template-columns:1fr}
.table{min-width:980px}
}
@media (max-width:760px){
.kpiBoard{grid-template-columns:1fr 1fr}
.listGrid{grid-template-columns:1fr}
.table{min-width:900px}
}
@media (max-width:620px){
.nav{padding:10px 12px}
.main{padding:16px 12px calc(16px + var(--safeBottom))}
.h1{font-size:30px}
.actions{flex-direction:column;align-items:stretch}
.btn{justify-content:center;width:100%}
.kpiBoard{grid-template-columns:1fr}
.table{min-width:820px}
.modalActions .btn{width:100%;justify-content:center}
}
@media (prefers-reduced-motion: reduce){
.skeleton{animation:none}
.meter > div{transition:none}
.pill,.btn,.chip{transition:none}
}

.pill.mini{padding:7px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(17,19,24,.04);font-weight:850;font-size:12px;display:inline-flex;align-items:center}
.leaving{opacity:.7;transform:translateY(6px);transition:all .18s ease}

/* Fetch button + AI switch */
#btnFetchJobsNow{
background: linear-gradient(135deg, var(--accent2), var(--accent));
border: 0;
color: #0b1020;
font-weight: 700;
box-shadow: 0 10px 22px rgba(79,104,255,.22);
}
#btnFetchJobsNow:disabled{
opacity: .55;
cursor: not-allowed;
box-shadow: none;
}
.switchWrap{display:flex;align-items:center;gap:10px;padding:6px 10px;border:1px solid rgba(255,255,255,.10);border-radius:999px;background:rgba(255,255,255,.04)}
.switch{position:relative;display:inline-block;width:44px;height:24px}
.switch input{opacity:0;width:0;height:0}
.slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,.25);transition:.2s;border-radius:999px}
.slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:white;transition:.2s;border-radius:50%}
.switch input:checked + .slider{background:linear-gradient(135deg,var(--accent2),var(--accent))}
.switch input:checked + .slider:before{transform:translateX(20px)}


/* AI switch gated hint + fetch meta */
.switchHint{display:inline-flex;align-items:center;gap:8px;margin-left:10px;padding:4px 10px;border-radius:999px;background:rgba(0,0,0,.04);border:1px solid rgba(0,0,0,.06)}
.switchHint .lock{font-size:14px;opacity:.8}
.switchHint a{color:var(--accent2);text-decoration:none;font-weight:700}
.switchHint a:hover{text-decoration:underline}
#fetchMeta{white-space:nowrap}
.switch input:disabled + .slider{opacity:.5;cursor:not-allowed}



/* Quick actions (Dashboard) */
.actionsStack{display:flex;flex-direction:column;gap:10px;align-items:stretch}
.actionsStack .btn{width:100%;justify-content:center}


/* --- BI dashboard redesign (KPI strip + visuals) --- */
.dashHeaderRow{
  display:flex;
  justify-content:space-between;
  gap:14px;
  align-items:flex-end;
  flex-wrap:wrap;
  margin:8px 0 10px;
}

.kpiStrip{
  display:grid;
  grid-template-columns:repeat(6, minmax(0, 1fr));
  gap:14px;
  margin:10px 0 18px;
  align-items:stretch;
}
.kpiTile{height:100%}
.kpiTile .value{font-size:30px}
.kpiTile .label{letter-spacing:.02em}

.meter.mini{height:8px;margin-top:10px}
.meter.mini > div{width:0%}

/* 2-up visual grid */
.vizGrid{
  display:grid;
  grid-template-columns:repeat(2, minmax(0,1fr));
  gap:12px;
}

/* Bar trend chart (HTML bars, no external libs) */
.barChartWrap{
  position:relative;
  height:160px;
  border-radius:16px;
  border:1px solid rgba(17,19,24,.12);
  background:rgba(17,19,24,.03);
  padding:12px 12px 10px;
}
.barChart{
  position:absolute;
  left:12px; right:12px; top:12px; bottom:28px;
  display:flex;
  gap:6px;
  align-items:flex-end;
}
.barCol{flex:1;min-width:0;display:flex;flex-direction:column;justify-content:flex-end;align-items:stretch}
.bar{
  width:100%;
  border-radius:10px;
  background:linear-gradient(135deg, var(--accent), var(--accent2));
  min-height:2px;
  opacity:.9;
  transition:height .2s ease;
}
.barCol:hover .bar{opacity:1; transform:translateY(-1px)}
.barLblRow{
  position:absolute;
  left:12px; right:12px; bottom:8px;
  display:flex;
  gap:6px;
}
.barLbl{
  flex:1;min-width:0;
  font-size:10px;
  font-weight:800;
  color:var(--muted2);
  text-align:center;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.capLine{
  position:absolute;
  left:12px; right:12px;
  height:2px;
  background:rgba(17,19,24,.28);
  border-radius:2px;
  pointer-events:none;
}

/* Funnel */
.funnel{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.fRow{
  display:grid;
  grid-template-columns: 120px 1fr 64px 74px;
  gap:10px;
  align-items:center;
}
.fLabel{font-size:12px;font-weight:950;color:var(--muted)}
.fVal{font-weight:950;text-align:right}
.fConv{font-size:12px;font-weight:800;color:var(--muted2);text-align:right}
.fBarWrap{
  height:12px;
  border-radius:999px;
  border:1px solid rgba(17,19,24,.14);
  background:rgba(17,19,24,.04);
  overflow:hidden;
}
.fBar{
  height:100%;
  width:0%;
  background:linear-gradient(135deg, var(--accent2), var(--accent));
  border-radius:999px;
}

/* Recommendations list */
.recoList{display:flex;flex-direction:column;gap:10px}
.recoItem{
  border:1px solid rgba(17,19,24,.12);
  background:rgba(17,19,24,.03);
  border-radius:16px;
  padding:12px;
}
.recoTop{display:flex;gap:10px;align-items:flex-start;justify-content:space-between}
.recoTitle{font-weight:950;line-height:1.2}
.recoDesc{margin-top:6px;color:var(--muted2);font-size:12px;font-weight:750;line-height:1.35}
.recoActions{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap}
.recoActions .btn{flex:1 1 auto;justify-content:center}

/* Right rail tweaks */
#rightRail h2{margin-bottom:6px}
#accountDetails summary{list-style:none}
#accountDetails summary::-webkit-details-marker{display:none}

@media (max-width:1100px){
  .kpiStrip{grid-template-columns:repeat(2, minmax(0,1fr))}
  .vizGrid{grid-template-columns:1fr}
}
@media (max-width:760px){
  .kpiStrip{grid-template-columns:repeat(2, minmax(0,1fr))}
}
@media (max-width:620px){
  .kpiStrip{grid-template-columns:1fr}
  .fRow{grid-template-columns: 92px 1fr 54px 64px}
}
/* --- Clean spacing + typography pass (v2) --- */
.main{ padding-top: 18px; }
.h1{ letter-spacing:-.03em; line-height:1.05; }
.sub{ margin-top:6px; }

.dashHeaderRow{ margin:12px 0 14px; align-items:center; }
.kpiStrip{ gap:16px; margin:12px 0 22px; }

/* Reduce squeeze on medium screens: switch to 3 columns earlier */
@media (max-width:1280px){
  .kpiStrip{ grid-template-columns:repeat(3, minmax(0,1fr)); }
}
@media (max-width:980px){
  .kpiStrip{ grid-template-columns:repeat(2, minmax(0,1fr)); }
}
@media (max-width:620px){
  .kpiStrip{ grid-template-columns:1fr; }
}

/* KPI typography + rhythm */
.kpiTile.card{ padding:16px 16px 14px !important; }
.kpiTile{ display:flex; flex-direction:column; }
.kpiTile .kpi{ align-items:flex-start; gap:12px; }
.kpiTile .value{
  font-size:32px;
  line-height:1;
  letter-spacing:-.03em;
}
.kpiTile .label{
  margin-top:7px;
  font-size:11px;
  font-weight:850;
  letter-spacing:.12em;
  text-transform:uppercase;
  color:rgba(17,19,24,.55);
}
.kpiTile .small{
  font-size:13px;
  line-height:1.35;
  margin-top:12px;
}
.kpiTile .badge{ margin-top:3px; }
.kpiTile .meter.mini{ margin-top:auto; }

.sectionHeader{ padding:18px 18px; }
.sectionBody{ padding:18px; }
.vizGrid{ gap:16px; }
.item{ padding:16px; }
.itemTitle{ font-weight:900; letter-spacing:-.01em; }
.itemMeta{ line-height:1.35; }
.small{ line-height:1.35; }

/* Performance header actions: align cleanly */
.dashActions{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.dashActionsLeft{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.dashActionsRight{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
  margin-left:auto;
}
.dashMetaCol{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:4px;
  min-width:220px;
}
@media (max-width:760px){
  .dashMetaCol{ min-width:0; }
}
@media (max-width:620px){
  .dashActionsRight{ width:100%; justify-content:space-between; }
  .dashMetaCol{ width:100%; align-items:flex-start; }
}

/* Right rail: breathing room */
#rightRail{ padding:18px !important; }
#rightRail .hr{ margin:14px 0; }
.actionsStack{ gap:12px; }

/* v2.1: numeric alignment + smoother type */
html{
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
}
.kpiTile .value{ font-variant-numeric: tabular-nums; }

</style>
</head>
<body>
<header class="topbar" id="topbar">
<nav class="nav">
<a class="brand" href="./dashboard.html" data-nav="1"><span class="logo" aria-hidden="true"></span><span>jobmejob</span></a>
<div class="navlinks">
<a class="pill active" href="./dashboard.html" data-nav="1">Dashboard</a>
<a class="pill" href="./cv.html" data-nav="1">CV Studio</a>
<a class="pill" href="./jobs.html" data-nav="1">Jobs</a>
<a class="pill" href="./plan.html" data-nav="1">Plan</a>

<details class="navDrop" id="navAccount" style="display:none">
  <summary class="pill" aria-label="Account menu">
    <span id="navAccountLabel">Account</span>
    <span aria-hidden="true">â–¾</span>
  </summary>

  <div class="navMenu" role="menu" aria-label="Account menu">
    <div class="menuLabel">Account</div>
    <a class="pill" href="./profile.html" data-nav="1" role="menuitem">Profile setup</a>
    <button class="btn ghost" id="navActivity" type="button" role="menuitem">Activity log</button>

    <div class="menuSep" role="separator"></div>
    <div class="menuLabel">More</div>
    <a class="pill" href="./plan.html" data-nav="1" role="menuitem">Upgrade / Plan</a>

    <div class="menuSep" role="separator"></div>
    <button class="btn danger" id="navLogout" type="button" role="menuitem">Logout</button>
  </div>
</details>

<a class="pill" href="./signup.html" id="navSignIn" data-nav="1">Sign in</a>
</div>
</nav>
</header>

<main class="main">
<h1 class="h1">Dashboard</h1>
<p class="sub" id="subLine">Loadingâ€¦</p>
<div class="errorTop" id="errorTop"></div>

<div class="dashHeaderRow">
  <div>
    <div class="small" style="font-weight:850">Range</div>
    <div class="chips" id="rangeFilters" aria-label="Dashboard range">
      <button class="chip active" type="button" data-range="14">14d</button>
      <button class="chip" type="button" data-range="30">30d</button>
    </div>
  </div>
  <div style="display:flex;align-items:flex-end;justify-content:flex-end;gap:10px;flex-wrap:wrap">
    <span class="pill mini" id="dashStatusPill">Loadingâ€¦</span>
  </div>
</div>

<div class="kpiStrip" id="kpiStrip">
  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiTodaySent">â€“</div>
        <div class="label" id="kpiTodaySentLabel">sent today</div>
      </div>
      <span class="badge" id="badgeTodaySent">Loading</span>
    </div>
    <div class="small" id="kpiTodaySentMeta">Cap: â€“/day</div>
    <div class="meter mini"><div id="todayMeterFill"></div></div>
  </div>

  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiWeekSent">â€“</div>
        <div class="label">sent last 7 days</div>
      </div>
      <span class="badge" id="badgeWeekSent">Loading</span>
    </div>
    <div class="small" id="kpiWeekSentMeta">vs prev 7d: â€“</div>
  </div>

  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiQueue">â€“</div>
        <div class="label">jobs ready</div>
      </div>
      <span class="badge" id="badgeQueue">Loading</span>
    </div>
    <div class="small" id="kpiQueueMeta">Coverage: â€“</div>
    <div class="meter mini"><div id="supplyMeterFill"></div></div>
  </div>

  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiTailorCoverage">â€“</div>
        <div class="label">tailored coverage</div>
      </div>
      <span class="badge" id="badgeTailor">Loading</span>
    </div>
    <div class="small" id="kpiTailorMeta">Avg ATS: â€“</div>
  </div>

  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiResponseRate">â€“</div>
        <div class="label">responses (30d)</div>
      </div>
      <span class="badge" id="badgeResponse">Loading</span>
    </div>
    <div class="small" id="kpiResponseMeta">Responses: â€“ â€¢ Sent: â€“</div>
  </div>

  <div class="card kpiTile">
    <div class="kpi">
      <div>
        <div class="value" id="kpiPlanName">â€“</div>
        <div class="label" id="kpiPlanMeta">selected</div>
      </div>
      <span class="badge" id="badgePlan">Loading</span>
    </div>
    <div class="small" id="kpiPlanHint">Total applications: <span id="kpiAppsTotal">â€“</span></div>
  </div>
</div>


<div class="grid">
<section class="card cardNoPad">
<div class="sectionHeader">
<h2>Performance</h2>
<p class="small" id="queueHint">Throughput, bottlenecks, and supply health. Manage individual jobs in the Jobs tab.</p>
<div class="dashActions" id="dashActions">
  <div class="dashActionsLeft">
    <button class="btn primary" id="btnRefresh" type="button">Refresh</button>
    <button class="btn cta" id="btnFetchJobsNow" type="button">Fetch new jobs</button>

    <div class="switchWrap" title="When ON: search using only AI-generated titles">
      <span class="small">AI titles only</span>
      <label class="switch">
        <input type="checkbox" id="toggleAiOnly" />
        <span class="slider"></span>
      </label>
      <div class="switchHint" id="aiSwitchHint" style="display:none">
        <span class="lock">ðŸ”’</span>
        <a href="./profile.html">Generate AI suggestions to unlock</a>
      </div>
    </div>
  </div>

  <div class="dashActionsRight">
    <button class="btn ghost" id="btnCopyToken" type="button">Copy access token</button>

    <div class="dashMetaCol">
      <span class="small" id="fetchMeta" style="opacity:.85"></span>
      <span class="small" id="fetchJobsStatus" style="opacity:.85"></span>
    </div>
  </div>
</div>
<div class="hr"></div>
</div>

<div class="sectionBody">
<div class="vizGrid" id="vizGrid">
  <div class="item">
    <div class="itemTop">
      <div>
        <div class="itemTitle">Applications trend</div>
        <div class="small" id="trendMeta" style="margin-top:6px">Loadingâ€¦</div>
      </div>
      <div class="badgeGroup"><span class="badge" id="badgeTrend">Loading</span></div>
    </div>
    <div style="height:10px"></div>
    <div id="trendChart"><div class="skeleton block" style="height:160px"></div></div>
    <div class="small" id="trendFoot" style="margin-top:10px"></div>
  </div>

  <div class="item">
    <div class="itemTop">
      <div>
        <div class="itemTitle">Pipeline funnel</div>
        <div class="small" id="funnelMeta" style="margin-top:6px">Loadingâ€¦</div>
      </div>
      <div class="badgeGroup"><span class="badge" id="badgeFunnel">Loading</span></div>
    </div>
    <div style="height:10px"></div>
    <div id="funnelWrap"><div class="skeleton block" style="height:160px"></div></div>
    <div class="small" id="funnelBottleneck" style="margin-top:10px"></div>
  </div>
</div>

<div class="hr"></div>
<div id="queueWrap"><div class="skeleton block"></div></div>
<div id="queueError"></div>

<div class="hr"></div>

<div class="sectionHeader" style="border-radius:0;border-left:0;border-right:0">
<h2 style="margin:0">Application activity log</h2>
<p class="small">Latest timeline events (queued, prioritized, skipped, appliedâ€¦).</p>
<div class="chips" id="activityFilters">
<button class="chip active" type="button" data-etype="">All</button>
<button class="chip" type="button" data-etype="queued">Queued</button>
<button class="chip" type="button" data-etype="prioritized">Prioritized</button>
<button class="chip" type="button" data-etype="applied">Applied</button>
<button class="chip" type="button" data-etype="sent">Sent</button>
<button class="chip" type="button" data-etype="rejected">Rejected</button>
<button class="chip" type="button" data-etype="skipped">Skipped</button>
</div>
</div>

<div class="hr"></div>

<div id="activitySnapshot"><div class="skeleton block" style="height:110px"></div></div>

<div class="hr"></div>

<div id="activityWrap"><div class="skeleton block"></div></div>
<div id="activityError"></div>
</div>
</section>

<aside class="card" id="rightRail">
  <h2>Now</h2>
  <div class="small" id="nowHint">Recommended next actions based on your activity and supply.</div>
  <div class="hr"></div>

  <div id="nextActions">
    <div class="actionsStack">
      <button class="btn primary cta" id="qaFetchJobs" type="button">Fetch jobs</button>
      <button class="btn" id="qaViewQueue" type="button">Open Jobs</button>
      <button class="btn" id="qaTailorTop" type="button">Tailor top job</button>

      <a class="btn ghost" id="qaSettings" href="./profile.html" data-nav="1">Profile setup</a>
      <a class="btn" id="qaAutoApply" href="./plan.html" data-nav="1">Auto-apply (upgrade)</a>
    </div>

    <div class="small" style="margin-top:10px" id="qaStatus"></div>

    <div class="hr"></div>
    <div id="nextActionsReco"><div class="skeleton block" style="height:120px"></div></div>
  </div>

  <div class="hr"></div>

  <div class="item" style="padding:12px">
    <div class="itemTop">
      <div class="itemTitle">Automation health</div>
      <div class="badgeGroup"><span class="badge" id="badgeAutomation">Loading</span></div>
    </div>
    <div class="small" id="automationHealthMeta" style="margin-top:8px">Loadingâ€¦</div>
    <div id="automationHealth" style="margin-top:10px"><div class="skeleton block" style="height:90px"></div></div>
  </div>

  <div class="hr"></div>

  <h2 style="margin-top:0">AI recommendations <span class="badge" id="badgeAi">Loading</span></h2>
  <div class="small" id="aiRecoHint">Loadingâ€¦</div>
  <div class="hr"></div>
  <div id="aiRecoList"></div>

  <div class="hr"></div>

  <details id="accountDetails" open>
    <summary class="pill" style="cursor:pointer">Account details</summary>

    <div style="margin-top:10px">
      <div class="badge good" id="badgeUser">Signed in</div>
      <div class="hr"></div>

      <div class="small">Email</div>
      <div class="mono" id="meEmail">â€“</div>

      <div class="hr"></div>
      <div class="small">Customer ID</div>
      <div class="mono" id="meCustomerId">â€“</div>

      <div class="hr"></div>
      <div class="small">Onboarding checks</div>
      <div id="onboardingChecks"><div class="skeleton block"></div></div>

      <div class="hr"></div>
      <div class="small">Applications breakdown</div>
      <div id="appsBreakdown"><div class="skeleton block"></div></div>

      <div class="hr"></div>
      <div class="small">Last refresh</div>
      <div class="mono" id="lastCheck">â€“</div>

      <div class="hr"></div>
      <div class="actions">
        <a class="btn ghost" href="./profile.html" data-nav="1">Edit profile</a>
        <a class="btn ghost" href="./plan.html" data-nav="1">Change plan</a>
      </div>

      <div class="hr"></div>
      <div class="small" id="errorBox"></div>
    </div>
  </details>
</aside>
</div>
</main>

<div class="modalBackdrop" id="skipModal" style="display:none">
<div class="modalCard">

  <div class="modalScroll">
<div class="modalTitle">Skip this job</div>

<div class="field">
<label for="skipReason">Reason</label>
<select id="skipReason">
<option value="not_relevant">Not relevant</option>
<option value="too_far">Too far</option>
<option value="wrong_industry">Wrong industry</option>
<option value="salary_too_low">Salary too low</option>
<option value="already_applied">Already applied</option>
<option value="other">Other</option>
</select>
</div>

<div class="field">
<label for="skipNote">Note</label>
<textarea id="skipNote" placeholder="Optional noteâ€¦"></textarea>
</div>
  </div>
  <div class="modalActions">
<button class="btn ghost" id="skipCancel" type="button">Cancel</button>
<button class="btn danger" id="skipConfirm" type="button">Skip</button>
</div>
</div>
</div>

<div class="modalBackdrop" id="descModal" style="display:none">
  <div class="modalCard" style="max-width:920px">
    
  <div class="modalScroll">
<div class="modalTitle" id="descTitle">Job description</div>
    <div class="small" id="descMeta" style="margin-top:-6px"></div>
    <div class="hr" style="margin:14px 0"></div>
    <div id="descBody" class="mono" style="white-space:pre-wrap; font-size:13px; line-height:1.45; max-height:60vh; overflow:auto; background:rgba(17,19,24,.04); border:1px solid rgba(17,19,24,.14); padding:12px; border-radius:14px;">Loadingâ€¦</div>
  </div>
  <div class="modalActions">
      <button class="btn ghost" id="descClose" type="button">Close</button>
      <button class="btn" id="descCopy" type="button">Copy</button>
    </div>
</div>
</div>


<div class="modalBackdrop" id="tailorModal" style="display:none">
  <div class="modalCard" style="max-width:960px">
    
  <div class="modalScroll">
<div class="modalTitle" id="tailorTitle">Tailored CV</div>
    <div class="small" id="tailorMeta" style="margin-top:-6px"></div>
    <div class="hr" style="margin:14px 0"></div>
    <div class="tailorControls" id="tailorControls">
      <div class="ctrl">
        <div class="small" style="font-weight:800">Template</div>
        <select id="tailorTemplate" class="input" style="min-width:240px">
          <option value="professional">Professional (ATS-safe)</option>
        </select>
      </div>
      <div class="ctrl" style="flex:1; min-width:280px">
        <div class="small" style="font-weight:800">Tailoring strength</div>
        <input id="tailorStrength" type="range" min="0" max="2" value="1" step="1" style="width:100%">
        <div class="small" id="tailorStrengthHelp" style="margin-top:2px; color:rgba(17,19,24,.7)"></div>
      </div>
      <div class="ctrl" style="min-width:220px">
        <div class="small" style="font-weight:800">View</div>
        <div class="pillRow" style="display:flex; gap:8px; margin-top:4px">
          <button class="pill active" id="tailorViewPreview" type="button">Preview</button>
          <button class="pill" id="tailorViewText" type="button">Text</button>
        </div>
      </div>
    </div>

    <div id="tailorKeywords" class="small" style="margin-bottom:10px; display:none"></div>
    <div id="tailorPreview" class="cvPreview">Generatingâ€¦</div>
    <div id="tailorBody" class="mono" style="display:none; white-space:pre-wrap; font-size:13px; line-height:1.45; max-height:60vh; overflow:auto; background:rgba(17,19,24,.04); border:1px solid rgba(17,19,24,.14); padding:12px; border-radius:14px;">Generatingâ€¦</div>
  </div>
  <div class="modalActions">
      <button class="btn ghost" id="tailorClose" type="button">Close</button>
      <button class="btn ghost" id="tailorRegenerate" type="button">Regenerate</button>
      <button class="btn" id="tailorCopy" type="button">Copy</button>
      <button class="btn" id="tailorPrint" type="button">Print / PDF</button>
      <button class="btn" id="tailorDownload" type="button">Download .txt</button>
    </div>
</div>
</div>

<footer class="footer">Support: <a href="mailto:team@jobmejob.com">team@jobmejob.com</a></footer>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script src="./auth.js"></script>
<script src="./shared.js"></script>
<script>


const API_BASE = (window.JobApplyAI && window.JobApplyAI.config && window.JobApplyAI.config.API_BASE) || "https://jobmejob.schoene-viktor.workers.dev";
const SUPABASE_URL="https://awlzvhcnjegfhjedswko.supabase.co";
const SUPABASE_ANON_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF3bHp2aGNuamVnZmhqZWRzd2tvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY2NTE2OTgsImV4cCI6MjA4MjIyNzY5OH0.-UmHiVi0_g9tKDkr6ldfROeBrOk8hm18YVPRfnb8luY";
let supabaseClient=null;

let lastSessionToken="";
let lastQueueResponse=null;
const tailorSummaryMap=new Map();
let currentPlanDaily=0;
let currentQueueCount=0;

// Rerender job cards (used after actions like Tailor CV to refresh ATS badge)
function renderAllJobs(){
  try{
    if(!lastQueueResponse){
      return;
    }
    setHtml("queueWrap", renderQueueCards(lastQueueResponse));
  }catch(e){
    // Never break the UI because of a rerender
    console.warn("renderAllJobs failed", e);
  }
}

let useEventsEndpoint=true;
let activityEventType="";

let pendingSkipJobId=null;
let pendingDescJobId=null;
let currentDescText="";
let pendingTailorJobId=null;
let currentTailorText="";
let currentTailorResult=null;
let currentTailorDoc=null;
let currentTailorJobTitle="";
let tailorViewMode="preview";

function setText(id,text){const el=document.getElementById(id); if(el) el.textContent=text;}
function setHtml(id,html){const el=document.getElementById(id); if(el) el.innerHTML=html;}
function setBadge(id,type,text){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.setBadge==="function"){
    return window.JobMeJobShared.setBadge(id,type,text);
  }
  const el=document.getElementById(id);
  if(!el) return;
  el.className="badge"+(type?(" "+type):"");
  el.textContent=text;
}
function showTopError(msg){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.showTopError==="function"){
    return window.JobMeJobShared.showTopError("errorTop", msg);
  }
  const el=document.getElementById("errorTop");
  if(!el) return;
  if(!msg){ el.style.display="none"; el.textContent=""; return; }
  el.style.display="block";
  el.textContent=msg;
}
function clearTopError(){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.showTopError==="function"){
    return window.JobMeJobShared.showTopError("errorTop", "");
  }
  const el=document.getElementById("errorTop");
  if(!el) return;
  el.style.display="none";
  el.textContent="";
}
function escapeHtml(s){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.escapeHtml==="function"){
    return window.JobMeJobShared.escapeHtml(s);
  }
  return String(s??"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function showModal(id){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.showModal==="function"){
    return window.JobMeJobShared.showModal(id);
  }
  const el=document.getElementById(id);
  if(!el) return;
  el.style.display="flex";
}
function hideModal(id){
  if(window.JobMeJobShared && typeof window.JobMeJobShared.hideModal==="function"){
    return window.JobMeJobShared.hideModal(id);
  }
  const el=document.getElementById(id);
  if(!el) return;
  el.style.display="none";
}
function closeTailorModal(){
  pendingTailorJobId=null;
  hideModal("tailorModal");
}
function nowStamp(){return new Date().toISOString().replace("T"," ").slice(0,19)+" UTC";}
function animateNumber(el,to){
const prefersReduced=window.matchMedia&&window.matchMedia("(prefers-reduced-motion: reduce)").matches;
if(!el) return;
if(prefersReduced){el.textContent=String(to);return;}
const from=Number(String(el.textContent||"").replace(/[^\d.-]/g,""))||0;
const start=performance.now();
const dur=420;
function tick(t){
const p=Math.min(1,(t-start)/dur);
const eased=1-Math.pow(1-p,3);
const v=Math.round(from+(to-from)*eased);
el.textContent=String(v);
if(p<1) requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
}
function renderSkeleton(){return '<div class="skeleton block"></div>'; }

function go(url){
document.body.classList.add("leaving");
setTimeout(()=>{window.location.href=url;},180);
}
document.addEventListener("click",(e)=>{
const a=e.target.closest("a[data-nav='1']");
if(!a) return;
const url=a.getAttribute("href");
if(!url || url.startsWith("#")) return;
e.preventDefault();
go(url);
});

function openDescModal(jobId){
pendingDescJobId=jobId;
currentDescText="";
document.getElementById("descTitle").textContent="Job description";
document.getElementById("descMeta").textContent="";
document.getElementById("descBody").textContent="Loadingâ€¦";
document.getElementById("descModal").style.display="flex";
loadDesc(jobId);
}
function closeDescModal(){
pendingDescJobId=null;
document.getElementById("descModal").style.display="none";
}
async function loadDesc(jobId){
try{
const session=await requireSession();
if(!session) return;
const resp=await apiGet("/me/jobs/description?job_id="+encodeURIComponent(jobId), session.access_token);
const job=resp && resp.job ? resp.job : null;
const title=(job && job.title) ? job.title : "Job description";
const company=(job && job.company_name) ? job.company_name : "";
const source=(job && job.description_full_source) ? job.description_full_source : "";
const fetchedAt=(job && job.description_full_fetched_at) ? job.description_full_fetched_at : "";
document.getElementById("descTitle").textContent=title;
document.getElementById("descMeta").textContent=[company ? ("Company: "+company) : "", source ? ("Source: "+source) : "", fetchedAt ? ("Fetched: "+fetchedAt) : ""].filter(Boolean).join(" Â· ");
const text=(job && job.description_full) ? String(job.description_full) : "";
currentDescText=text;
if(text){
document.getElementById("descBody").textContent=text;
}else if(job && job.description_full_error){
document.getElementById("descBody").textContent="No description yet. Last error: "+job.description_full_error;
}else{
document.getElementById("descBody").textContent="No description found.";
}
}catch(e){
document.getElementById("descBody").textContent="Failed to load description: "+(e.message||e);
}
}
async function copyDesc(){
try{
const t=currentDescText||"";
if(!t){alert("Nothing to copy yet.");return;}
await navigator.clipboard.writeText(t);
alert("Description copied.");
}catch(e){
window.prompt("Copy description:", currentDescText||"");
}
}


// Tailored CV modal
function openTailorModal(jobId, force){
  pendingTailorJobId=jobId;
  currentTailorText="";
  currentTailorDoc=null;
  currentTailorResult=null;

  currentTailorJobTitle="";
  try{
    const jobs = (lastQueueResponse && Array.isArray(lastQueueResponse.data)) ? lastQueueResponse.data : ((lastQueueResponse && Array.isArray(lastQueueResponse.jobs)) ? lastQueueResponse.jobs : []);
    const j = jobs.find(x => String(x && x.id) === String(jobId));
    if(j && j.title) currentTailorJobTitle = String(j.title);
  }catch(e){}

  // Restore last used settings (best-effort)
  try{
    const lastStrength = localStorage.getItem("tailor_strength");
    if(lastStrength){
      const v = String(lastStrength).trim().toLowerCase();
      if(v==="light"||v==="balanced"||v==="strong") setStrengthSliderFromKey(v);
    }
    const lastView = localStorage.getItem("tailor_view");
    if(lastView==="text"||lastView==="preview") tailorViewMode=lastView;
  }catch(e){}

  updateTailorStrengthHelp();
  setTailorView(tailorViewMode||"preview");

  setText("tailorTitle", "Tailored CV");
  setText("tailorStatus", "Ready");
  setText("tailorMeta", "Choose your options and click Generate.");
  setHtml("tailorKeywords", "");
  const kw=document.getElementById("tailorKeywords");
  if(kw) kw.style.display="none";

  setHtml("tailorPreview", '<div class="small">Choose settings above and click <b>Generate</b>.</div>');
  const tb=document.getElementById("tailorBody");
  if(tb) tb.textContent="Choose settings above and click Generate.";

  // Button state
  const genBtn=document.getElementById("tailorRegenerate");
  if(genBtn) genBtn.textContent="Generate";
  updateTailorButtonsState(false);

  showModal("tailorModal");
}

function regenerateTailor(){
  if(!pendingTailorJobId) return;
  generateTailoredCv(pendingTailorJobId, true);
}

function getStrengthKeyFromSlider(){
  const el=document.getElementById("tailorStrength");
  const v=Number(el?.value ?? 1);
  return (v<=0) ? "light" : (v>=2) ? "strong" : "balanced";
}

function setStrengthSliderFromKey(key){
  const el=document.getElementById("tailorStrength");
  if(!el) return;
  el.value = (key==="light") ? "0" : (key==="strong") ? "2" : "1";
}

function getTailorTemplate(){
  const el=document.getElementById("tailorTemplate");
  const v=String(el?.value||"professional").trim().toLowerCase();
  return (v==="professional") ? "professional" : "professional";
}

function updateTailorStrengthHelp(){
  const help=document.getElementById("tailorStrengthHelp");
  if(!help) return;
  const k=getStrengthKeyFromSlider();
  const map={
    light:{label:"Conservative", desc:"Keeps your wording. Small adjustments + keyword ordering."},
    balanced:{label:"Balanced", desc:"Improves summary and bullets to match the job, without over-rewriting."},
    strong:{label:"Aggressive", desc:"Rewrites more strongly to highlight fit and align with job language (still truthful)."},
  };
  const m=map[k]||map.balanced;
  help.innerHTML = `<span class="pill">${escapeHtml(m.label)}</span> <span style="color:rgba(17,19,24,.72)">${escapeHtml(m.desc)}</span>`;
}

function setTailorView(mode){
  tailorViewMode = (mode==="text") ? "text" : "preview";
  try{ localStorage.setItem("tailor_view", tailorViewMode); }catch(e){}
  const preview=document.getElementById("tailorPreview");
  const text=document.getElementById("tailorBody");
  const bPrev=document.getElementById("tailorViewPreview");
  const bText=document.getElementById("tailorViewText");
  if(preview) preview.style.display = (tailorViewMode==="preview") ? "block" : "none";
  if(text) text.style.display = (tailorViewMode==="text") ? "block" : "none";
  if(bPrev) bPrev.classList.toggle("active", tailorViewMode==="preview");
  if(bText) bText.classList.toggle("active", tailorViewMode==="text");
}

async function generateTailoredCv(jobId, force){
  try{
    setText("tailorStatus", "Generatingâ€¦");
    updateTailorButtonsState(true);

    const template=getTailorTemplate();
    const strength=getStrengthKeyFromSlider();
    try{ localStorage.setItem("tailor_strength", strength); }catch(e){}

    setText("tailorMeta", `Template: ${template} Â· Strength: ${strength}`);

    const payload={ job_id: jobId, force: !!force, template, strength };
    const session=await requireSession();
    if(!session) return;

    const resp=await apiPost("/me/cv/tailor", session.access_token, payload);
    if(!resp.ok) throw new Error(resp.error || "CV tailoring failed");

    const r=resp.result || {};
    currentTailorResult=r;
    currentTailorText = String(r.cv_text||"");
    currentTailorDoc = (r.cv_doc && typeof r.cv_doc === "object") ? r.cv_doc : null;

    const score = (typeof r.ats_score === "number") ? r.ats_score : null;
    setText("tailorStatus", score!==null ? `Done Â· ATS ${score}%` : "Done");

    const used = Array.isArray(r.ats_keywords_used) ? r.ats_keywords_used : [];
    const missing = Array.isArray(r.ats_keywords_missing) ? r.ats_keywords_missing : [];

    const explain = `<div class="small" style="margin-top:6px; color:rgba(17,19,24,.72)">ATS match is a keyword-based indicator (not a guarantee). Best results combine a good match with truthful content and clean formatting.</div>`;

    setHtml("tailorKeywords", [
      `<div class="row" style="gap:8px; flex-wrap:wrap">`,
      `<span class="pill">ATS match: <b>${escapeHtml(score===null?"?":String(score))}%</b></span>`,
      `<span class="pill">Keywords used: <b>${escapeHtml(String(used.length))}</b></span>`,
      `<span class="pill">Missing: <b>${escapeHtml(String(missing.length))}</b></span>`,
      `</div>`,
      explain,
    ].join(""));
    const kw2=document.getElementById("tailorKeywords");
    if(kw2) kw2.style.display="block";

    if(currentTailorDoc){
      setHtml("tailorPreview", cvDocToPreviewHtml(currentTailorDoc, r.language || "en"));
    }else{
      setHtml("tailorPreview", `<div class="small">Preview not available for this result. Use Text view.</div>`);
    }

    const tb=document.getElementById("tailorBody");
    if(tb) tb.textContent=currentTailorText || "";

    // Update badge cache for the job card
    tailorSummaryMap.set(jobId, { ats_score: score, updated_at: r.updated_at || new Date().toISOString() });
    updateTailorButtonsState(false);
    renderAllJobs();
  }catch(err){
    const msg = String(err?.message || err);
    setText("tailorStatus", "Failed");
    setText("tailorMeta", msg);
    setHtml("tailorPreview", `<div class="small" style="color:var(--bad)">Failed to generate CV: ${escapeHtml(msg)}</div>`);
    const tb=document.getElementById("tailorBody");
    if(tb) tb.textContent=`Failed to generate CV: ${msg}`;
    updateTailorButtonsState(false);
  }
}

function cvLabels(lang){
  const de={
    summary:"PROFIL",
    experience:"BERUFSERFAHRUNG",
    education:"AUSBILDUNG",
    achievements:"ERFOLGE",
    skills:"KOMPETENZEN",
    courses:"KURSE",
    interests:"INTERESSEN",
    languages:"SPRACHEN",
  };
  const en={
    summary:"SUMMARY",
    experience:"EXPERIENCE",
    education:"EDUCATION",
    achievements:"KEY ACHIEVEMENTS",
    skills:"SKILLS",
    courses:"COURSES",
    interests:"INTERESTS",
    languages:"LANGUAGES",
  };
  return (String(lang||"").toLowerCase()==="de") ? de : en;
}

function joinNonEmpty(parts, sep){
  return (parts||[]).map(x=>String(x||"").trim()).filter(Boolean).join(sep||" Â· ");
}

function fmtPeriod(start, end){
  const s=String(start||"").trim();
  const e=String(end||"").trim();
  if(s && e) return `${s} â€“ ${e}`;
  return s || e || "";
}

function asStringArr(v, limit){
  const arr = Array.isArray(v) ? v : [];
  return arr.map(x=>String(x||"").trim()).filter(Boolean).slice(0, limit||50);
}

function cvDocToPreviewHtml(doc, lang){
  const L=cvLabels(lang);
  const name=String(doc?.name||"YOUR NAME");
  const role=String(doc?.target_role||"The role you are applying for?");

  const c = doc?.contact || {};
  const contactLine = joinNonEmpty([
    c.phone,
    c.email,
    c.linkedin,
    c.portfolio,
    c.location,
  ], " Â· ");

  const summary=asStringArr(doc?.summary, 8);
  const exp=Array.isArray(doc?.experience) ? doc.experience : [];
  const edu=Array.isArray(doc?.education) ? doc.education : [];
  const ach=asStringArr(doc?.key_achievements, 10);
  const courses=asStringArr(doc?.courses, 10);
  const interests=asStringArr(doc?.interests, 10);
  const langs=asStringArr(doc?.languages, 10);

  const skills = doc?.skills || {};
  const skillGroups = Array.isArray(skills?.groups) ? skills.groups : [];
  const skillAdditional = asStringArr(skills?.additional, 30);

  const sec = (title, inner) => inner ? `<div class="cvSection"><div class="cvSectionTitle">${escapeHtml(title)}</div>${inner}</div>` : "";

  const ul = (items) => items && items.length ? `<ul class="cvUl">${items.map(it=>`<li>${escapeHtml(it)}</li>`).join("")}</ul>` : "";

  const expHtml = exp.length ? exp.slice(0, 12).map(e=>{
    const t=String(e?.title||"");
    const company=String(e?.company||"");
    const meta = joinNonEmpty([fmtPeriod(e?.start, e?.end), e?.location], " Â· ");
    const bullets = asStringArr(e?.bullets, 8);
    return [
      `<div class="cvItem">`,
      `<div class="cvItemTitle">${escapeHtml(joinNonEmpty([t, company], " â€” ") || (t||company||""))}</div>`,
      meta ? `<div class="cvMetaLine">${escapeHtml(meta)}</div>` : "",
      ul(bullets),
      `</div>`,
    ].join("");
  }).join("") : "";

  const eduHtml = edu.length ? edu.slice(0, 10).map(e=>{
    const degree = joinNonEmpty([e?.degree, e?.field], " Â· ");
    const school = joinNonEmpty([e?.school, e?.location], " Â· ");
    const meta = fmtPeriod(e?.start, e?.end);
    return [
      `<div class="cvItem">`,
      degree ? `<div class="cvItemTitle">${escapeHtml(degree)}</div>` : "",
      school ? `<div class="cvItemSub">${escapeHtml(school)}</div>` : "",
      meta ? `<div class="cvMetaLine">${escapeHtml(meta)}</div>` : "",
      `</div>`,
    ].join("");
  }).join("") : "";

  const skillsInner = (skillGroups.length || skillAdditional.length) ? [
    skillGroups.slice(0,6).map(g=>{
      const label = String(g?.label||"").trim();
      const items = asStringArr(g?.items, 30);
      if(!label && !items.length) return "";
      const line = label ? `<b>${escapeHtml(label)}:</b> ${escapeHtml(items.join(", "))}` : escapeHtml(items.join(", "));
      return `<div class="cvSkillLine">${line}</div>`;
    }).join(""),
    skillAdditional.length ? `<div class="cvSkillLine">${escapeHtml(skillAdditional.join(", "))}</div>` : "",
  ].join("") : "";

  const coursesInner = courses.length ? `<div class="cvPara">${escapeHtml(courses.join(" Â· "))}</div>` : "";
  const interestsInner = interests.length ? `<div class="cvPara">${escapeHtml(interests.join(" Â· "))}</div>` : "";
  const langsInner = langs.length ? `<div class="cvPara">${escapeHtml(langs.join(" Â· "))}</div>` : "";

  return [
    `<div class="cvPaper">`,
    `<div class="cvName">${escapeHtml(name)}</div>`,
    `<div class="cvRole">${escapeHtml(role)}</div>`,
    contactLine ? `<div class="cvContact">${escapeHtml(contactLine)}</div>` : "",
    sec(L.summary, ul(summary)),
    sec(L.experience, expHtml),
    sec(L.education, eduHtml),
    sec(L.achievements, ul(ach)),
    sec(L.skills, skillsInner),
    sec(L.courses, coursesInner),
    sec(L.interests, interestsInner),
    sec(L.languages, langsInner),
    `</div>`,
  ].join("");
}

function cvDocToPrintableHtml(cvDoc, lang, title){
  const css = `
    @page{ size:A4; margin:14mm 14mm 14mm 14mm; }
    body{ margin:0; padding:0; font-family: Arial, Helvetica, sans-serif; color:#111318; }
    .printHint{ background:#fff7db; color:#1b1b1b; border:1px solid #f2d57a; padding:10px 12px; border-radius:10px; margin:12px auto 0 auto; max-width:820px; font-size:12.5px; line-height:1.35; }
    @media print{ .printHint{ display:none !important; } }
    .cvPaper{ max-width:820px; margin:0 auto; }
    .cvName{ font-size:34px; font-weight:900; letter-spacing:-.6px; color:rgba(17,19,24,.72); }
    .cvRole{ margin-top:2px; font-size:14px; font-weight:800; color:rgba(17,19,24,.55); }
    .cvContact{ margin-top:6px; font-size:12.5px; color:rgba(17,19,24,.62); }
    .cvSection{ margin-top:16px; }
    .cvSectionTitle{ font-size:14px; font-weight:900; letter-spacing:.08em; text-transform:uppercase; border-bottom:3px solid #111318; padding-bottom:6px; margin:0 0 8px 0; }
    .cvItem{ margin-top:10px; }
    .cvItemTitle{ font-size:13.5px; font-weight:900; }
    .cvItemSub{ margin-top:2px; font-size:12.5px; font-weight:800; color:rgba(17,19,24,.62); }
    .cvMetaLine{ margin-top:2px; font-size:12.5px; color:rgba(17,19,24,.62); }
    .cvUl{ margin:6px 0 0 18px; padding:0; }
    .cvUl li{ margin:0 0 3px 0; font-size:13px; }
    .cvPara{ font-size:13px; line-height:1.45; }
    .cvSkillLine{ font-size:13px; line-height:1.45; margin:2px 0; }
  `;

  const body = cvDocToPreviewHtml(cvDoc, lang);
  const docTitle = title || "Curriculum Vitae";
  const hint = `<div class="printHint"><b>Tip:</b> To remove the jobmejob.com link in the PDF, open the print dialog and disable <b>Headers and footers</b> (More settings).</div>`;
  return `<!doctype html><html><head><meta charset="utf-8"><title>${escapeHtml(docTitle)}</title><style>${css}</style></head><body>${hint}${body}</body></html>`;
}

function cvTextToPrintableHtml(title, cvText){
  const safe = escapeHtml(cvText||"").replace(/\n/g, "<br>");
  return `<!doctype html><html><head><meta charset="utf-8"><title>${escapeHtml(title||"CV")}</title></head><body style="font-family:Arial, Helvetica, sans-serif"><div style="white-space:normal; font-size:13px; line-height:1.45">${safe}</div></body></html>`;
}

function printTailor(){
  if(!currentTailorText && !currentTailorDoc){
    alert("No tailored CV to print.");
    return;
  }
  const jobTitle = currentTailorJobTitle || "Curriculum Vitae";
  const lang = (currentTailorResult && currentTailorResult.language) ? currentTailorResult.language : "en";

  // Browser security prevents us from disabling print headers/footers automatically.
  // Show a quick reminder before opening the print dialog.
  try{
    const ok = confirm("To remove the jobmejob.com link from the PDF, disable 'Headers and footers' in the print dialog (More settings).\n\nContinue to Print / Save as PDF?");
    if(!ok) return;
  }catch(e){}

  const html = (currentTailorDoc)
    ? cvDocToPrintableHtml(currentTailorDoc, lang, jobTitle)
    : cvTextToPrintableHtml(jobTitle, currentTailorText);

  // Use hidden iframe to avoid popup blockers
  const blob = new Blob([html], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  let iframe = document.getElementById('printFrame');
  if(!iframe){
    iframe = document.createElement('iframe');
    iframe.id='printFrame';
    iframe.style.position='fixed';
    iframe.style.right='0';
    iframe.style.bottom='0';
    iframe.style.width='0';
    iframe.style.height='0';
    iframe.style.border='0';
    document.body.appendChild(iframe);
  }

  iframe.onload = () => {
    try{ iframe.contentWindow.focus(); iframe.contentWindow.print(); }catch(e){}
    setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(e){} }, 1000);
  };
  iframe.src = url;
}

function downloadTailor(){
  if(!currentTailorText){
    alert("No tailored CV to download.");
    return;
  }
  const title = currentTailorJobTitle ? `CV - ${currentTailorJobTitle}` : "CV";
  downloadTextFile(`${title}.txt`, currentTailorText);
}

function updateTailorButtonsState(isGenerating){
  const gen=document.getElementById("tailorRegenerate");
  const copy=document.getElementById("tailorCopy");
  const dl=document.getElementById("tailorDownload");
  const pr=document.getElementById("tailorPrint");

  const hasOutput = !!(currentTailorText && String(currentTailorText).trim()) || !!currentTailorDoc;

  if(copy) copy.disabled = !!isGenerating || !hasOutput;
  if(dl) dl.disabled = !!isGenerating || !(currentTailorText && String(currentTailorText).trim());
  if(pr) pr.disabled = !!isGenerating || !hasOutput;
  if(gen) gen.disabled = !!isGenerating;

  if(gen){
    if(isGenerating) gen.textContent = "Generatingâ€¦";
    else gen.textContent = hasOutput ? "Regenerate" : "Generate";
  }
}

function cvDocToPlainText(doc, lang){
  const L=cvLabels(lang);
  const lines=[];
  const name=String(doc?.name||"").trim();
  const role=String(doc?.target_role||"").trim();
  if(name) lines.push(name);
  if(role) lines.push(role);

  const c = doc?.contact || {};
  const contactLine = joinNonEmpty([
    c.phone,
    c.email,
    c.linkedin,
    c.portfolio,
    c.location,
  ], " | ");
  if(contactLine) lines.push(contactLine);

  function addTitle(t){
    lines.push("");
    lines.push(t);
    lines.push("-".repeat(Math.min(40, t.length)));
  }
  function addBullets(arr){
    const items=asStringArr(arr, 200);
    for(const it of items){
      lines.push("- "+it);
    }
  }

  // Summary
  const summary=asStringArr(doc?.summary, 20);
  if(summary.length){ addTitle(L.summary); addBullets(summary); }

  // Experience
  const exp=Array.isArray(doc?.experience)?doc.experience:[];
  if(exp.length){
    addTitle(L.experience);
    for(const e of exp){
      const head = joinNonEmpty([e?.title, e?.company], " â€” ");
      const meta = joinNonEmpty([fmtPeriod(e?.start, e?.end), e?.location], " | ");
      if(head) lines.push(head);
      if(meta) lines.push(meta);
      const bullets=asStringArr(e?.bullets, 50);
      for(const b of bullets){ lines.push("  - "+b); }
      lines.push("");
    }
  }

  // Education
  const edu=Array.isArray(doc?.education)?doc.education:[];
  if(edu.length){
    addTitle(L.education);
    for(const e of edu){
      const degree=joinNonEmpty([e?.degree, e?.field], " Â· ");
      const school=joinNonEmpty([e?.school, e?.location], " Â· ");
      const meta=fmtPeriod(e?.start, e?.end);
      if(degree) lines.push(degree);
      if(school) lines.push(school);
      if(meta) lines.push(meta);
      lines.push("");
    }
  }

  // Achievements
  const ach=asStringArr(doc?.key_achievements, 50);
  if(ach.length){ addTitle(L.achievements); addBullets(ach); }

  // Skills
  const skills=doc?.skills || {};
  const groups=Array.isArray(skills?.groups)?skills.groups:[];
  const additional=asStringArr(skills?.additional, 200);
  if(groups.length || additional.length){
    addTitle(L.skills);
    for(const g of groups.slice(0,12)){
      const label=String(g?.label||"").trim();
      const items=asStringArr(g?.items, 200);
      if(label && items.length) lines.push(label+": "+items.join(", "));
      else if(items.length) lines.push(items.join(", "));
    }
    if(additional.length) lines.push(additional.join(", "));
  }

  // Courses
  const courses=asStringArr(doc?.courses, 80);
  if(courses.length){ addTitle(L.courses); lines.push(courses.join(" Â· ")); }

  // Interests
  const interests=asStringArr(doc?.interests, 80);
  if(interests.length){ addTitle(L.interests); lines.push(interests.join(" Â· ")); }

  // Languages
  const langs=asStringArr(doc?.languages, 40);
  if(langs.length){ addTitle(L.languages); lines.push(langs.join(" Â· ")); }

  return lines.join("\n").trim()+"\n";
}

async function copyTailor(){
  try{
    let t = currentTailorText || "";
    if(!t && currentTailorDoc){
      const lang = (currentTailorResult && currentTailorResult.language) ? currentTailorResult.language : "en";
      t = cvDocToPlainText(currentTailorDoc, lang);
    }
    if(!t){ alert("Nothing to copy yet."); return; }
    await navigator.clipboard.writeText(t);
    alert("CV copied.");
  }catch(e){
    const fallback = currentTailorText || "";
    window.prompt("Copy CV:", fallback);
  }
}


function openSkipModal(jobId){
pendingSkipJobId=jobId;
document.getElementById("skipNote").value="";
document.getElementById("skipReason").value="not_relevant";
document.getElementById("skipModal").style.display="flex";
}
function closeSkipModal(){
pendingSkipJobId=null;
document.getElementById("skipModal").style.display="none";
}

async function requireSession(){
const {data,error}=await supabaseClient.auth.getSession();
if(error) throw error;
if(!data||!data.session){
window.location.replace("./signup.html");
return null;
}
lastSessionToken=data.session.access_token;
return data.session;
}

async function apiGet(path,accessToken){
const res=await fetch(API_BASE+path,{method:"GET",headers:{"Authorization":"Bearer "+accessToken}});
const text=await res.text().catch(()=> "");
let json=null;
try{json=JSON.parse(text);}catch{json={raw:text};}
if(!res.ok){
let msg=text;
if(json){
  const e=(json.error||json.message||"").toString().trim();
  const d=(json.details||json.detail||"").toString().trim();
  if(e && d && d!==e) msg=e+" â€” "+d;
  else if(e) msg=e;
  else if(d) msg=d;
}
throw new Error(path+" failed: "+res.status+" "+msg);
}
return json;
}
async function apiPost(path,accessToken,body){
const res=await fetch(API_BASE+path,{
method:"POST",
headers:{
"Authorization":"Bearer "+accessToken,
"content-type":"application/json"
},
body:JSON.stringify(body||{})
});
const text=await res.text().catch(()=> "");
let json=null;
try{json=JSON.parse(text);}catch{json={raw:text};}
if(!res.ok){
let msg=text;
if(json){
  const e=(json.error||json.message||"").toString().trim();
  const d=(json.details||json.detail||"").toString().trim();
  if(e && d && d!==e) msg=e+" â€” "+d;
  else if(e) msg=e;
  else if(d) msg=d;
}
throw new Error(path+" failed: "+res.status+" "+msg);
}
return json;
}

// --- Tailored CV summaries (for ATS badge on cards) ---
function normalizeKeywordList(x){
  if(!x) return [];
  if(Array.isArray(x)) return x.map(v=>String(v||"").trim()).filter(Boolean);
  if(typeof x === "string"){
    const s=x.trim();
    if(!s) return [];
    try{
      const j=JSON.parse(s);
      if(Array.isArray(j)) return j.map(v=>String(v||"").trim()).filter(Boolean);
    }catch{}
    return s.split(/[\n,;]+/).map(t=>t.trim()).filter(Boolean);
  }
  return [];
}

function computeAtsMatchPercent(used, missing){
  const u=normalizeKeywordList(used);
  const m=normalizeKeywordList(missing);
  const denom=u.length + m.length;
  if(denom<=0) return null;
  return Math.round((u.length/denom)*100);
}

async function loadTailorSummariesForJobs(jobIds){
  // Always keep the UI usable even if this fails
  tailorSummaryMap.clear();

  const ids=Array.isArray(jobIds)?jobIds:[];
  const uniq=[...new Set(ids.map(x=>String(x||"").trim()).filter(Boolean))];
  if(uniq.length===0) return;

  // Chunk to avoid long URLs
  const chunkSize=40;
  for(let i=0;i<uniq.length;i+=chunkSize){
    const chunk=uniq.slice(i,i+chunkSize);
    try{
      const qs="job_ids="+encodeURIComponent(chunk.join(","));
      const res=await apiGet("/me/cv/tailored?"+qs, lastSessionToken);
      const rows=(res && Array.isArray(res.data))?res.data:[];
      for(const row of rows){
        if(row && row.job_id) tailorSummaryMap.set(String(row.job_id), row);
      }
    }catch(err){
      console.warn("loadTailorSummariesForJobs failed", err);
      // Don't break the dashboard if this fails
      return;
    }
  }
}


function planFromState(planId){
const pid=String(planId||"").trim().toLowerCase();
if(pid==="starter") return {id:"starter",name:"Starter",daily:1,meta:"1 application/day",short:"Starter (1/day)"};
if(pid==="pro") return {id:"pro",name:"Growth",daily:5,meta:"5 applications/day",short:"Growth (5/day)"};
if(pid==="max") return {id:"max",name:"Max",daily:10,meta:"10 applications/day",short:"Max (10/day)"};
return {id:null,name:"No plan",daily:0,meta:"Select Starter / Growth / Max",short:"No plan"};
}
function planFallbackFromLocalStorage(){
const raw=(localStorage.getItem("jm_plan")||localStorage.getItem("ja_plan")||"").trim().toLowerCase();
if(raw==="starter"||raw==="pro"||raw==="max") return planFromState(raw);
return planFromState(null);
}

function computeSupply(queueCount,planDaily){
let healthLabel="Low";
let badgeType="warn";
let recommendedCap=1;
if(queueCount>=25){healthLabel="Healthy";badgeType="good";recommendedCap=10;}
else if(queueCount>=5){healthLabel="Medium";badgeType="";recommendedCap=5;}
let note="";
if(!planDaily) note="Select a plan to start.";
else if(queueCount===0) note="No jobs in your queue yet. Broaden titles or increase radius.";
else if(queueCount<planDaily) note="Your queue is below your plan. Increase titles/radius to avoid running out.";
else note="You have enough supply for today.";
let ratio=0;
if(planDaily&&planDaily>0) ratio=Math.min(1,queueCount/(planDaily*5));
else ratio=Math.min(1,queueCount/10);
return {healthLabel,badgeType,recommendedCap,note,ratio};
}
function renderHealth(queueCount,plan){
const s=computeSupply(queueCount,plan.daily);
setBadge("badgeHealth",s.badgeType,s.healthLabel);
setText("kpiHealthLabel",s.healthLabel);
setBadge("badgeHealthPlan",plan.daily?"":"warn","Plan: "+plan.short);
setBadge("badgeHealthQueue",queueCount>0?"good":"warn","Queue: "+queueCount);
setBadge("badgeHealthCap","","Today cap: "+(plan.daily?plan.daily:0)+"/day");
const meter=document.getElementById("healthMeterFill");
if(meter) meter.style.width=Math.round(s.ratio*100)+"%";
setHtml("healthNote",
'<div class="mono">Recommended cap based on supply: '+s.recommendedCap+'/day</div>'+
'<div class="mono" style="margin-top:6px">'+escapeHtml(s.note)+'</div>'
);
}

function isSingleColumn(){
return window.matchMedia && window.matchMedia("(max-width: 1100px)").matches;
}

function daysAgo(ts){
  if(!ts) return null;
  let d=new Date(ts);
  if(isNaN(d.getTime())){
    const m=String(ts).match(/^(\d{4}-\d{2}-\d{2})/);
    if(!m) return null;
    d=new Date(m[1] + "T00:00:00Z");
    if(isNaN(d.getTime())) return null;
  }
  const diffMs=Date.now() - d.getTime();
  const days=Math.floor(diffMs / 86400000);
  return days < 0 ? 0 : days;
}

function renderQueueCards(queue){
  const items=Array.isArray(queue?.data)?queue.data:[];
  const qCount=(typeof queue?.count==="number") ? queue.count : items.length;

  // Dashboard intentionally does NOT list jobs here (job titles are shown on the Jobs page).
  if(qCount<=0){
    return [
      '<div class="item">',
        '<div class="itemTitle">Your queue is empty</div>',
        '<div class="itemMeta"><span>Fetch jobs to get started, or broaden your titles/radius in Profile.</span></div>',
        '<div class="itemActions">',
          '<a class="btn small" href="./profile.html" data-nav="1">Improve search settings</a>',
          '<a class="btn small ghost" href="./jobs.html" data-nav="1">Open Jobs</a>',
        '</div>',
      '</div>'
    ].join("");
  }

  const prioCount = items.filter(j => j && j._application && j._application.priority).length;

  const dOf = (j)=>daysAgo((j && (j.source_modified_at || j.posted_at)) || null);
  const freshCount = items.filter(j=>{ const d=dOf(j); return d!==null && d<=2; }).length;
  const staleCount = items.filter(j=>{ const d=dOf(j); return d!==null && d>=10; }).length;

  // Top locations (aggregated, no titles)
  const locMap=new Map();
  for(const j of items){
    const city=j && j.city ? String(j.city) : "";
    const region=j && j.region ? String(j.region) : "";
    const loc=[city, region].map(s=>String(s||"").trim()).filter(Boolean).join(", ").trim();
    if(!loc) continue;
    const k=loc.toLowerCase();
    const prev=locMap.get(k);
    locMap.set(k, { label: loc, n: (prev?prev.n:0)+1 });
  }
  const topLoc=[...locMap.values()].sort((a,b)=>b.n-a.n).slice(0,3);
  const locLine = topLoc.length ? topLoc.map(x=>`${escapeHtml(x.label)} (${x.n})`).join(" Â· ") : "â€”";

  const supply = computeSupply(qCount, currentPlanDaily || 0);
  const planTxt = currentPlanDaily ? (String(currentPlanDaily)+"/day") : "no plan";
  const estDays = (currentPlanDaily && currentPlanDaily>0) ? Math.floor(qCount / currentPlanDaily) : null;
  const cover = (estDays===null) ? "â€”" : (estDays===0 ? "today" : (String(estDays)+" day"+(estDays===1?"":"s")));

  const wrapClass=isSingleColumn() ? "list" : "listGrid";

  return `
    <div class="${wrapClass}">
      <div class="item">
        <div class="itemTop">
          <div class="itemTitle">Supply overview</div>
          <div class="badgeGroup"><span class="badge ${escapeHtml(supply.badgeType||"")}">${escapeHtml(supply.healthLabel||"")}</span></div>
        </div>
        <div class="itemMeta">
          <span><b>${qCount}</b> jobs ready</span><span>â€¢</span>
          <span>Plan: ${escapeHtml(planTxt)}</span><span>â€¢</span>
          <span>Coverage: ${escapeHtml(cover)}</span>
        </div>
        <div class="tagRow">
          <span class="tag ok">Fresh â‰¤2d: <b>${freshCount}</b></span>
          <span class="tag ${prioCount? "ok":"warn"}">Prioritized: <b>${prioCount}</b></span>
          <span class="tag ${staleCount? "warn":"ok"}">Stale â‰¥10d: <b>${staleCount}</b></span>
        </div>
        <div class="hr"></div>
        <div class="mono">${escapeHtml(supply.note || "")}</div>
      </div>

      <div class="item">
        <div class="itemTitle">Next steps</div>
        <div class="itemMeta"><span>Use Jobs for job-level actions (prio, skip, apply).</span></div>
        <div class="itemActions">
          <a class="btn small" href="./jobs.html" data-nav="1">Open Jobs</a>
          <a class="btn small ghost" href="./profile.html" data-nav="1">Adjust titles & radius</a>
          <a class="btn small ghost" href="./plan.html" data-nav="1">Auto-apply (upgrade)</a>
        </div>
      </div>

      <div class="item">
        <div class="itemTitle">Top locations</div>
        <div class="mono" style="margin-top:8px">${locLine}</div>
        <div class="small" style="margin-top:10px">Based on your current queue (no job titles shown).</div>
      </div>

      <div class="item">
        <div class="itemTitle">Fetch cadence</div>
        <div class="mono" style="margin-top:8px">Manual fetch is rate-limited to prevent spam. Use â€œAI titles onlyâ€ for exploration when available.</div>
        <div class="small" style="margin-top:10px">Tip: Generate AI suggestions in Profile to unlock AI titles.</div>
      </div>
    </div>
  `;
}


function wireQueueClicks(){
const wrap=document.getElementById("queueWrap");
if(!wrap) return;
wrap.addEventListener("click", async (e)=>{
const skip=e.target.closest("button[data-skip]");
if(skip){
const jobId=skip.getAttribute("data-skip")||"";
if(jobId) openSkipModal(jobId);
return;
}

const desc=e.target.closest("button[data-desc]");
if(desc){
const jobId=desc.getAttribute("data-desc")||"";
if(jobId) openDescModal(jobId);
return;
}

const tl=e.target.closest("button[data-tailor]");
if(tl){
const jobId=tl.getAttribute("data-tailor")||"";
if(jobId) openTailorModal(jobId, false);
return;
}
const pr=e.target.closest("button[data-prio]");
if(pr){
const jobId=pr.getAttribute("data-prio")||"";
if(!jobId) return;
try{
await apiPost("/me/applications/prioritize", lastSessionToken, { job_id: jobId });
await refreshQueueAndActivity();
updateFetchButtonCooldownUI();
updateFetchMetaUI();
updateAiSwitchState();
}catch(err){ showTopError(err.message); }
return;
}
const un=e.target.closest("button[data-unprio]");
if(un){
const jobId=un.getAttribute("data-unprio")||"";
if(!jobId) return;
try{
await apiPost("/me/applications/unprioritize", lastSessionToken, { job_id: jobId });
await refreshQueueAndActivity();
}catch(err){ showTopError(err.message); }
}
});
}

async function submitSkip(){
if(!pendingSkipJobId) return;

const minSupply=Math.max(5, currentPlanDaily * 3);
if(currentPlanDaily > 0 && currentQueueCount <= minSupply){
const el=document.getElementById("skipGuardrail");
if(el){
el.style.display="block";
el.style.color="rgba(255,179,0,.95)";
el.textContent="Skipping is limited because your queue is getting low. Add more titles or increase radius to keep daily applications running.";
}
closeSkipModal();
return;
}

const reason_code=document.getElementById("skipReason").value;
const reason_note=document.getElementById("skipNote").value.trim();

try{
await apiPost("/me/applications/skip", lastSessionToken, {
job_id: pendingSkipJobId,
reason_code,
reason_note
});
closeSkipModal();
await refreshQueueAndActivity();
}catch(e){
closeSkipModal();
showTopError(e.message);
}
}

async function undoSkip(jobId){
try{
await apiPost("/me/applications/unskip", lastSessionToken, { job_id: jobId });
await refreshQueueAndActivity();
}catch(e){
showTopError(e.message);
}
}

function fmtDate(ts){
if(!ts) return "â€”";
try{return String(ts).replace("T"," ").slice(0,16);}catch{return String(ts).slice(0,16);}
}

function timeBucket(ts){
if(!ts) return "";
return String(ts).slice(0,16);
}
function sentKey(ev){
const jobId=ev && ev.job && ev.job.id ? String(ev.job.id) : "";
return jobId + "|" + timeBucket(ev.created_at);
}
function eventBadge(type){
const t=String(type||"").toLowerCase();
if(t==="applied"||t==="sent"||t==="replied") return {cls:"good", label:t};
if(t==="rejected") return {cls:"bad", label:t};
if(t==="skipped") return {cls:"warn", label:t};
if(t==="prioritized") return {cls:"prio", label:"prio"};
if(t==="unprioritized") return {cls:"", label:"unprio"};
if(t==="queued") return {cls:"", label:"queued"};
if(t==="unskipped") return {cls:"", label:"undo"};
return {cls:"", label:t||"event"};
}

function renderEventsTable(resp){
const items=Array.isArray(resp?.data) ? resp.data : [];
if(items.length===0) return '<span class="badge warn">No events yet</span>';

const list=items.slice(0,30);

const sentByKey=new Map();
for(const ev of list){
if(String(ev.event_type||"").toLowerCase() !== "sent") continue;
sentByKey.set(sentKey(ev), ev);
}

const appliedKeys=new Set();
for(const ev of list){
if(String(ev.event_type||"").toLowerCase() !== "applied") continue;
appliedKeys.add(sentKey(ev));
}

const visible=list.filter(ev=>{
const t=String(ev.event_type||"").toLowerCase();
if(t !== "sent") return true;
return !appliedKeys.has(sentKey(ev));
});

const rows=visible.map(ev=>{
const b=eventBadge(ev.event_type);
const job=ev.job||{};
const title=job.title||"Untitled";
const company=job.company_name||"â€”";
const loc=[job.city||"", job.region||""].filter(Boolean).join(", ") || "â€”";
const when=fmtDate(ev.created_at);
const link=job.apply_url?String(job.apply_url):"";
const titleCell=link ? ('<a href="'+escapeHtml(link)+'" target="_blank" rel="noopener">'+escapeHtml(title)+'</a>') : escapeHtml(title);

let metaTxt="â€”";
const t=String(ev.event_type||"").toLowerCase();

if(t === "applied"){
const s=sentByKey.get(sentKey(ev));
if(s && s.meta && typeof s.meta === "object"){
const ch=s.meta.channel || "email_manual";
const fe=s.meta.from_email || "";
const proofHtml="via " + escapeHtml(ch) + (fe ? "<br><span class='mono'>from " + escapeHtml(fe) + "</span>" : "");
metaTxt="<button class='btn small ghost' type='button' data-proof='1'>Show proof</button>"
+ "<div style='display:none;margin-top:8px' class='mono' data-proof-box='1'>" + proofHtml + "</div>";
}
}

if(metaTxt === "â€”" && ev.meta && typeof ev.meta === "object"){
if(t === "sent"){
const ch=ev.meta.channel || "email_manual";
const fe=ev.meta.from_email || "";
metaTxt="via " + escapeHtml(ch) + (fe ? "<br><span class='mono'>from " + escapeHtml(fe) + "</span>" : "");
} else if(t === "queued" && ev.meta && (ev.meta.fetch_mode || ev.meta.source)){
metaTxt = "fetch: " + escapeHtml(String(ev.meta.fetch_mode || ev.meta.source));
} else if(ev.meta.reason_code){
metaTxt="reason: " + escapeHtml(String(ev.meta.reason_code));
}
}

const actionBtn=(t==="skipped" && job.id)
? "<button class='btn small ghost' type='button' data-unskip='"+escapeHtml(job.id)+"'>Undo</button>"
: "â€”";

return "<tr>"
+ "<td><span class='badge "+b.cls+"'>"+escapeHtml(b.label)+"</span></td>"
+ "<td>"+titleCell+"</td>"
+ "<td>"+escapeHtml(company)+"</td>"
+ "<td>"+escapeHtml(loc)+"</td>"
+ "<td>"+escapeHtml(when)+"</td>"
+ "<td>"+metaTxt+"</td>"
+ "<td>"+actionBtn+"</td>"
+ "</tr>";
}).join("");

return '<div class="tableWrap"><table class="table">'
+ '<thead><tr><th>Event</th><th>Job</th><th>Company</th><th>Location</th><th>Time</th><th>Meta</th><th>Action</th></tr></thead>'
+ '<tbody>'+rows+'</tbody></table></div>';
}

function renderApplicationsFallback(resp){
const items=Array.isArray(resp?.data)?resp.data:[];
if(items.length===0) return '<span class="badge warn">No activity yet</span>';

const rows=items.slice(0,30).map(a=>{
const st=String(a.status||"").toLowerCase();
const cls=st==="applied" ? "good" : st==="rejected" ? "bad" : st==="skipped" ? "warn" : "";
const job=a.job||{};
const title=job.title||"Untitled";
const company=job.company_name||"â€”";
const loc=[job.city||"", job.region||""].filter(Boolean).join(", ") || "â€”";
const when=fmtDate(a.updated_at || a.created_at);
const link=job.apply_url?String(job.apply_url):"";
const titleCell=link ? ('<a href="'+escapeHtml(link)+'" target="_blank" rel="noopener">'+escapeHtml(title)+'</a>') : escapeHtml(title);
const actionBtn=(st==="skipped" && job.id) ? "<button class='btn small ghost' type='button' data-unskip='"+escapeHtml(job.id)+"'>Undo</button>" : "â€”";

return "<tr>"
+ "<td><span class='badge "+cls+"'>"+escapeHtml(st||"new")+"</span></td>"
+ "<td>"+titleCell+"</td>"
+ "<td>"+escapeHtml(company)+"</td>"
+ "<td>"+escapeHtml(loc)+"</td>"
+ "<td>"+escapeHtml(when)+"</td>"
+ "<td>"+actionBtn+"</td>"
+ "</tr>";
}).join("");

return '<div class="tableWrap"><table class="table">'
+ '<thead><tr><th>Status</th><th>Job</th><th>Company</th><th>Location</th><th>Time</th><th>Action</th></tr></thead>'
+ '<tbody>'+rows+'</tbody></table></div>';
}


function safeMs(ts){
  if(!ts) return null;
  try{
    const d=new Date(ts);
    const t=d.getTime();
    return isNaN(t) ? null : t;
  }catch{
    return null;
  }
}

function countTypeSince(items, type, sinceMs){
  const arr=Array.isArray(items)?items:[];
  const t=String(type||"").toLowerCase();
  let n=0;
  for(const it of arr){
    const kind=String((it && (it.event_type || it.status)) || "").toLowerCase();
    if(kind !== t) continue;
    const ms=safeMs(it.created_at || it.updated_at);
    if(ms===null || ms < sinceMs) continue;
    n++;
  }
  return n;
}

function renderActivitySnapshot(items){
  const arr=Array.isArray(items)?items:[];
  if(arr.length===0) return '<span class="badge warn">No activity yet</span>';

  const sinceMs=Date.now() - (7 * 86400000);
  const totalRecent = arr.filter(it=>{
    const ms=safeMs(it.created_at || it.updated_at);
    return ms!==null && ms>=sinceMs;
  }).length;

  const applied=countTypeSince(arr,"applied",sinceMs);
  const sent=countTypeSince(arr,"sent",sinceMs);
  const rejected=countTypeSince(arr,"rejected",sinceMs);
  const skipped=countTypeSince(arr,"skipped",sinceMs);
  const prioritized=countTypeSince(arr,"prioritized",sinceMs);

  const wrapClass=isSingleColumn() ? "list" : "listGrid";

  const tile=(title, value, badgeCls, hint)=>(
    '<div class="item">'
      + '<div class="itemTop">'
        + '<div class="itemTitle">'+escapeHtml(title)+'</div>'
        + '<div class="badgeGroup"><span class="badge '+escapeHtml(badgeCls||"")+'">'+escapeHtml(String(value))+'</span></div>'
      + '</div>'
      + '<div style="margin-top:8px;font-weight:950;font-size:30px;letter-spacing:-.02em">'+escapeHtml(String(value))+'</div>'
      + '<div class="small" style="margin-top:6px">'+escapeHtml(hint||"")+'</div>'
    + '</div>'
  );

  const tiles=[
    tile("Applied", applied, applied? "good":"", "last 7 days"),
    tile("Sent", sent, sent? "good":"", "emails/messages"),
    tile("Rejected", rejected, rejected? "bad":"", "last 7 days"),
    tile("Skipped", skipped, skipped? "warn":"", "last 7 days"),
  ].join("");

  const meta = '<div class="small" style="margin:8px 0 10px;color:rgba(17,19,24,.72)">'
    + 'Recent activity: <b>'+escapeHtml(String(totalRecent))+'</b> events in the last 7 days'
    + (prioritized ? (' Â· Prioritized: <b>'+escapeHtml(String(prioritized))+'</b>') : '')
    + '</div>';

  return meta + '<div class="'+wrapClass+'">'+tiles+'</div>';
}

function renderSnapshotSkeleton(){
  const wrapClass=isSingleColumn() ? "list" : "listGrid";
  const tile = '<div class="item"><div class="skeleton" style="height:14px;width:40%"></div><div style="height:10px"></div><div class="skeleton" style="height:26px;width:55%"></div><div style="height:10px"></div><div class="skeleton" style="height:12px;width:70%"></div></div>';
  return '<div class="'+wrapClass+'">'+tile+tile+tile+tile+'</div>';
}


async function loadActivity(accessToken){
setHtml("activityError","");
setHtml("activityWrap",renderSkeleton());
setHtml("activitySnapshot", renderSnapshotSkeleton());

if(useEventsEndpoint){
let path="/me/application-events?limit=120";
if(activityEventType) path += "&event_type=" + encodeURIComponent(activityEventType);
try{
const resp=await apiGet(path,accessToken);
setHtml("activitySnapshot", renderActivitySnapshot(resp && Array.isArray(resp.data) ? resp.data : []));
setHtml("activityWrap",renderEventsTable(resp));
return;
}catch(e){
useEventsEndpoint=false;
setHtml("activityError",'<div class="error">Timeline endpoint failed. Fallback to applications list. Details: '+escapeHtml(e.message)+'</div>');
}
}

let path="/me/applications?limit=120";
const map={ queued:"new", applied:"applied", rejected:"rejected", skipped:"skipped", prioritized:"new" };
if(activityEventType && map[activityEventType]) path += "&status=" + encodeURIComponent(map[activityEventType]);

try{
const resp=await apiGet(path,accessToken);
setHtml("activitySnapshot", renderActivitySnapshot(resp && Array.isArray(resp.data) ? resp.data : []));
setHtml("activityWrap",renderApplicationsFallback(resp));
}catch(e){
setHtml("activityWrap",'<span class="badge bad">Activity failed</span>');
setHtml("activitySnapshot", '<span class="badge bad">Snapshot failed</span>');
setHtml("activityError",'<div class="error">'+escapeHtml(e.message)+'</div>');
}
}

function wireActivityClicks(){
const wrap=document.getElementById("activityWrap");
if(!wrap) return;
wrap.addEventListener("click",(e)=>{
const unskip=e.target.closest("button[data-unskip]");
if(unskip){
const jobId=unskip.getAttribute("data-unskip")||"";
if(jobId) undoSkip(jobId);
return;
}
const proofBtn=e.target.closest("button[data-proof]");
if(proofBtn){
const cell=proofBtn.parentElement;
if(!cell) return;
const box=cell.querySelector("[data-proof-box='1']");
if(!box) return;
const isOpen=box.style.display === "block";
box.style.display=isOpen ? "none" : "block";
proofBtn.textContent=isOpen ? "Show proof" : "Hide proof";
}
});
}



const FETCH_COOLDOWN_MS = 10 * 60 * 1000;
function getNextFetchAllowedAt(){
const v = Number(localStorage.getItem("jm_last_manual_fetch_ts") || "0");
return v ? (v + FETCH_COOLDOWN_MS) : 0;
}
function updateFetchButtonCooldownUI(){
const btn=document.getElementById("btnFetchJobsNow");
const status=document.getElementById("fetchJobsStatus");
if(!btn) return;
const next = getNextFetchAllowedAt();
const now = Date.now();
if(next && now < next){
const sec = Math.ceil((next-now)/1000);
btn.disabled = true;
btn.textContent = "Fetch new jobs";
if(status && !status.textContent) status.textContent = "You can fetch again in " + sec + "s";
setTimeout(updateFetchButtonCooldownUI, 1000);
}else{
btn.disabled = false;
}
}

function updateFetchMetaUI(){
const meta=document.getElementById("fetchMeta");
if(!meta) return;

const lastTs = Number(localStorage.getItem("jm_last_manual_fetch_ts") || "0");
if(!lastTs){
meta.textContent = "";
return;
}

const last = new Date(lastTs).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
const next = lastTs + FETCH_COOLDOWN_MS;
const now = Date.now();

if(now < next){
const sec = Math.ceil((next-now)/1000);
const min = Math.floor(sec/60);
const s = sec % 60;
meta.textContent = "Last fetch: " + last + " Â· Next fetch in " + min + ":" + String(s).padStart(2,"0");
}else{
meta.textContent = "Last fetch: " + last + " Â· You can fetch again now";
}
}

function updateAiSwitchState(){
const toggle = document.getElementById("toggleAiOnly");
const hint = document.getElementById("aiSwitchHint");
if(!toggle || !hint) return;

const titles = Array.isArray(window.lastAiTitleSuggestions) ? window.lastAiTitleSuggestions : [];
const aiAvailable = titles.length > 0;

if(aiAvailable){
toggle.disabled = false;
hint.style.display = "none";
}else{
toggle.disabled = true;
toggle.checked = false;
hint.style.display = "inline-flex";
}
}

// Manual fetch (button) + AI titles toggle
function getAiTitlesForFetch(){
try{
const {p,c}=getAiJson();
const titles=[];
if(p && Array.isArray(p.job_titles)) for(const t of p.job_titles) titles.push(t);
if(c && Array.isArray(c.alternative_titles)) for(const t of c.alternative_titles) titles.push(t);
const seen=new Set();
const out=[];
for(const t of titles){
const s=String(t||"").trim();
if(!s) continue;
const k=s.toLowerCase();
if(seen.has(k)) continue;
seen.add(k);
out.push(s);
}
return out;
}catch{
return [];
}
}

async function manualFetchJobs(){
const btn=document.getElementById("btnFetchJobsNow");
const status=document.getElementById("fetchJobsStatus");
const toggle=document.getElementById("toggleAiOnly");

const setState=(loading,msg)=>{
if(btn){
btn.disabled=!!loading;
btn.textContent=loading ? "Fetching..." : "Fetch new jobs";
}
if(status) status.textContent=msg||"";
};

try{
const next = getNextFetchAllowedAt();
if(next && Date.now() < next){
const sec = Math.ceil((next-Date.now())/1000);
setState(false, "Please wait " + sec + "s before fetching again.");
updateFetchButtonCooldownUI();
updateFetchMetaUI();
return;
}
if(!lastSessionToken) await requireSession();
// start cooldown immediately to prevent double-click spamming
localStorage.setItem("jm_last_manual_fetch_ts", String(Date.now()));
updateFetchButtonCooldownUI();
updateFetchMetaUI();
const aiOnly=!!(toggle && toggle.checked);
const aiTitles=aiOnly ? getAiTitlesForFetch() : [];

setState(true, aiOnly ? "Fetching (AI titles only)..." : "Fetching...");

const resp=await apiPost("/me/jobs/fetch", lastSessionToken, {
include_ai_titles: aiOnly,
ai_titles: aiTitles,
fetch_mode: aiOnly ? "ai_only" : "profile"
});

if(resp && resp.skipped){
if(resp.reason==="queue_full"){
setState(false, "Skipped: queue has "+resp.queue_new_count+" new jobs (cap "+resp.max_queue_new+").");
} else {
setState(false, "Skipped: "+String(resp.reason||""));
}
return;
}

const added=typeof resp.jobs_added==="number" ? resp.jobs_added : 0;
const q=typeof resp.queue_new_count==="number" ? resp.queue_new_count : "â€”";
const rad=(resp.used_radius!==undefined && resp.used_radius!==null) ? resp.used_radius : "â€”";
const ml=(resp.match_level!==undefined && resp.match_level!==null) ? resp.match_level : "â€”";

setState(false, "Added "+added+" Â· Queue new: "+q+" Â· Radius "+rad+"km Â· Match "+ml);
updateFetchMetaUI();
await refreshQueueAndActivity();
}catch(e){
setState(false, e && e.message ? e.message : "Fetch failed");
showTopError(e && e.message ? e.message : "Fetch failed");
}
}

async function refreshQueueAndActivity(){
const queue=await apiGet("/me/jobs/queue", lastSessionToken);
lastQueueResponse=queue;
const qCount=(typeof queue.count==="number")?queue.count:(Array.isArray(queue.data)?queue.data.length:0);
currentQueueCount=qCount;
setHtml("queueWrap",renderQueueCards(queue));
await loadActivity(lastSessionToken);
}

function renderAppsBreakdown(summary){
const counts=summary&&summary.counts?summary.counts:null;
if(!counts||typeof counts!=="object") return '<span class="badge warn">Not available</span>';
const entries=Object.entries(counts);
if(entries.length===0) return '<span class="badge warn">No applications yet</span>';
entries.sort((a,b)=>String(a[0]).localeCompare(String(b[0])));
const rows=entries.map(([k,v])=>"<tr><td>"+escapeHtml(k)+"</td><td>"+escapeHtml(v)+"</td></tr>").join("");
return '<div class="tableWrap" style="margin-top:8px"><table class="table" style="min-width:520px"><thead><tr><th>Status</th><th>Count</th></tr></thead><tbody>'+rows+'</tbody></table></div>';
}

function renderOnboardingChecks(state){
const items=[];
const profileOk=!!state.profile_complete;
const planOk=!!state.plan_id;
const cvOk=!!state.cv_uploaded;
const ocrOk=(String(state.cv_ocr_status||"").toLowerCase()==="done");
items.push({label:"Profile complete",ok:profileOk,fix:"profile.html"});
items.push({label:"Plan selected",ok:planOk,fix:"plan.html"});
items.push({label:"CV uploaded",ok:cvOk,fix:"profile.html"});
items.push({label:"OCR done",ok:ocrOk,fix:"profile.html"});
return items.map(it=>{
const cls=it.ok?"badge good":"badge warn";
const right=it.ok?'OK':('<a href="'+it.fix+'" style="text-decoration:underline">Fix</a>');
return '<div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 0"><span class="'+cls+'">'+escapeHtml(it.label)+'</span><span class="small">'+right+'</span></div>';
}).join("");
}

function getAiJson(){
try{
const pRaw=localStorage.getItem("jm_ai_profile") || localStorage.getItem("ja_ai_profile");
const cRaw=localStorage.getItem("jm_ai_clusters") || localStorage.getItem("ja_ai_clusters");
return {
p: pRaw ? JSON.parse(pRaw) : null,
c: cRaw ? JSON.parse(cRaw) : null
};
}catch{
return {p:null,c:null};
}
}

function renderAiInsightsFromCache(){
try{
const {p,c}=getAiJson();
const has=!!(p && (p.job_titles || p.skills));
if(!has){
setBadge("badgeAi","warn","Locked");
setText("aiInsightsHint","Generate suggestions in Profile to unlock this.");
setHtml("aiTopTitles","");
setHtml("aiAltRoles","");
setHtml("aiTopSkills","");
return;
}

setBadge("badgeAi","good","Ready");
const created=p.created_at ? String(p.created_at).replace("T"," ").slice(0,16) : "";
setText("aiInsightsHint", created ? ("Last updated: "+created) : "Last updated: â€”");

const titles=Array.isArray(p.job_titles) ? p.job_titles.slice(0,5) : [];
setHtml("aiTopTitles", titles.map(t=>'<span class="pill mini">'+escapeHtml(t)+'</span>').join("") || '<span class="badge warn">No titles</span>');

const alt=c && Array.isArray(c.alternative_titles) ? c.alternative_titles.slice(0,5) : [];
setHtml("aiAltRoles", alt.map(t=>'<span class="pill mini">'+escapeHtml(t)+'</span>').join("") || '<span class="badge warn">No alternatives yet</span>');

const core=p.skills && Array.isArray(p.skills.core) ? p.skills.core.slice(0,6) : [];
const tools=p.skills && Array.isArray(p.skills.tools) ? p.skills.tools.slice(0,4) : [];
const skills=[];
for(const s of core) skills.push(s);
for(const s of tools) skills.push(s);
const seen=new Set();
const uniq=[];
for(const s of skills){
const k=String(s).toLowerCase();
if(!k || seen.has(k)) continue;
seen.add(k);
uniq.push(s);
}
setHtml("aiTopSkills", uniq.map(s=>'<span class="pill mini">'+escapeHtml(s)+'</span>').join("") || '<span class="badge warn">No skills</span>');
}catch{
setBadge("badgeAi","warn","Locked");
setText("aiInsightsHint","Generate suggestions in Profile to unlock this.");
}
}

async function loadDashboard(){
clearTopError();
setText("errorBox","");
setHtml("queueError","");
setText("lastCheck",nowStamp());
setBadge("badgeQueue","","Loading");
setBadge("badgeApps","","Loading");
setBadge("badgePlan","","Loading");
setBadge("badgeHealth","","Loading");
setHtml("queueWrap",renderSkeleton());
setHtml("appsBreakdown",renderSkeleton());
setHtml("onboardingChecks",renderSkeleton());
setHtml("activityWrap",renderSkeleton());
setHtml("activitySnapshot", renderSnapshotSkeleton());
setHtml("activityError","");

const session=await requireSession();
if(!session) return;

// Load profile (for persisted AI titles)
try{
const profResp = await apiGet("/me/profile", lastSessionToken);
const p = profResp && profResp.profile ? profResp.profile : null;
window.lastAiTitleSuggestions = (p && Array.isArray(p.ai_titles)) ? p.ai_titles : [];
}catch(e){
window.lastAiTitleSuggestions = [];
}
updateAiSwitchState();

const email=session.user&&session.user.email?session.user.email:"â€”";
setText("meEmail",email);
setText("subLine","Signed in as "+email);
try{
  const acc=document.getElementById("navAccount");
  const sign=document.getElementById("navSignIn");
  if(acc) acc.style.display="";
  if(sign) sign.style.display="none";

  const lbl=document.getElementById("navAccountLabel");
  if(lbl){
    const base = (email && String(email).includes("@")) ? String(email).split("@")[0] : "Account";
    lbl.textContent = base.length>14 ? (base.slice(0,14) + "â€¦") : base;
  }
}catch(_){ }


renderAiInsightsFromCache();

let state=null;
try{ state=await apiGet("/me/state",session.access_token); }catch{ state=null; }

// Load profile to get persisted AI titles (server source of truth)
try{
const prof = await apiGet("/me/profile", session.access_token);
const ai = prof && prof.profile && Array.isArray(prof.profile.ai_titles) ? prof.profile.ai_titles : [];
window.lastAiTitleSuggestions = ai;
localStorage.setItem("jm_ai_titles_server", JSON.stringify(ai));
}catch(e){
// fallback to cached AI titles
try{
const ai = JSON.parse(localStorage.getItem("jm_ai_titles_server") || "[]");
window.lastAiTitleSuggestions = Array.isArray(ai) ? ai : [];
}catch(_){
window.lastAiTitleSuggestions = [];
}
}

const plan=state&&state.plan_id?planFromState(state.plan_id):planFallbackFromLocalStorage();
currentPlanDaily=plan.daily;

setText("kpiPlanName",plan.name);
setText("kpiPlanMeta",plan.daily?plan.meta:"no plan selected");
setBadge("badgePlan",plan.daily?"good":"warn",plan.daily?"Selected":"Not selected");

if(state&&state.customer_id){ setText("meCustomerId",state.customer_id); }
if(state){ setHtml("onboardingChecks",renderOnboardingChecks(state)); }

try{
const queue=await apiGet("/me/jobs/queue",session.access_token);
lastQueueResponse=queue;
const qCount=(typeof queue.count==="number")?queue.count:(Array.isArray(queue.data)?queue.data.length:0);
currentQueueCount=qCount;

animateNumber(document.getElementById("kpiQueue"),qCount);
setBadge("badgeQueue",qCount>0?"good":"warn",qCount>0?"OK":"Empty");

setHtml("queueWrap",renderQueueCards(queue));
renderHealth(qCount,plan);
}catch(e){
setText("kpiQueue","â€“");
setBadge("badgeQueue","bad","Error");
setBadge("badgeHealth","bad","Error");
setHtml("queueWrap",'<span class="badge bad">Queue failed</span>');
setHtml("queueError",'<div class="error">'+escapeHtml(e.message)+'</div>');
setText("errorBox",e.message);
showTopError(e.message);
}

try{
const apps=await apiGet("/me/applications/summary",session.access_token);
const total=(typeof apps.total==="number")?apps.total:0;
animateNumber(document.getElementById("kpiAppsTotal"),total);
setBadge("badgeApps","good","OK");
setHtml("appsBreakdown",renderAppsBreakdown(apps));
}catch{
setText("kpiAppsTotal","â€“");
setBadge("badgeApps","warn","Not ready");
setHtml("appsBreakdown",'<span class="badge warn">Not available</span>');
}

await loadActivity(session.access_token);
}

function wireActivityFilters(){
const wrap=document.getElementById("activityFilters");
if(!wrap) return;
wrap.addEventListener("click", async (e)=>{
const btn=e.target.closest("button[data-etype]");
if(!btn) return;

const et=btn.getAttribute("data-etype")||"";
activityEventType=et;

for(const b of wrap.querySelectorAll(".chip")) b.classList.remove("active");
btn.classList.add("active");

if(lastSessionToken) await loadActivity(lastSessionToken);
});
}

function wireEvents(){
document.getElementById("btnRefresh").addEventListener("click",async()=>{
try{ await loadDashboard();
updateFetchButtonCooldownUI();
updateFetchMetaUI(); }catch(e){ showTopError(e.message); setText("errorBox",e.message); }
});
document.getElementById("btnFetchJobsNow").addEventListener("click",async()=>{
await manualFetchJobs();
});


// Quick actions
const qaFetch=document.getElementById("qaFetchJobs");
if(qaFetch){
  qaFetch.addEventListener("click",()=>{
    const b=document.getElementById("btnFetchJobsNow");
    if(b) b.click();
    else manualFetchJobs();
  });
}

const qaView=document.getElementById("qaViewQueue");
if(qaView){
  qaView.addEventListener("click",()=>{
    go("./jobs.html");
  });
}

const qaTailor=document.getElementById("qaTailorTop");
if(qaTailor){
  qaTailor.addEventListener("click",()=>{
    try{
      const jobs=(lastQueueResponse && Array.isArray(lastQueueResponse.data)) ? lastQueueResponse.data : [];
      if(!jobs.length){
        setText("qaStatus","No jobs in your queue yet. Click â€œSearch jobs (fetch)â€ first.");
        return;
      }
      const prioJob = jobs.find(j=>j && j._application && j._application.priority);
      const top = prioJob || jobs[0];
      const jobId = top && top.id ? String(top.id) : "";
      if(!jobId){
        setText("qaStatus","Could not find a job to tailor. Please refresh and try again.");
        return;
      }

      // Go to CV Studio with the chosen job
      try{
        localStorage.setItem("cvstudio_job_source", "queue");
        sessionStorage.removeItem("cvstudio_started");
      }catch(_){ }

      go("./cv.html?job_id="+encodeURIComponent(jobId));
      setText("qaStatus","");
    }catch(e){
      setText("qaStatus","Could not open CV Studio. Please open Jobs and select a job.");
    }
  });
}

document.getElementById("btnCopyToken").addEventListener("click",async()=>{
try{
const {data}=await supabaseClient.auth.getSession();
const token=data&&data.session?data.session.access_token:"";
if(!token){ alert("No session token found. Please sign in again."); return; }

// Some browsers block clipboard access depending on context (permissions/iframes).
// Fallback: show the token in a prompt so you can copy manually.
try{
await navigator.clipboard.writeText(token);
alert("Access token copied.");
return;
}catch(_clipboardErr){
// Fallback 1: hidden textarea + execCommand
try{
const ta=document.createElement("textarea");
ta.value=token;
ta.setAttribute("readonly","true");
ta.style.position="fixed";
ta.style.left="-9999px";
ta.style.top="0";
document.body.appendChild(ta);
ta.select();
const ok=document.execCommand && document.execCommand("copy");
document.body.removeChild(ta);
if(ok){
alert("Access token copied.");
return;
}
}catch(_){ /* ignore */ }

// Fallback 2: prompt
window.prompt("Copy your access token:", token);
}
}catch(e){
showTopError(e.message || "Copy token failed");
}
});
async function doLogout(){
  try{
    await supabaseClient.auth.signOut();
    Object.keys(localStorage).forEach(k=>{
      if(k.startsWith("ja_") || k.startsWith("jobapplyai_") || k.startsWith("jm_") || k.startsWith("jobmejob_") || k.startsWith("sb-")){
        localStorage.removeItem(k);
      }
    });
    try{sessionStorage.removeItem("sb_access_token");}catch{}
    window.location.replace("./index.html");
  }catch(e){
    showTopError((e && e.message) ? e.message : "Logout failed");
  }
}

// Logout buttons (legacy + account dropdown)
const btnLogout=document.getElementById("btnLogout");
if(btnLogout){ btnLogout.addEventListener("click", doLogout); }

const navLogout=document.getElementById("navLogout");
if(navLogout){
  navLogout.addEventListener("click", async ()=>{
    try{ const d=document.getElementById("navAccount"); if(d) d.open=false; }catch(_){ }
    await doLogout();
  });
}

// Account menu: jump to activity log section
const navActivity=document.getElementById("navActivity");
if(navActivity){
  navActivity.addEventListener("click", ()=>{
    try{
      const el=document.getElementById("activityFilters") || document.getElementById("activityWrap");
      if(el && el.scrollIntoView) el.scrollIntoView({behavior:"smooth", block:"start"});
    }catch(_){ }
    try{ const d=document.getElementById("navAccount"); if(d) d.open=false; }catch(_){ }
  });
}


wireQueueClicks();
wireActivityFilters();
wireActivityClicks();

document.getElementById("skipCancel").addEventListener("click",()=>closeSkipModal());
document.getElementById("skipConfirm").addEventListener("click",()=>submitSkip());

document.getElementById("skipModal").addEventListener("click",(e)=>{
if(e.target && e.target.id==="skipModal") closeSkipModal();
});

// Job description modal
document.getElementById("descClose").addEventListener("click",()=>closeDescModal());
document.getElementById("descCopy").addEventListener("click",()=>copyDesc());
document.getElementById("descModal").addEventListener("click",(e)=>{
if(e.target && e.target.id==="descModal") closeDescModal();
});

// Tailored CV modal
document.getElementById("tailorClose").addEventListener("click",()=>closeTailorModal());
document.getElementById("tailorCopy").addEventListener("click",()=>copyTailor());
document.getElementById("tailorDownload").addEventListener("click",()=>downloadTailor());
document.getElementById("tailorPrint").addEventListener("click",()=>printTailor());
document.getElementById("tailorRegenerate").addEventListener("click",()=>regenerateTailor());
document.getElementById("tailorModal").addEventListener("click",(e)=>{
if(e.target && e.target.id==="tailorModal") closeTailorModal();
});

// Tailor controls
const strengthEl=document.getElementById("tailorStrength");
if(strengthEl){
  strengthEl.addEventListener("input",()=>{
    updateTailorStrengthHelp();
    try{localStorage.setItem("tailor_strength", String(strengthEl.value));}catch{}
  });
  // Load saved value (if any)
  try{
    const saved=localStorage.getItem("tailor_strength");
    if(saved!==null && saved!==undefined && saved!=="") strengthEl.value=saved;
  }catch{}
}

const tplEl=document.getElementById("tailorTemplate");
if(tplEl){
  tplEl.addEventListener("change",()=>{
    try{localStorage.setItem("tailor_template", String(tplEl.value||"professional"));}catch{}
  });
  try{
    const saved=localStorage.getItem("tailor_template");
    if(saved) tplEl.value=saved;
  }catch{}
}

const viewPrev=document.getElementById("tailorViewPreview");
if(viewPrev){viewPrev.addEventListener("click",()=>setTailorView("preview"));}
const viewText=document.getElementById("tailorViewText");
if(viewText){viewText.addEventListener("click",()=>setTailorView("text"));}

updateTailorStrengthHelp();

}

window.addEventListener("load",async()=>{
try{
if(!window.supabase) throw new Error("Supabase library did not load. Check adblockers / network.");
supabaseClient=window.supabase.createClient(SUPABASE_URL,SUPABASE_ANON_KEY);
wireEvents();
await loadDashboard();
updateFetchButtonCooldownUI();
updateFetchMetaUI();
}catch(e){
showTopError(e.message);
setText("errorBox",e.message);
setBadge("badgeQueue","bad","Error");
setBadge("badgeApps","bad","Error");
setBadge("badgePlan","bad","Error");
setBadge("badgeHealth","bad","Error");
}
});


/* ============================================================
   BI Dashboard Redesign (KPI strip + trend + funnel + actions)
   - Keeps existing endpoints and UI primitives
   - No external chart libs (HTML bar chart + funnel bars)
   ============================================================ */

let dashRangeDays = 14;                 // controlled by Range chips (14d / 30d)
let dashPrimaryEventType = "sent";      // will fallback to "applied" if "sent" not present
let dashEventsCache = [];              // unfiltered events (for KPIs + charts)
let dashEventsMode = "events";         // "events" | "applications" | "none"
let dashEventsLoadedAt = 0;

function fmtInt(x){ return (typeof x === "number" && isFinite(x)) ? String(Math.round(x)) : "â€“"; }
function fmtPct(x){
  if(x===null || x===undefined || !isFinite(Number(x))) return "â€“";
  return (Math.round(Number(x)*10)/10).toFixed(1) + "%";
}
function fmtSigned(n){
  const v = Number(n);
  if(!isFinite(v) || v===0) return "0";
  return (v>0 ? "+" : "") + String(Math.round(v));
}

function startOfLocalDayMs(d){
  const x = d ? new Date(d) : new Date();
  return new Date(x.getFullYear(), x.getMonth(), x.getDate(), 0,0,0,0).getTime();
}
function localDayKeyFromMs(ms){
  const d = new Date(ms);
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const da = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${da}`;
}
function labelFromDayKey(key){
  // key is YYYY-MM-DD
  try{
    const d = new Date(key + "T00:00:00");
    return d.toLocaleDateString([], { month: "short", day: "numeric" });
  }catch{
    return key.slice(5);
  }
}

function getType(it){
  return String((it && (it.event_type || it.status)) || "").toLowerCase();
}
function getWhenMs(it){
  return safeMs(it && (it.created_at || it.updated_at));
}
function countTypeBetween(items, type, startMs, endMs){
  const arr = Array.isArray(items) ? items : [];
  const t = String(type||"").toLowerCase();
  let n = 0;
  for(const it of arr){
    if(getType(it) !== t) continue;
    const ms = getWhenMs(it);
    if(ms===null) continue;
    if(ms >= startMs && ms < endMs) n++;
  }
  return n;
}
function countAnyBetween(items, types, startMs, endMs){
  const set = new Set((types||[]).map(x=>String(x||"").toLowerCase()));
  const arr = Array.isArray(items) ? items : [];
  let n=0;
  for(const it of arr){
    const ty = getType(it);
    if(!set.has(ty)) continue;
    const ms = getWhenMs(it);
    if(ms===null) continue;
    if(ms >= startMs && ms < endMs) n++;
  }
  return n;
}

async function fetchDashboardEvents(accessToken, force){
  const TTL = 60 * 1000; // keep light; refresh after actions
  if(!force && dashEventsLoadedAt && (Date.now() - dashEventsLoadedAt) < TTL && Array.isArray(dashEventsCache) && dashEventsCache.length){
    return { mode: dashEventsMode, items: dashEventsCache };
  }

  // Try events endpoint first (best for timeline)
  try{
    const resp = await apiGet("/me/application-events?limit=600", accessToken);
    const items = Array.isArray(resp?.data) ? resp.data : [];
    dashEventsCache = items;
    dashEventsMode = "events";
    dashEventsLoadedAt = Date.now();
    return { mode:"events", items };
  }catch(e){
    // Fallback to applications list
    try{
      const resp = await apiGet("/me/applications?limit=600", accessToken);
      const items = Array.isArray(resp?.data) ? resp.data : [];
      dashEventsCache = items;
      dashEventsMode = "applications";
      dashEventsLoadedAt = Date.now();
      return { mode:"applications", items };
    }catch(e2){
      dashEventsCache = [];
      dashEventsMode = "none";
      dashEventsLoadedAt = Date.now();
      return { mode:"none", items:[], error: e2 };
    }
  }
}

function choosePrimaryEventType(items){
  // Prefer "sent" if present in last 30d; otherwise use "applied"
  const arr = Array.isArray(items) ? items : [];
  const since30 = Date.now() - (30*86400000);
  let sent30 = 0, applied30 = 0;
  for(const it of arr){
    const ms = getWhenMs(it);
    if(ms===null || ms < since30) continue;
    const t = getType(it);
    if(t==="sent") sent30++;
    if(t==="applied") applied30++;
  }
  return (sent30>0) ? "sent" : "applied";
}

function computeDailySeries(items, type, days){
  const n = Math.max(1, Number(days)||14);
  const keys = [];
  for(let i=n-1;i>=0;i--){
    const d = new Date();
    d.setDate(d.getDate() - i);
    keys.push(localDayKeyFromMs(d.getTime()));
  }
  const map = new Map(keys.map(k=>[k,0]));
  const arr = Array.isArray(items) ? items : [];
  const startMs = startOfLocalDayMs(new Date(Date.now() - (n-1)*86400000));
  for(const it of arr){
    if(getType(it) !== type) continue;
    const ms = getWhenMs(it);
    if(ms===null || ms < startMs) continue;
    const k = localDayKeyFromMs(ms);
    if(map.has(k)) map.set(k, (map.get(k)||0)+1);
  }
  const values = keys.map(k=>map.get(k)||0);
  const labels = keys.map(k=>labelFromDayKey(k));
  return { keys, labels, values };
}

function renderTrendBars(labels, values, cap){
  const vs = Array.isArray(values) ? values : [];
  const max = Math.max(1, ...(vs.length?vs:[0]), (Number(cap)||0));
  const capPct = (cap && isFinite(Number(cap))) ? Math.min(100, Math.max(0, (Number(cap)/max)*100)) : null;

  const cols = vs.map((v,i)=>{
    const h = Math.min(100, Math.max(0, (Number(v)/max)*100));
    const tip = `${labels[i]||""}: ${v}`;
    return `<div class="barCol" title="${escapeHtml(tip)}"><div class="bar" style="height:${h}%"></div></div>`;
  }).join("");

  const lbls = labels.map((l,i)=>{
    // show every 2nd label to reduce clutter
    const show = (labels.length<=10) ? true : (i%2===0);
    return `<div class="barLbl">${escapeHtml(show ? l : "")}</div>`;
  }).join("");

  return `
    <div class="barChartWrap">
      ${capPct!==null ? `<div class="capLine" style="bottom:${capPct}%"></div>` : ``}
      <div class="barChart">${cols}</div>
      <div class="barLblRow">${lbls}</div>
    </div>
  `;
}

function getTailorStatsFromMap(rangeDays){
  const total = tailorSummaryMap ? tailorSummaryMap.size : 0;
  let scored=0, sumScore=0;

  // For "recent tailored", use updated_at if present
  const sinceMs = Date.now() - ((Number(rangeDays)||14) * 86400000);
  let recent = 0;

  if(tailorSummaryMap && typeof tailorSummaryMap.forEach === "function"){
    tailorSummaryMap.forEach((row)=>{
      const score = (row && typeof row.ats_score === "number") ? row.ats_score : computeAtsMatchPercent(row?.ats_keywords_used, row?.ats_keywords_missing);
      if(score!==null && score!==undefined && isFinite(Number(score))){
        scored++;
        sumScore += Number(score);
      }
      const ms = safeMs(row && row.updated_at);
      if(ms!==null && ms>=sinceMs) recent++;
    });
  }

  const avg = scored ? Math.round((sumScore/scored)) : null;
  return { total, recent, avg };
}

function updateKpiStrip({ planDaily, queueCount, appsTotal, supply, eventsItems, primaryType }){
  // Today
  const startToday = startOfLocalDayMs();
  const endNow = Date.now() + 1;
  const today = countTypeBetween(eventsItems, primaryType, startToday, endNow);

  setText("kpiTodaySent", `${today}/${planDaily||0}`);
  setText("kpiTodaySentLabel", (primaryType==="applied") ? "applied today" : "sent today");
  setText("kpiTodaySentMeta", `Cap: ${planDaily||0}/day â€¢ ${today >= (planDaily||0) && planDaily ? "On track" : "Remaining: " + Math.max(0, (planDaily||0)-today)}`);

  const pct = (planDaily && planDaily>0) ? Math.min(1, today/planDaily) : (today>0 ? 1 : 0);
  const fill = document.getElementById("todayMeterFill");
  if(fill) fill.style.width = Math.round(pct*100) + "%";
  setBadge("badgeTodaySent", (planDaily && today>=planDaily) ? "good" : (today>0 ? "" : "warn"), (planDaily && today>=planDaily) ? "On track" : (today>0 ? "In progress" : "Start"));

  // Week (rolling 7d)
  const since7 = Date.now() - (7*86400000);
  const since14 = Date.now() - (14*86400000);
  const last7 = countTypeSince(eventsItems, primaryType, since7);
  const prev7 = countTypeBetween(eventsItems, primaryType, since14, since7);
  setText("kpiWeekSent", fmtInt(last7));
  setText("kpiWeekSentMeta", `vs prev 7d: ${fmtSigned(last7 - prev7)}`);
  setBadge("badgeWeekSent", (last7>0 ? "good" : "warn"), (last7>0 ? "Active" : "Low"));

  // Queue supply
  animateNumber(document.getElementById("kpiQueue"), queueCount);
  const coverDays = (planDaily && planDaily>0) ? (queueCount/planDaily) : null;
  const coverTxt = (coverDays===null) ? "â€”" : (coverDays<1 ? "today" : `${Math.floor(coverDays)} day${Math.floor(coverDays)===1?"":"s"}`);
  setText("kpiQueueMeta", `Coverage: ${coverTxt} â€¢ Fresh â‰¤2d: ${supply.freshCount ?? "â€”"}`);
  setBadge("badgeQueue", supply.badgeType || "", supply.healthLabel || "â€”");
  const sfill = document.getElementById("supplyMeterFill");
  if(sfill) sfill.style.width = Math.round((supply.ratio||0)*100) + "%";

  // Tailoring coverage
  const t = supply.tailorStats || { total:0, avg:null };
  const cov = (queueCount>0) ? (t.total/queueCount) : 0;
  setText("kpiTailorCoverage", queueCount>0 ? `${Math.round(cov*100)}%` : "â€”");
  setText("kpiTailorMeta", `Avg ATS: ${t.avg===null ? "â€”" : (String(t.avg)+"%")} â€¢ Tailored: ${t.total}`);
  setBadge("badgeTailor", (cov>=0.6 ? "good" : cov>0 ? "warn" : ""), (cov>=0.6 ? "Strong" : cov>0 ? "Some" : "None"));

  // Responses (30d)
  const since30 = Date.now() - (30*86400000);
  const sent30 = countTypeSince(eventsItems, primaryType, since30);
  const resp30 = countAnyBetween(eventsItems, ["replied","reply","response","responded"], since30, Date.now()+1);
  const rr = sent30>0 ? (resp30/sent30)*100 : null;
  setText("kpiResponseRate", rr===null ? "â€”" : fmtPct(rr));
  setText("kpiResponseMeta", `Responses: ${fmtInt(resp30)} â€¢ ${primaryType==="applied" ? "Applied" : "Sent"}: ${fmtInt(sent30)}`);
  setBadge("badgeResponse", (rr!==null && rr>=5) ? "good" : (rr!==null && rr>0 ? "" : "warn"), (rr===null ? "No data" : rr>=5 ? "Good" : rr>0 ? "Some" : "None"));

  // Plan + total apps
  setText("kpiAppsTotal", fmtInt(appsTotal));

  // Status pill (top-right)
  const statusEl = document.getElementById("dashStatusPill");
  if(statusEl){
    const onTrack = planDaily && today>=planDaily;
    const lowSupply = planDaily && coverDays!==null && coverDays<3;
    statusEl.className = "pill mini" + (onTrack ? " active" : "");
    statusEl.textContent = onTrack ? "On track today" : lowSupply ? "Queue needs attention" : "Keep going";
  }
}

function updateTrendAndFunnel({ planDaily, eventsItems, primaryType, rangeDays }){
  // Trend
  const series = computeDailySeries(eventsItems, primaryType, rangeDays);
  const cap = (planDaily && planDaily>0) ? planDaily : null;
  setHtml("trendChart", renderTrendBars(series.labels, series.values, cap));
  setText("trendMeta", `Last ${rangeDays} days Â· Bars = ${(primaryType==="applied")?"Applied":"Sent"} Â· Cap line = ${cap===null?"â€”":cap+"/day"}`);
  const totalRange = series.values.reduce((a,b)=>a+(Number(b)||0),0);
  const avgPerDay = totalRange / Math.max(1, rangeDays);
  setText("trendFoot", `Total: ${fmtInt(totalRange)} â€¢ Avg/day: ${fmtInt(avgPerDay)} â€¢ Best day: ${fmtInt(Math.max(...series.values))}`);
  setBadge("badgeTrend", totalRange>0 ? "good" : "warn", totalRange>0 ? "Active" : "No activity");

  // Funnel (same range as selected)
  const since = Date.now() - (rangeDays*86400000);
  const end = Date.now()+1;

  const queued = countTypeBetween(eventsItems, "queued", since, end);
  const prioritized = countTypeBetween(eventsItems, "prioritized", since, end);
  const applied = countTypeBetween(eventsItems, "applied", since, end);
  const sent = countTypeBetween(eventsItems, "sent", since, end);
  const replied = countAnyBetween(eventsItems, ["replied","reply","response","responded"], since, end);
  const rejected = countTypeBetween(eventsItems, "rejected", since, end);

  const tailorStats = getTailorStatsFromMap(rangeDays);
  const tailoredRecent = tailorStats.recent || 0;

  const steps = [
    { key:"queued", label:"Queued", n: queued },
    { key:"prioritized", label:"Prioritized", n: prioritized },
    { key:"tailored", label:"Tailored", n: tailoredRecent },
    { key:"applied", label:"Applied", n: applied },
    { key:"sent", label:"Sent", n: sent },
    { key:"replied", label:"Replied", n: replied },
  ];

  const max = Math.max(1, ...steps.map(s=>s.n||0));
  const rows = steps.map((s, idx)=>{
    const prev = idx===0 ? null : steps[idx-1].n;
    const conv = (prev && prev>0) ? Math.round((s.n/prev)*100) : null;
    const w = Math.round((s.n/max)*100);
    return `
      <div class="fRow">
        <div class="fLabel">${escapeHtml(s.label)}</div>
        <div class="fBarWrap"><div class="fBar" style="width:${w}%"></div></div>
        <div class="fVal">${escapeHtml(String(s.n||0))}</div>
        <div class="fConv">${conv===null ? "â€”" : (String(conv)+"%")}</div>
      </div>
    `;
  }).join("");

  // Bottleneck
  let worst = null;
  for(let i=1;i<steps.length;i++){
    const a = steps[i-1], b = steps[i];
    if(!a.n || a.n<=0) continue;
    const r = (b.n||0)/a.n; // lower is worse
    if(worst===null || r < worst.r){
      worst = { from:a.label, to:b.label, r };
    }
  }
  const bottleneckTxt = worst ? `Biggest drop: ${worst.from} â†’ ${worst.to} (${Math.round(worst.r*100)}% conversion)` : "";

  setHtml("funnelWrap", `<div class="funnel">${rows}</div>`);
  setText("funnelMeta", `Last ${rangeDays} days Â· Tailored uses your CV tailoring activity`);
  setText("funnelBottleneck", bottleneckTxt || (rejected ? `Rejected: ${rejected} (last ${rangeDays}d)` : ""));
  setBadge("badgeFunnel", (queued>0 || applied>0 || sent>0) ? "good" : "warn", (queued>0 || applied>0 || sent>0) ? "Ready" : "Empty");
}

function renderNextActionsReco({ planDaily, queueCount, eventsItems, primaryType }){
  const startToday = startOfLocalDayMs();
  const today = countTypeBetween(eventsItems, primaryType, startToday, Date.now()+1);

  const coverDays = (planDaily && planDaily>0) ? (queueCount/planDaily) : null;
  const lowSupply = (coverDays!==null && coverDays<3);

  const tailorStats = getTailorStatsFromMap(dashRangeDays);
  const cov = queueCount>0 ? (tailorStats.total/queueCount) : 0;

  const items = [];

  if(planDaily && today < planDaily){
    items.push({
      title: `Finish todayâ€™s cap`,
      desc: `Youâ€™re at ${today}/${planDaily} ${(primaryType==="applied")?"applied":"sent"} today. Open Jobs and prioritize 1â€“3 high-fit roles.`,
      actions: [
        { label:"Open Jobs", href:"./jobs.html" },
      ],
      badge: { cls:"warn", text:`${planDaily-today} left` },
    });
  }else if(planDaily){
    items.push({
      title: `Youâ€™re on track today`,
      desc: `Daily cap reached (${today}/${planDaily}). Keep an eye on your queue supply so you donâ€™t run out.`,
      actions: [{ label:"View activity", scroll:"#activityFilters" }],
      badge: { cls:"good", text:"On track" },
    });
  }

  if(planDaily && lowSupply){
    items.push({
      title: `Queue is running low`,
      desc: `Coverage is under 3 days at your current cap. Fetch jobs now and consider broadening titles or radius.`,
      actions: [
        { label:"Fetch jobs", click:"qaFetchJobs" },
        { label:"Adjust search", href:"./profile.html" },
      ],
      badge: { cls:"warn", text:"Low supply" },
    });
  }

  if(queueCount>0 && cov < 0.3){
    items.push({
      title: `Increase tailoring coverage`,
      desc: `Only ~${Math.round(cov*100)}% of queued jobs have a tailored CV saved. Tailoring improves match + consistency.`,
      actions: [
        { label:"Tailor top job", click:"qaTailorTop" },
        { label:"CV Studio", href:"./cv.html" },
      ],
      badge: { cls:"", text:"Quality" },
    });
  }

  if(!items.length){
    items.push({
      title:"Next steps",
      desc:"Fetch jobs, prioritize a few, tailor one CV, then apply consistently.",
      actions:[{ label:"Open Jobs", href:"./jobs.html" }],
      badge:{ cls:"", text:"Ready" },
    });
  }

  const html = `<div class="recoList">` + items.slice(0,4).map(it=>{
    const btns = (it.actions||[]).map(a=>{
      if(a.href){
        return `<a class="btn small" href="${escapeHtml(a.href)}" data-nav="1">${escapeHtml(a.label)}</a>`;
      }
      if(a.scroll){
        return `<button class="btn small ghost" type="button" data-scroll="${escapeHtml(a.scroll)}">${escapeHtml(a.label)}</button>`;
      }
      if(a.click){
        return `<button class="btn small ghost" type="button" data-click="${escapeHtml(a.click)}">${escapeHtml(a.label)}</button>`;
      }
      return "";
    }).join("");

    return `
      <div class="recoItem">
        <div class="recoTop">
          <div>
            <div class="recoTitle">${escapeHtml(it.title)}</div>
            <div class="recoDesc">${escapeHtml(it.desc)}</div>
          </div>
          <div class="badgeGroup"><span class="badge ${escapeHtml(it.badge?.cls||"")}">${escapeHtml(it.badge?.text||"")}</span></div>
        </div>
        <div class="recoActions">${btns}</div>
      </div>
    `;
  }).join("") + `</div>`;

  setHtml("nextActionsReco", html);

  // Wire internal clicks (fetch / tailor) + scroll
  const wrap = document.getElementById("nextActionsReco");
  if(wrap && !wrap._wired){
    wrap._wired = true;
    wrap.addEventListener("click",(e)=>{
      const sc = e.target.closest("button[data-scroll]");
      if(sc){
        const sel = sc.getAttribute("data-scroll");
        const el = sel ? document.querySelector(sel) : null;
        if(el && el.scrollIntoView) el.scrollIntoView({behavior:"smooth", block:"start"});
        return;
      }
      const cl = e.target.closest("button[data-click]");
      if(cl){
        const id = cl.getAttribute("data-click");
        const btn = id ? document.getElementById(id) : null;
        if(btn) btn.click();
      }
    });
  }
}

function renderAutomationHealth({ planDaily, queueCount }){
  const lastTs = Number(localStorage.getItem("jm_last_manual_fetch_ts") || "0");
  const next = getNextFetchAllowedAt();
  const now = Date.now();

  const last = lastTs ? new Date(lastTs).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"}) : "â€”";
  const nextTxt = (!next) ? "â€”" : (now < next
    ? (()=>{ const sec=Math.ceil((next-now)/1000); const m=Math.floor(sec/60); const s=sec%60; return `${m}:${String(s).padStart(2,"0")} remaining`; })()
    : "available now"
  );

  const aiTitles = Array.isArray(window.lastAiTitleSuggestions) ? window.lastAiTitleSuggestions : [];
  const aiOk = aiTitles.length > 0;

  // Supply freshness (rough: from queue data if available)
  let freshPct = null;
  try{
    const items = (lastQueueResponse && Array.isArray(lastQueueResponse.data)) ? lastQueueResponse.data : [];
    const total = items.length || 0;
    if(total>0){
      const fresh = items.filter(j=>{ const d=daysAgo((j && (j.source_modified_at || j.posted_at)) || null); return d!==null && d<=2; }).length;
      freshPct = Math.round((fresh/total)*100);
    }
  }catch(_){}

  const rows = [
    `<div class="mono">Last fetch: ${escapeHtml(last)}</div>`,
    `<div class="mono">Next manual fetch: ${escapeHtml(nextTxt)}</div>`,
    `<div class="mono">AI titles: ${aiOk ? "enabled" : "locked"}</div>`,
    `<div class="mono">Data freshness (â‰¤2d): ${freshPct===null ? "â€”" : (String(freshPct)+"%")}</div>`,
  ].join("");

  setHtml("automationHealth", rows);
  setText("automationHealthMeta", planDaily ? `Daily cap: ${planDaily}/day â€¢ Queue: ${queueCount}` : `No plan selected â€¢ Queue: ${queueCount}`);
  setBadge("badgeAutomation", aiOk ? "good" : "", aiOk ? "Ready" : "Basic");
}

function renderAiRecommendations(){
  const listEl = document.getElementById("aiRecoList");
  if(!listEl) return;

  try{
    const {p,c} = getAiJson();
    const has = !!(p && (p.job_titles || p.skills));
    if(!has){
      setBadge("badgeAi","warn","Locked");
      setText("aiRecoHint","Generate suggestions in Profile to unlock AI recommendations.");
      setHtml("aiRecoList",
        `<div class="recoList">
          <div class="recoItem">
            <div class="recoTop">
              <div>
                <div class="recoTitle">Unlock AI suggestions</div>
                <div class="recoDesc">Generate titles and skills from your profile to improve search coverage and tailoring quality.</div>
              </div>
              <div class="badgeGroup"><span class="badge warn">Action</span></div>
            </div>
            <div class="recoActions">
              <a class="btn small" href="./profile.html" data-nav="1">Go to Profile</a>
              <a class="btn small ghost" href="./plan.html" data-nav="1">See plans</a>
            </div>
          </div>
        </div>`
      );
      return;
    }

    setBadge("badgeAi","good","Ready");
    const created = p.created_at ? String(p.created_at).replace("T"," ").slice(0,16) : "";
    setText("aiRecoHint", created ? ("Updated: "+created) : "Updated: â€”");

    const titles = Array.isArray(p.job_titles) ? p.job_titles.slice(0,6) : [];
    const alt = (c && Array.isArray(c.alternative_titles)) ? c.alternative_titles.slice(0,6) : [];
    const core = (p.skills && Array.isArray(p.skills.core)) ? p.skills.core.slice(0,6) : [];
    const tools = (p.skills && Array.isArray(p.skills.tools)) ? p.skills.tools.slice(0,4) : [];

    const skillList = [...core, ...tools].map(s=>String(s||"").trim()).filter(Boolean).slice(0,10);

    const item = (title, desc, buttons, badge)=>{
      const btns = (buttons||[]).map(b=>{
        if(b.href) return `<a class="btn small" href="${escapeHtml(b.href)}" data-nav="1">${escapeHtml(b.label)}</a>`;
        if(b.click) return `<button class="btn small ghost" type="button" data-click="${escapeHtml(b.click)}">${escapeHtml(b.label)}</button>`;
        return "";
      }).join("");
      return `
        <div class="recoItem">
          <div class="recoTop">
            <div>
              <div class="recoTitle">${escapeHtml(title)}</div>
              <div class="recoDesc">${escapeHtml(desc)}</div>
            </div>
            <div class="badgeGroup"><span class="badge ${escapeHtml(badge?.cls||"")}">${escapeHtml(badge?.text||"")}</span></div>
          </div>
          <div class="recoActions">${btns}</div>
        </div>
      `;
    };

    const cards = [];

    if(titles.length){
      cards.push(item(
        "Focus titles",
        titles.join(" â€¢ "),
        [{label:"Adjust search in Profile", href:"./profile.html"}],
        {cls:"good", text:`${titles.length} titles`}
      ));
    }

    if(alt.length){
      cards.push(item(
        "Expand with alternative titles",
        alt.join(" â€¢ "),
        [{label:"Add to search", href:"./profile.html"}],
        {cls:"", text:`+${alt.length}`}
      ));
    }

    if(skillList.length){
      cards.push(item(
        "Skills to evidence in your CV",
        skillList.join(" â€¢ "),
        [{label:"Open CV Studio", href:"./cv.html"}],
        {cls:"", text:"Quality"}
      ));
    }

    cards.push(item(
      "Try exploration mode",
      "Use â€œAI titles onlyâ€ in the Performance header when you want to broaden discovery fast.",
      [{label:"Fetch jobs", click:"qaFetchJobs"}],
      {cls:"", text:"Tip"}
    ));

    setHtml("aiRecoList", `<div class="recoList">${cards.join("")}</div>`);

    // Wire internal clicks
    if(!listEl._wired){
      listEl._wired = true;
      listEl.addEventListener("click",(e)=>{
        const cl = e.target.closest("button[data-click]");
        if(cl){
          const id = cl.getAttribute("data-click");
          const btn = id ? document.getElementById(id) : null;
          if(btn) btn.click();
        }
      });
    }
  }catch(e){
    setBadge("badgeAi","warn","Locked");
    setText("aiRecoHint","Generate suggestions in Profile to unlock AI recommendations.");
    setHtml("aiRecoList", "");
  }
}

function wireRangeFilters(){
  const wrap = document.getElementById("rangeFilters");
  if(!wrap || wrap._wired) return;
  wrap._wired = true;
  wrap.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-range]");
    if(!btn) return;
    const v = Number(btn.getAttribute("data-range")||"14");
    dashRangeDays = (v===30) ? 30 : 14;

    for(const b of wrap.querySelectorAll(".chip")) b.classList.remove("active");
    btn.classList.add("active");

    // Refresh visuals from cached events (no extra network)
    try{
      const planDaily = currentPlanDaily || 0;
      const eventsItems = Array.isArray(dashEventsCache) ? dashEventsCache : [];
      updateTrendAndFunnel({ planDaily, eventsItems, primaryType: dashPrimaryEventType, rangeDays: dashRangeDays });
      renderNextActionsReco({ planDaily, queueCount: currentQueueCount||0, eventsItems, primaryType: dashPrimaryEventType });
    }catch(_){}
  });
}

function computeSupplyExtras(queue){
  const items=Array.isArray(queue?.data)?queue.data:[];
  const qCount=(typeof queue?.count==="number") ? queue.count : items.length;

  const prioCount = items.filter(j => j && j._application && j._application.priority).length;

  const dOf = (j)=>daysAgo((j && (j.source_modified_at || j.posted_at)) || null);
  const freshCount = items.filter(j=>{ const d=dOf(j); return d!==null && d<=2; }).length;
  const staleCount = items.filter(j=>{ const d=dOf(j); return d!==null && d>=10; }).length;

  return { qCount, prioCount, freshCount, staleCount };
}

async function loadTailorSummariesForQueue(queue){
  try{
    const items=Array.isArray(queue?.data)?queue.data:[];
    const ids=items.map(j=>j && j.id).filter(Boolean).map(String);
    if(!ids.length) return;
    await loadTailorSummariesForJobs(ids);
  }catch(_){}
}

/* Override: refreshQueueAndActivity to also refresh KPIs/charts */
async function refreshQueueAndActivity(){
  const queue = await apiGet("/me/jobs/queue", lastSessionToken);
  lastQueueResponse = queue;

  const extras = computeSupplyExtras(queue);
  currentQueueCount = extras.qCount;

  setHtml("queueWrap", renderQueueCards(queue));

  // Tailor summaries (best-effort, does not block UI)
  await loadTailorSummariesForQueue(queue);

  // Update metrics + charts from unfiltered events cache (force refresh after actions)
  const ev = await fetchDashboardEvents(lastSessionToken, true);
  dashPrimaryEventType = choosePrimaryEventType(ev.items);

  const planDaily = currentPlanDaily || 0;
  const supply = computeSupply(currentQueueCount||0, planDaily);
  supply.freshCount = extras.freshCount;
  supply.prioCount = extras.prioCount;
  supply.staleCount = extras.staleCount;
  supply.tailorStats = getTailorStatsFromMap(dashRangeDays);

  updateKpiStrip({
    planDaily,
    queueCount: currentQueueCount||0,
    appsTotal: Number(document.getElementById("kpiAppsTotal")?.textContent || "0") || 0,
    supply,
    eventsItems: ev.items,
    primaryType: dashPrimaryEventType,
  });
  updateTrendAndFunnel({ planDaily, eventsItems: ev.items, primaryType: dashPrimaryEventType, rangeDays: dashRangeDays });
  renderNextActionsReco({ planDaily, queueCount: currentQueueCount||0, eventsItems: ev.items, primaryType: dashPrimaryEventType });
  renderAutomationHealth({ planDaily, queueCount: currentQueueCount||0 });
  renderAiRecommendations();

  // Keep existing activity table updated
  await loadActivity(lastSessionToken);
}

/* Override: loadDashboard to fill KPI strip + visuals + right rail */
async function loadDashboard(){
  clearTopError();
  setText("errorBox","");
  setHtml("queueError","");

  // Skeleton states (new UI)
  setBadge("badgeTodaySent","","Loading");
  setBadge("badgeWeekSent","","Loading");
  setBadge("badgeQueue","","Loading");
  setBadge("badgeTailor","","Loading");
  setBadge("badgeResponse","","Loading");
  setBadge("badgePlan","","Loading");
  setBadge("badgeTrend","","Loading");
  setBadge("badgeFunnel","","Loading");
  setBadge("badgeAutomation","","Loading");
  setBadge("badgeAi","","Loading");

  setHtml("trendChart", '<div class="skeleton block" style="height:160px"></div>');
  setHtml("funnelWrap", '<div class="skeleton block" style="height:160px"></div>');
  setHtml("nextActionsReco", '<div class="skeleton block" style="height:120px"></div>');
  setHtml("automationHealth", '<div class="skeleton block" style="height:90px"></div>');
  setHtml("aiRecoList", '');

  setText("lastCheck", nowStamp());

  const session = await requireSession();
  if(!session) return;

  // Account display
  const email = session.user && session.user.email ? session.user.email : "â€”";
  setText("meEmail", email);
  setText("subLine", "Signed in as " + email);

  // Show account dropdown instead of Sign in
  try{
    const acc=document.getElementById("navAccount");
    const sign=document.getElementById("navSignIn");
    if(acc) acc.style.display="";
    if(sign) sign.style.display="none";
    const lbl=document.getElementById("navAccountLabel");
    if(lbl){
      const base = (email && String(email).includes("@")) ? String(email).split("@")[0] : "Account";
      lbl.textContent = base.length>14 ? (base.slice(0,14) + "â€¦") : base;
    }
  }catch(_){}

  // Ensure range chip wiring is live
  wireRangeFilters();

  // Load profile (AI titles are server source of truth)
  try{
    const prof = await apiGet("/me/profile", session.access_token);
    const ai = prof && prof.profile && Array.isArray(prof.profile.ai_titles) ? prof.profile.ai_titles : [];
    window.lastAiTitleSuggestions = ai;
    try{ localStorage.setItem("jm_ai_titles_server", JSON.stringify(ai)); }catch(_){}
  }catch(e){
    try{
      const ai = JSON.parse(localStorage.getItem("jm_ai_titles_server") || "[]");
      window.lastAiTitleSuggestions = Array.isArray(ai) ? ai : [];
    }catch(_){
      window.lastAiTitleSuggestions = [];
    }
  }
  updateAiSwitchState();

  // Plan / state
  let state=null;
  try{ state = await apiGet("/me/state", session.access_token); }catch{ state=null; }

  const plan = state && state.plan_id ? planFromState(state.plan_id) : planFallbackFromLocalStorage();
  currentPlanDaily = plan.daily;

  setText("kpiPlanName", plan.name);
  setText("kpiPlanMeta", plan.daily ? plan.meta : "no plan selected");
  setBadge("badgePlan", plan.daily ? "good" : "warn", plan.daily ? "Selected" : "Not selected");

  if(state && state.customer_id){ setText("meCustomerId", state.customer_id); }
  if(state){ setHtml("onboardingChecks", renderOnboardingChecks(state)); }

  // Queue
  let queue=null;
  try{
    queue = await apiGet("/me/jobs/queue", session.access_token);
    lastQueueResponse = queue;
    const extras = computeSupplyExtras(queue);
    currentQueueCount = extras.qCount;

    // Render queue breakdown cards (existing, no titles)
    setHtml("queueWrap", renderQueueCards(queue));

    // Tailored summaries (best-effort)
    await loadTailorSummariesForQueue(queue);

    // Apps summary (total)
    let appsTotal = 0;
    try{
      const apps = await apiGet("/me/applications/summary", session.access_token);
      appsTotal = (typeof apps.total==="number") ? apps.total : 0;
      animateNumber(document.getElementById("kpiAppsTotal"), appsTotal);
      setHtml("appsBreakdown", renderAppsBreakdown(apps));
    }catch(_){
      setText("kpiAppsTotal","â€“");
      setHtml("appsBreakdown", '<span class="badge warn">Not available</span>');
    }

    // Dashboard events (unfiltered)
    const ev = await fetchDashboardEvents(session.access_token, true);
    dashPrimaryEventType = choosePrimaryEventType(ev.items);

    // Supply + tailor stats
    const supply = computeSupply(currentQueueCount||0, currentPlanDaily||0);
    supply.freshCount = extras.freshCount;
    supply.prioCount = extras.prioCount;
    supply.staleCount = extras.staleCount;
    supply.tailorStats = getTailorStatsFromMap(dashRangeDays);

    // Update KPIs + visuals + right rail
    updateKpiStrip({
      planDaily: currentPlanDaily||0,
      queueCount: currentQueueCount||0,
      appsTotal,
      supply,
      eventsItems: ev.items,
      primaryType: dashPrimaryEventType,
    });
    updateTrendAndFunnel({ planDaily: currentPlanDaily||0, eventsItems: ev.items, primaryType: dashPrimaryEventType, rangeDays: dashRangeDays });
    renderNextActionsReco({ planDaily: currentPlanDaily||0, queueCount: currentQueueCount||0, eventsItems: ev.items, primaryType: dashPrimaryEventType });
    renderAutomationHealth({ planDaily: currentPlanDaily||0, queueCount: currentQueueCount||0 });
    renderAiRecommendations();

  }catch(e){
    setHtml("queueWrap", '<span class="badge bad">Queue failed</span>');
    setHtml("queueError", '<div class="error">'+escapeHtml(e.message)+'</div>');
    setText("errorBox", e.message);
    showTopError(e.message);
  }

  // Keep existing activity section
  await loadActivity(session.access_token);
}

</script>
</body>
</html>
