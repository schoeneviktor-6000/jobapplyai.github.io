<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>jobmejob • CV Studio</title>
  <meta name="description" content="Tailor your CV per role with ATS-safe formatting."/>

  <!-- Shared styles -->
  <link rel="stylesheet" href="./shared.css"/>

  <style>
    /* =========================================================
       CV Studio (page-only styles)
       ========================================================= */

    .layout{
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    .sectionTitle{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .sectionTitle h2{
      margin:0;
      font-size:14px;
      letter-spacing:.02em;
      text-transform:uppercase;
      color:rgba(17,19,24,.70);
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 1 1 auto; }

    .label{
      font-weight:900;
      font-size:13px;
      color:rgba(17,19,24,.80);
      margin:10px 0 6px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .hint{
      font-size:12px;
      color:rgba(17,19,24,.58);
      font-weight:650;
      line-height:1.45;
      margin-top:6px;
    }

    .selectWide{ width:100%; }
    .jobMeta{
      font-size:13px;
      color:rgba(17,19,24,.62);
      font-weight:700;
      line-height:1.4;
      white-space:pre-wrap;
    }

    /* Strength */
    .strengthWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .strengthTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    input[type="range"]{ width:100%; }
    .strengthPills{ display:flex; gap:8px; flex-wrap:wrap; }
    .miniPill{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      color:rgba(17,19,24,.78);
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
    }
    .miniPill.active{
      border-color: rgba(34,197,94,.55);
      background: rgba(34,197,94,.14);
      color:#0a3d1f;
    }

    details.info{
      margin-top:10px;
      border:1px solid rgba(17,19,24,.10);
      border-radius:16px;
      background:rgba(255,255,255,.70);
      padding:10px 12px;
    }
    details.info summary{
      cursor:pointer;
      font-weight:900;
      color:rgba(17,19,24,.78);
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    details.info summary::-webkit-details-marker{display:none}

    /* Output */
    .outputTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .tabs{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .tabBtn{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      cursor:pointer;
    }
    .tabBtn.active{
      border-color: rgba(34,197,94,.55);
      background: rgba(34,197,94,.14);
      color:#0a3d1f;
    }

    .cvBox{
      margin-top:12px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.03);
      border-radius:16px;
      padding:12px;
      overflow:auto;
      max-height: 56vh;
      -webkit-overflow-scrolling:touch;
    }

    /* Preview rendering (HTML) */
    .cvPreview{
      background: rgba(255,255,255,.72);
      border: 1px solid rgba(17,19,24,.10);
      border-radius: 14px;
      padding: 14px 14px;
    }
    .cvName{
      font-size:30px;
      font-weight:950;
      letter-spacing:-.6px;
      color: rgba(17,19,24,.86);
    }
    .cvRole{
      margin-top:4px;
      font-size:13px;
      font-weight:850;
      color: rgba(17,19,24,.58);
    }
    .cvContact{
      margin-top:8px;
      font-size:12.5px;
      color: rgba(17,19,24,.62);
      font-weight:700;
    }
    .cvSection{ margin-top:16px; }
    .cvSectionTitle{
      font-size:14px;
      font-weight:950;
      letter-spacing:.04em;
      text-transform:uppercase;
      border-bottom:3px solid rgba(17,19,24,.86);
      padding-bottom:6px;
      margin:0 0 10px 0;
    }
    .cvItem{ margin-top:10px; }
    .cvItemTitle{ font-size:13.5px; font-weight:950; }
    .cvItemSub{ margin-top:2px; font-size:12.5px; font-weight:850; color:rgba(17,19,24,.62); }
    .cvMetaLine{ margin-top:2px; font-size:12.5px; color:rgba(17,19,24,.62); }
    .cvUl{ margin:6px 0 0 18px; padding:0; }
    .cvUl li{ margin:0 0 3px 0; font-size:13px; line-height:1.45; }
    .cvPara{ font-size:13px; line-height:1.5; margin:0; }
    .cvSkillLine{ font-size:13px; line-height:1.5; margin:2px 0; }

    /* Text view */
    textarea.cvText{
      width:100%;
      min-height: 56vh;
      border:0;
      outline:none;
      resize:vertical;
      background:transparent;
      font-size:13px;
      line-height:1.45;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(17,19,24,.92);
    }

    /* Sticky actions */
    .stickyActions{
      position:sticky;
      bottom:0;
      margin-top:12px;
      padding-top:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,.92) 30%, rgba(255,255,255,.96));
      backdrop-filter: blur(10px);
    }
    .stickyRow{ display:flex; gap:10px; flex-wrap:wrap; }
    @media (max-width:620px){
      .stickyRow{ flex-direction:column; }
      .stickyRow .btn{ width:100%; justify-content:center; }
      .cvBox{ max-height: 52vh; }
      textarea.cvText{ min-height: 52vh; }
    }

    /* KPIs */
    .kpiRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .kpi{
      flex: 1 1 170px;
      min-width: 170px;
      border:1px solid rgba(17,19,24,.10);
      background:rgba(255,255,255,.78);
      border-radius:16px;
      padding:10px 12px;
    }
    .kpi .k{ font-size:12px; color:rgba(17,19,24,.60); font-weight:850; }
    .kpi .v{ margin-top:6px; font-size:18px; font-weight:980; letter-spacing:-.4px; }
    .bar{ height:10px; border-radius:999px; background:rgba(17,19,24,.08); overflow:hidden; margin-top:10px; }
    .bar > div{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(34,197,94,.70), rgba(22,163,74,.70));
      border-radius:999px;
      transition:width .25s ease;
    }

    /* Chips */
    .chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .chip{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.04);
      font-weight:850;
      font-size:12px;
      color:rgba(17,19,24,.78);
      white-space:nowrap;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chip.good{ border-color: rgba(34,197,94,.38); background: rgba(34,197,94,.12); color:#0a3d1f; }
    .chip.warn{ border-color: rgba(255,179,0,.42); background: rgba(255,179,0,.12); color:#5a3b00; }

    /* Clickable missing keyword chips */
    button.chipBtn{
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid rgba(255,179,0,.48);
      background: rgba(255,179,0,.12);
    }
    button.chipBtn:hover{
      background: rgba(255,179,0,.16);
      transform: translateY(-1px);
    }
    .chipPlus{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      border-radius:999px;
      background: rgba(255,179,0,.22);
      border:1px solid rgba(255,179,0,.28);
      font-weight:950;
      flex:0 0 auto;
    }

    .monoSmall{
      white-space:pre-wrap;
      font-size:12px;
      line-height:1.45;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(17,19,24,.72);
      background:rgba(17,19,24,.04);
      border:1px solid rgba(17,19,24,.12);
      border-radius:14px;
      padding:10px;
      margin-top:10px;
    }

    /* Description modal */
    .descMeta{
      margin-top:6px;
      color:rgba(17,19,24,.62);
      font-weight:700;
      font-size:13px;
      line-height:1.35;
    }

    /* Keyword modal */
    .formRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .formRow > *{ flex:1 1 220px; min-width:220px; }
    .field{
      border:1px solid rgba(17,19,24,.12);
      background: rgba(17,19,24,.03);
      border-radius:14px;
      padding:10px 12px;
    }
    .fieldLabel{
      font-weight:900;
      font-size:12px;
      color: rgba(17,19,24,.72);
      margin-bottom:8px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .checkLine{
      display:flex;
      align-items:flex-start;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(17,19,24,.12);
      background: rgba(255,255,255,.72);
      font-size:13px;
      font-weight:800;
      color: rgba(17,19,24,.78);
    }
    .checkLine input{ margin-top:3px; }
    .tinyNote{
      font-size:12px;
      line-height:1.45;
      color: rgba(17,19,24,.60);
      font-weight:650;
      margin-top:8px;
    }
    .kwPreview{
      white-space:pre-wrap;
      font-size:12.5px;
      line-height:1.45;
      background: rgba(17,19,24,.03);
      border:1px solid rgba(17,19,24,.10);
      border-radius:14px;
      padding:10px 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      color: rgba(17,19,24,.86);
      margin-top:8px;
    }
    .pillToggle{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    .pillToggle button{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background: rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .pillToggle button.active{
      border-color: rgba(34,197,94,.55);
      background: rgba(34,197,94,.14);
      color:#0a3d1f;
    }

    .warnBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,179,0,.42);
      background: rgba(255,179,0,.10);
      color:#5a3b00;
      font-weight:800;
      font-size:12.5px;
      line-height:1.45;
    }
  
    /* =========================================================
       Changes / Diff tab
       ========================================================= */
    .changeHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-top:2px;
    }
    .changeKpis{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .changePill{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      color:rgba(17,19,24,.78);
      white-space:nowrap;
    }
    .changePill.good{ border-color: rgba(34,197,94,.38); background: rgba(34,197,94,.12); color:#0a3d1f; }
    .changePill.warn{ border-color: rgba(255,179,0,.38); background: rgba(255,179,0,.12); color:#5a3b00; }
    .changePill.bad{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.10); color:#5b1111; }

    .changeCard{
      border:1px solid rgba(17,19,24,.10);
      background:rgba(255,255,255,.78);
      border-radius:16px;
      padding:12px;
      margin-top:10px;
    }
    .changeCardTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .changeTitle{
      font-weight:980;
      font-size:13px;
      letter-spacing:-.1px;
      color:rgba(17,19,24,.86);
    }
    .changeMeta{
      margin-top:2px;
      font-weight:750;
      font-size:12px;
      color:rgba(17,19,24,.60);
      line-height:1.35;
    }
    .changeBody{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top:10px;
    }
    .changeBlock{
      border:1px solid rgba(17,19,24,.10);
      background:rgba(17,19,24,.03);
      border-radius:14px;
      padding:10px;
    }
    .changeLabel{
      font-size:11px;
      font-weight:950;
      letter-spacing:.05em;
      text-transform:uppercase;
      color:rgba(17,19,24,.62);
      margin-bottom:6px;
    }
    .changeText{
      font-size:13px;
      line-height:1.45;
      color:rgba(17,19,24,.90);
      white-space:pre-wrap;
    }
    .changeTags{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    .tag{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.10);
      background:rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      color:rgba(17,19,24,.74);
    }
    .tag.good{ border-color: rgba(34,197,94,.30); background: rgba(34,197,94,.10); color:#0a3d1f; }
    .tag.warn{ border-color: rgba(255,179,0,.30); background: rgba(255,179,0,.10); color:#5a3b00; }

    .diffLines{
      white-space:pre;
      font-size:12px;
      line-height:1.45;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .diffLine{ padding:2px 4px; border-radius:8px; display:block; }
    .diffLine.add{ background: rgba(34,197,94,.10); color: rgba(17,19,24,.90); }
    .diffLine.del{ background: rgba(239,68,68,.08); color: rgba(17,19,24,.90); }
    .diffLine.same{ color: rgba(17,19,24,.62); }

    .miniNote{
      margin-top:8px;
      font-size:12px;
      font-weight:750;
      color:rgba(17,19,24,.60);
      line-height:1.45;
    }



    /* Paste job description inputs */
    .textInput{
      width:100%;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(255,255,255,.78);
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      font-size:13px;
      color:rgba(17,19,24,.90);
      outline:none;
    }
    .textInput:focus{
      border-color: rgba(34,197,94,.45);
      box-shadow: 0 0 0 4px rgba(34,197,94,.12);
    }
    textarea.jobDesc{
      width:100%;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(255,255,255,.78);
      border-radius:14px;
      padding:10px 12px;
      font-weight:750;
      font-size:13px;
      line-height:1.45;
      color:rgba(17,19,24,.92);
      outline:none;
      resize:vertical;
      min-height: 180px;
    }
    textarea.jobDesc:focus{
      border-color: rgba(34,197,94,.45);
      box-shadow: 0 0 0 4px rgba(34,197,94,.12);
    }
    .qualityPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(17,19,24,.12);
      background:rgba(17,19,24,.04);
      font-weight:900;
      font-size:12px;
      color:rgba(17,19,24,.78);
      white-space:nowrap;
    }
    .qualityPill.good{ border-color: rgba(34,197,94,.38); background: rgba(34,197,94,.12); color:#0a3d1f; }
    .qualityPill.warn{ border-color: rgba(255,179,0,.38); background: rgba(255,179,0,.12); color:#5a3b00; }

  </style>
</head>

<body>
  <header class="topbar">
    <nav class="nav">
      <a class="brand" href="./index.html" data-nav="1" aria-label="Home">
        <span class="logo" aria-hidden="true"></span>
        <span>jobmejob</span>
      </a>

      <div class="navlinks">
        <a class="pill" href="./index.html" data-nav="1">Home</a>
        <a class="pill" href="./profile.html" data-nav="1">Profile</a>
        <a class="pill" href="./plan.html" data-nav="1">Plan</a>
        <a class="pill" href="./jobs.html" data-nav="1">Jobs</a>
        <a class="pill" href="./dashboard.html" data-nav="1">Dashboard</a>
        <a class="pill active" href="./cv.html" data-nav="1">CV Studio</a>

        <a class="pill" href="./signup.html" id="navSignIn" data-nav="1">Sign in</a>
        <button class="pill" id="navLogout" type="button" style="display:none;">Logout</button>
      </div>
    </nav>
  </header>

  <main class="main">
    <h1 class="h1">CV Studio</h1>
    <p class="sub" id="subTitle">Tailor your CV per role with ATS-safe formatting. Job search + CV tailoring stay free.</p>

    <div class="errorTop" id="errorTop"></div>

    <section class="layout">
      <!-- LEFT: Controls -->
      <div class="card">
        <div class="sectionTitle">
          <h2 id="setupTitle">Setup</h2>
          <span class="badge warn" id="authBadge">Checking…</span>
        </div>

        <div class="label" id="jobSourceLbl">Job source</div>
        <div class="strengthPills" id="sourcePills">
          <span class="miniPill active" data-src="queue" id="srcQueue">From my Jobs</span>
          <span class="miniPill" data-src="paste" id="srcPaste">Paste description</span>
        </div>
        <div class="hint" id="jobSourceHint">Use a saved job from your queue, or paste any job description.</div>

        <div id="queueBox">
          <div class="label" id="jobToTailorLbl">Job to tailor</div>
          <div class="row">
            <select id="jobSelect" class="selectWide">
              <option value="">Loading…</option>
            </select>
            <a class="btn" href="./jobs.html" data-nav="1" style="flex:0 0 auto" id="openJobsBtn">Open Jobs</a>
          </div>
          <div class="hint" id="jobHint">Pick a job from your queue.</div>
          <div class="jobMeta" id="jobMeta"></div>
        </div>

        <div id="pasteBox" style="display:none">
          <div class="label" id="pasteJobLbl">Pasted job (not saved)</div>

          <div class="row">
            <input id="pasteTitle" class="textInput" type="text" placeholder="Job title (optional)" />
            <input id="pasteCompany" class="textInput" type="text" placeholder="Company (optional)" />
          </div>

          <div class="row" style="margin-top:10px">
            <input id="pasteApply" class="textInput" type="url" placeholder="Apply link (optional)" />
            <select id="pasteLangHint" class="selectWide" title="Language hint for tailoring">
              <option value="auto">Language: Auto</option>
              <option value="en">Language: English</option>
              <option value="de">Language: German</option>
            </select>
          </div>

          <div class="label" style="margin-top:12px" id="pasteDescLbl">Job description</div>
          <textarea id="pasteDesc" class="jobDesc" rows="10" placeholder="Paste the job description here…"></textarea>

          <div class="miniNote" style="margin-top:8px">
            <span class="qualityPill warn" id="pasteQualityPill">Needs text</span>
            <span id="pasteQuality">Paste the full job posting for best results.</span>
          </div>
          <div class="hint" id="pasteHint">Tip: include Responsibilities + Requirements + Tech stack. Don’t paste confidential info.</div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn ghost" id="btnViewDesc" type="button" disabled>View description</button>
          <button class="btn ghost" id="btnCopyDesc" type="button" disabled>Copy description</button>
        </div>

        <div class="hr"></div>

        <div class="label">
          <span id="templateLbl">Template</span>
          <span class="badge" title="ATS-safe formatting" id="atsSafeBadge">ATS-safe</span>
        </div>
        <div class="row">
          <select id="tplSelect" class="selectWide">
            <option value="professional">Professional (ATS-safe)</option>
          </select>
          <button class="btn ghost" id="btnAtsInfo" type="button" style="flex:0 0 auto">ATS?</button>
        </div>
        <div class="hint" id="atsHintLine">ATS-safe formatting = simple headings, no tables/columns, easy-to-parse structure.</div>

        <div class="label" id="tailorStrengthLbl">Tailoring strength</div>
        <div class="strengthWrap">
          <div class="strengthTop">
            <div class="strengthPills" id="strengthPills">
              <span class="miniPill" data-s="0" id="pillLight">Light</span>
              <span class="miniPill active" data-s="1" id="pillBalanced">Balanced</span>
              <span class="miniPill" data-s="2" id="pillAggressive">Aggressive</span>
            </div>
            <span class="badge" id="strengthBadge">Balanced</span>
          </div>

          <input id="strengthRange" type="range" min="0" max="2" step="1" value="1" />

          <div class="hint" id="strengthHint">
            Improves summary and bullets to match the job, without over-rewriting.
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <button class="btn primary" id="btnGenerate" type="button" disabled>Generate tailored CV</button>
          <button class="btn" id="btnGenerateAgain" type="button" disabled>Generate again</button>
        </div>
        <div class="hint" id="genHint">
          Same settings reuse a cached result (fast). To create a different version, change the tailoring strength.
        </div>

        <details class="info" open>
          <summary>
            <span id="stepsTitle">What we tailor (step-by-step)</span>
            <span class="badge" id="stepsBadge">Ready</span>
          </summary>

          <div class="hint" style="margin-top:8px" id="stepsIntro">
            This is what happens when you click “Generate”:
          </div>

          <ul style="margin:10px 0 0 18px; color:rgba(17,19,24,.70); font-weight:750; line-height:1.55" id="stepsList">
            <li><span id="s1">Extract job keywords</span></li>
            <li><span id="s2">Align summary & bullets</span></li>
            <li><span id="s3">Keep ATS-safe structure</span></li>
            <li><span id="s4">Compute ATS match</span></li>
            <li><span id="s5">Prepare preview & export</span></li>
          </ul>

          <div class="hint" style="margin-top:10px" id="truthHint">
            We stay truthful: we never invent experience or certifications. We only rephrase / reorder based on your uploaded CV + profile.
          </div>
        </details>

        <details class="info" id="pipelineDetails">
          <summary>
            <span id="pipelineTitle">Pipeline status</span>
            <span class="badge" id="pipeBadge">—</span>
          </summary>
          <div class="monoSmall" id="pipeBox">Generate a CV to see pipeline details.</div>
        </details>
      </div>

      <!-- RIGHT: Output -->
      <div class="card">
        <div class="outputTop">
          <div>
            <div style="font-weight:980;font-size:18px;letter-spacing:-.2px" id="tailoredTitle">Tailored CV</div>
            <div class="hint" id="outHint">Generate a CV to see preview and ATS match.</div>
          </div>

          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <span class="badge warn" id="outStatus">Not generated</span>
            <span class="badge" id="outModel">Model: —</span>
          </div>
        </div>

        <div class="kpiRow">
          <div class="kpi">
            <div class="k" id="kpiAts">ATS match</div>
            <div class="v" id="atsScore">—</div>
            <div class="bar" aria-hidden="true"><div id="atsBar"></div></div>
            <div class="hint" id="atsHint">Calculated from keyword coverage (used vs missing).</div>
          </div>

          <div class="kpi">
            <div class="k" id="kpiUsed">Keywords used</div>
            <div class="v" id="kwUsedCount">—</div>
            <div class="hint" id="kpiUsedHint">Found in your tailored CV.</div>
          </div>

          <div class="kpi">
            <div class="k" id="kpiMissing">Keywords missing</div>
            <div class="v" id="kwMissCount">—</div>
            <div class="hint" id="kpiMissingHint">Click a missing keyword to add it (truthfully).</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="tabs" role="tablist" aria-label="Output view">
          <button class="tabBtn active" id="tabPreview" type="button">Preview</button>
          <button class="tabBtn" id="tabText" type="button">Text</button>
          <button class="tabBtn" id="tabChanges" type="button">Changes</button>
        </div>

        <div class="cvBox" id="cvBox">
          <div id="cvPreviewWrap" style="display:block;">
            <div id="cvPreview" class="cvPreview">
              <div class="hint">No CV generated yet.</div>
            </div>
          </div>

          <div id="cvTextWrap" style="display:none;">
            <textarea class="cvText" id="cvText" spellcheck="false"></textarea>
          </div>
          <div id="cvChangesWrap" style="display:none;">
            <div class="changeHeader">
              <div>
                <div style="font-weight:980;font-size:14px;letter-spacing:-.1px">Changes</div>
                <div class="hint" id="changesHint">Review what changed since the last generation.</div>
              </div>

              <div class="row" style="flex:0 0 auto; justify-content:flex-end;">
                <button class="btn small" id="btnUndoFromChanges" type="button" disabled>Undo</button>
                <button class="btn small" id="btnResetFromChanges" type="button" disabled>Reset</button>
                <button class="btn small" id="btnCopyChangeSummary" type="button" disabled>Copy summary</button>
                <button class="btn small" id="btnSyncTextToDoc" type="button" style="display:none;">Sync text to preview</button>
              </div>
            </div>

            <div class="changeKpis" id="changeKpis"></div>

            <div class="bar" aria-hidden="true" style="margin-top:10px"><div id="trustBar"></div></div>
            <div class="hint" id="trustHint" style="margin-top:6px"></div>

            <div class="hr" style="margin-top:12px"></div>

            <div id="changeCards"></div>

            <details class="info" id="diffDetails" style="margin-top:12px">
              <summary>Text diff (advanced)</summary>
              <div class="monoSmall" id="diffBox">—</div>
              <div class="row" style="margin-top:10px">
                <button class="btn small" id="btnCopyDiff" type="button">Copy diff</button>
              </div>
              <div class="miniNote">Tip: If you manually edited the Text tab, changes may appear here even if Preview did not change.</div>
            </details>
          </div>

        </div>

        <div class="stickyActions">
          <div class="stickyRow">
            <button class="btn" id="btnCopy" type="button" disabled>Copy</button>
            <button class="btn" id="btnDownload" type="button" disabled>Download .txt</button>
            <button class="btn primary" id="btnPrint" type="button" disabled>Print / PDF</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="sectionTitle" style="margin-bottom:6px">
          <h2 id="atsKwTitle">ATS keywords</h2>
          <div class="row" style="justify-content:flex-end; flex:0 0 auto">
            <button class="btn small" id="btnUndoEdit" type="button" disabled>Undo</button>
            <button class="btn small" id="btnResetEdits" type="button" disabled>Reset</button>
            <button class="btn small" id="btnCopyMissing" type="button" disabled>Copy missing</button>
          </div>
        </div>

        <div class="hint" id="atsKwHint">These keywords are extracted from the job description. Click a missing keyword to add it to your CV (truthfully) and improve your ATS match.</div>

        <div class="label" style="margin-top:12px" id="usedLbl">Used</div>
        <div class="chips" id="chipsUsed"></div>

        <div class="label" style="margin-top:12px" id="missingLbl">Missing</div>
        <div class="chips" id="chipsMissing"></div>

        <details class="info" style="margin-top:12px">
          <summary id="debugTitle">Debug details</summary>
          <div class="monoSmall" id="debugBox">—</div>
        </details>
      </div>
    </section>
  </main>

  <!-- ATS info modal -->
  <div class="modalBackdrop" id="atsModal" style="display:none" role="dialog" aria-modal="true" aria-labelledby="atsTitle">
    <div class="modalCard">
      <div class="modalScroll">
        <div class="modalHeader">
          <div>
            <h3 class="modalTitle" id="atsTitle">What does ATS mean?</h3>
            <div class="hint" style="margin-top:6px" id="atsModalIntro">
              ATS = Applicant Tracking System. Companies use ATS to parse, search, and rank CVs.
            </div>
          </div>
          <button class="btn small" id="atsClose" type="button">Close</button>
        </div>

        <div class="hr"></div>

        <div class="hint" id="atsModalBody">
          <b>ATS-safe formatting</b> improves the chance your CV is parsed correctly:
          <ul style="margin:10px 0 0 18px; line-height:1.6">
            <li>Use simple headings (Experience, Education, Skills).</li>
            <li>Avoid tables, columns, text boxes, and complex layouts.</li>
            <li>Use consistent dates and bullet structure.</li>
          </ul>
          <div style="margin-top:10px">
            Our CV Studio keeps formatting simple and focuses on keywords and relevance — without inventing facts.
          </div>
        </div>
      </div>

      <div class="modalActions">
        <button class="btn primary" id="atsOk" type="button">Got it</button>
      </div>
    </div>
  </div>

  <!-- Job description modal -->
  <div class="modalBackdrop" id="descModal" style="display:none" role="dialog" aria-modal="true" aria-labelledby="descH">
    <div class="modalCard">
      <div class="modalScroll">
        <div class="modalHeader">
          <div style="min-width:0">
            <h3 class="modalTitle" id="descH">Job description</h3>
            <div class="descMeta" id="descMeta"></div>
          </div>
          <button class="btn small" id="descClose" type="button">Close</button>
        </div>
        <div class="hr"></div>
        <div class="modalMonoBox" id="descText">Loading…</div>
      </div>
      <div class="modalActions">
        <button class="btn" id="descCopy" type="button">Copy</button>
        <a class="btn primary" id="descOpen" href="#" target="_blank" rel="noopener">Open apply link</a>
      </div>
    </div>
  </div>

  <!-- Keyword booster modal -->
  <div class="modalBackdrop" id="kwModal" style="display:none" role="dialog" aria-modal="true" aria-labelledby="kwH">
    <div class="modalCard">
      <div class="modalScroll">
        <div class="modalHeader">
          <div style="min-width:0">
            <h3 class="modalTitle" id="kwH">Add keyword</h3>
            <div class="hint" style="margin-top:6px" id="kwSub">Add missing keywords — only if it's truly accurate for you.</div>
          </div>
          <button class="btn small" id="kwClose" type="button">Close</button>
        </div>

        <div class="hr"></div>

        <div class="field">
          <div class="fieldLabel" id="kwFieldLbl">Keyword</div>
          <div class="chips" style="margin-top:0">
            <span class="chip warn" id="kwChip">—</span>
          </div>

          <div class="checkLine" style="margin-top:10px">
            <input type="checkbox" id="kwTruth"/>
            <div>
              <div id="kwTruthLbl">I confirm this keyword is true for me.</div>
              <div class="tinyNote" id="kwTruthNote">We never invent experience. If it's not true, don’t add it.</div>
            </div>
          </div>
        </div>

        <div class="formRow" style="margin-top:12px">
          <div class="field">
            <div class="fieldLabel" id="kwWhereLbl">Where should it appear?</div>
            <select id="kwTarget">
              <option value="skills">Skills (recommended)</option>
              <option value="experience">Experience</option>
            </select>
            <div class="tinyNote" id="kwWhereNote">Skills is usually the safest option for ATS without adding new claims.</div>
          </div>

          <div class="field">
            <div class="fieldLabel" id="kwLangLbl">Language</div>
            <select id="kwLang">
              <option value="auto">Auto (match CV)</option>
              <option value="de">German</option>
              <option value="en">English</option>
            </select>
            <div class="tinyNote" id="kwLangNote">Auto matches your CV language. Choose German if your CV is in German.</div>
          </div>
        </div>

        <div class="field" style="margin-top:12px">
          <div class="fieldLabel" id="kwModeLbl">Insertion mode</div>
          <div class="pillToggle" id="kwModeToggle">
            <button type="button" data-mode="ai" class="active" id="kwModeAi">AI rewrite</button>
            <button type="button" data-mode="quick" id="kwModeQuick">Quick (no AI)</button>
          </div>
          <div class="tinyNote" id="kwModeNote">AI tries to integrate the keyword naturally into an existing bullet. If your backend has no AI endpoint, we automatically fall back to smart templates.</div>
        </div>

        <div class="field" style="margin-top:12px" id="kwAiRecoBox">
          <div class="fieldLabel">AI recommendation</div>
          <div class="row" style="margin-top:8px;gap:8px;align-items:center">
            <button class="btn small" id="kwAiRecoRefresh" type="button" style="flex:0 0 auto">Refresh</button>
            <span class="badge" id="kwAiRecoBadge">—</span>
          </div>
          <div class="kwPreview" id="kwAiRecoText">—</div>
          <div class="tinyNote" id="kwAiRecoNote">Recommendation is based on your existing CV text. It never invents experience.</div>
        </div>


        <!-- Skills target -->
        <div id="kwSkillsBox" style="margin-top:12px">
          <div class="field">
            <div class="fieldLabel" id="kwSkillsGroupLbl">Which skill area?</div>
            <select id="kwSkillGroup"></select>
            <div class="tinyNote" id="kwSkillsGroupNote">We add the keyword with clean casing and consistent style.</div>
          </div>
        </div>

        <!-- Experience target -->
        <div id="kwExpBox" style="margin-top:12px; display:none">
          <div class="field">
            <div class="fieldLabel" id="kwExpRoleLbl">Which role?</div>
            <select id="kwExpRole"></select>
          </div>

          <div class="field" style="margin-top:12px">
            <div class="fieldLabel" id="kwExpHowLbl">How to insert?</div>
            <select id="kwExpHow">
              <option value="rewrite">Rewrite an existing bullet (recommended)</option>
              <option value="append">Append to an existing bullet</option>
              <option value="new">Add a new bullet</option>
            </select>
            <div class="tinyNote" id="kwExpHowNote">Rewriting is most natural and stays close to your real statements.</div>
          </div>

          <div class="field" style="margin-top:12px" id="kwBulletPickBox">
            <div class="fieldLabel" id="kwExpBulletLbl">Which bullet?</div>
            <select id="kwExpBullet"></select>
            <div class="row" style="margin-top:8px;gap:8px">
              <button class="btn small" id="kwAutoPick" type="button" style="flex:0 0 auto">Auto-pick best bullet</button>
              <span class="badge" id="kwAutoPickBadge">—</span>
            </div>
            <div class="kwPreview" id="kwBulletPreview">—</div>
          </div>

          <div class="field" style="margin-top:12px; display:none" id="kwNoteBox">
            <div class="fieldLabel" id="kwNoteLbl">Short note (important for new bullet)</div>
            <textarea id="kwNote" rows="3" style="width:100%;border:0;outline:none;background:transparent;resize:vertical;font-weight:750"></textarea>
            <div class="tinyNote" id="kwNoteHelp">Example: “Facilitated client workshops”, “Implemented OKRs”, “Built SQL reports”. Keeps it 100% truthful.</div>
          </div>

          <div class="warnBox" id="kwNewWarn" style="display:none">
            Tip: A new bullet without context can look “made up”. If you don’t add a note, it’s safer to add the keyword under Skills.
          </div>
        </div>

        <div class="field" style="margin-top:12px">
          <div class="fieldLabel" id="kwPreviewLbl">Preview</div>
          <div class="kwPreview" id="kwResultPreview">—</div>
          <div class="tinyNote" id="kwPreviewNote">You can always use Undo/Reset.</div>
        </div>

      </div>

      <div class="modalActions">
        <button class="btn" id="kwCancel" type="button">Cancel</button>
        <button class="btn primary" id="kwApply" type="button">Apply</button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="./auth.js"></script>
  <script src="./shared.js"></script>

  <script>
  (() => {
    "use strict";

    const S = window.JobMeJobShared || null;

    // Fallbacks (so one missing helper doesn't break the whole page)
    const F = {
      escapeHtml: (s) => String(s ?? "").replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])),
      showModal: (id) => { const el = document.getElementById(id); if(el) el.style.display=""; },
      hideModal: (id) => { const el = document.getElementById(id); if(el) el.style.display="none"; },
      showTopError: (id, msg) => { const el = document.getElementById(id); if(el){ el.textContent = msg||""; el.style.display = msg ? "" : "none"; } },
      setBadge: (id, cls, txt) => {
        const el = document.getElementById(id); if(!el) return;
        el.className = "badge" + (cls ? (" " + cls) : "");
        el.textContent = txt ?? "";
      },
      resolveApiBase: (x) => String(x || "").trim()
    };

    const H = {
      escapeHtml: S?.escapeHtml ? S.escapeHtml : F.escapeHtml,
      showModal: S?.showModal ? S.showModal : F.showModal,
      hideModal: S?.hideModal ? S.hideModal : F.hideModal,
      showTopError: S?.showTopError ? S.showTopError : F.showTopError,
      setBadge: S?.setBadge ? S.setBadge : F.setBadge,
      resolveApiBase: S?.resolveApiBase ? S.resolveApiBase : F.resolveApiBase,
      wireNavTransitions: S?.wireNavTransitions ? S.wireNavTransitions.bind(S) : (()=>{})
    };

    H.wireNavTransitions();

    const $ = (id) => document.getElementById(id);

    const API_BASE = H.resolveApiBase("https://jobmejob.schoene-viktor.workers.dev").replace(/\/+$/, "");

    let session = null;
    let jobs = [];
    let selectedJob = null;
    let selectedDesc = "";
    let selectedApplyUrl = "";

    // Job source: queue (your saved jobs) vs paste (manual job description)
    let jobSource = "queue"; // "queue" | "paste"
    let pasteDraft = { title:"", company:"", apply:"", lang_hint:"auto", desc:"" };
    let pasteCacheKey = "";

    let lastCvText = "";
    let lastCvDoc = null;
    let lastLang = "en";

    // Keyword tracking
    let atsKeywordsAll = [];     // full list from server (union)
    let lastUsed = [];
    let lastMissing = [];
    let lastDebug = {};

    // Edits
    let baseSnapshot = null;
    let historyStack = [];

    // Keyword modal state
    let activeKeywordRaw = "";
    let activeKeywordDisplay = "";
    let kwMode = "ai"; // ai | quick

    // AI placement recommendation (cached per CV+keyword)
    let kwAiReco = null; // { target, exp_index, bullet_index, rewritten_bullet, skill_group, skill_item, reason, confidence }
    let kwAiRecoKey = "";
    const kwAiRecoCache = new Map();
    let kwAiKeywordPretty = "";
    let kwAiRecoToken = 0;

    // UI language (interface). Keep English UI; keyword insertion language follows your CV language (auto).
    let uiLang = "en";

    /* -------------------------
       i18n (interface)
       ------------------------- */
    const I18N = {
      de: {
        subTitle: "Passe deinen CV pro Rolle an – ATS-sicher formatiert. Jobsuche + CV Tailoring bleiben gratis.",
        setupTitle: "Setup",
        jobToTailorLbl: "Job auswählen",
        openJobsBtn: "Jobs öffnen",
        btnViewDesc: "Beschreibung ansehen",
        btnCopyDesc: "Beschreibung kopieren",
        templateLbl: "Template",
        atsHintLine: "ATS-sicher = einfache Überschriften, keine Tabellen/Spalten, leicht zu parsen.",
        tailorStrengthLbl: "Tailoring-Stärke",
        light: "Leicht",
        balanced: "Balanced",
        aggressive: "Aggressiv",
        gen: "Tailored CV generieren",
        genAgain: "Neu generieren",
        stepsTitle: "Was wir anpassen (Schritt für Schritt)",
        stepsIntro: "Das passiert, wenn du auf „Generieren“ klickst:",
        s1: "Job-Keywords extrahieren",
        s2: "Summary & Bullets anpassen",
        s3: "ATS-sichere Struktur beibehalten",
        s4: "ATS Match berechnen",
        s5: "Preview & Export vorbereiten",
        truthHint: "Wir bleiben ehrlich: Wir erfinden keine Erfahrung oder Zertifikate. Wir formulieren nur um / sortieren um – basierend auf deinem hochgeladenen CV + Profil.",
        pipelineTitle: "Pipeline-Status",

        tailoredTitle: "Tailored CV",
        outHint: "Generiere einen CV, um Preview und ATS Match zu sehen.",
        kpiAts: "ATS Match",
        atsHint: "Berechnet aus Keyword-Abdeckung (used vs missing).",
        kpiUsed: "Keywords gefunden",
        kpiUsedHint: "Im CV gefunden.",
        kpiMissing: "Keywords fehlen",
        kpiMissingHint: "Klicke ein fehlendes Keyword, um es (ehrlich) einzufügen.",
        tabPreview: "Preview",
        tabText: "Text",
        copy: "Kopieren",
        download: "Download .txt",
        print: "Drucken / PDF",

        atsKwTitle: "ATS Keywords",
        undo: "Undo",
        reset: "Reset",
        copyMissing: "Fehlende kopieren",
        atsKwHint: "Diese Keywords kommen aus der Jobbeschreibung. Klicke ein fehlendes Keyword, um es (ehrlich) einzufügen und dein ATS Match zu verbessern.",
        usedLbl: "Used",
        missingLbl: "Missing",
        debugTitle: "Debug Details",

        // Keyword modal
        kwH: "Add keyword",
        kwSub: "Add missing keywords — only if it's truly accurate for you.",
        close: "Schließen",
        kwTruthLbl: "I confirm this keyword is true for me.",
        kwTruthNote: "We never invent experience. If it's not true, don’t add it.",
        kwWhereLbl: "Where should it appear?",
        kwWhereNote: "Skills is usually the safest option for ATS without adding new claims.",
        kwLangLbl: "Language",
        kwLangNote: "Auto passt zur Sprache deines CV. Wähle Deutsch, wenn dein CV auf Deutsch ist.",
        kwModeLbl: "Insertion mode",
        kwModeAi: "AI rewrite",
        kwModeQuick: "Quick (no AI)",
        kwModeNote: "KI integriert das Keyword natürlich. Falls dein Backend keinen KI-Endpunkt hat, nutzen wir automatisch Smart-Templates.",
        kwSkillsGroupLbl: "Which skill area?",
        kwSkillsGroupNote: "We add the keyword with clean casing and consistent style.",
        kwExpRoleLbl: "Which role?",
        kwExpHowLbl: "How to insert?",
        kwExpHowNote: "Rewriting is most natural and stays close to your real statements.",
        kwExpBulletLbl: "Which bullet?",
        kwNoteLbl: "Short note (important for new bullet)",
        kwNoteHelp: "Beispiel: „Kundenworkshops moderiert“, „OKRs eingeführt“, „SQL-Reports gebaut“. Damit bleibt es 100% wahrheitsgemäß.",
        kwPreviewLbl: "Preview",
        kwPreviewNote: "You can always use Undo/Reset.",
        kwCancel: "Cancel",
        kwApply: "Apply",

        // errors
        pickJob: "Bitte wähle zuerst einen Job.",
        needCv: "Bitte generiere zuerst einen CV.",
        truthRequired: "Bitte bestätige, dass das Keyword für dich zutrifft.",
        needDoc: "Für diese Aktion brauchen wir die strukturierte CV-Ansicht (Preview). Bitte generiere den CV erneut.",
        noteRequired: "Bitte gib einen kurzen Hinweis, wie du das Keyword wirklich angewendet hast (für einen neuen Bullet).",
        aiFallback: "KI-Endpunkt nicht verfügbar — Smart-Template wurde verwendet.",
        added: "Eingefügt ✓",
        copied: "Kopiert ✓"
      },
      en: {
        subTitle: "Tailor your CV per role with ATS-safe formatting. Job search + CV tailoring stay free.",
        setupTitle: "Setup",
        jobSourceLbl: "Job source",
        sourceJobs: "From my Jobs",
        sourcePaste: "Paste description",
        jobSourceHint: "Use a saved job from your queue, or paste any job description.",
        pasteJobLbl: "Pasted job (not saved)",
        pasteDescLbl: "Job description",
        pasteHint: "Tip: include Responsibilities + Requirements + Tech stack. Don’t paste confidential info.",
        pasteTitlePh: "Job title (optional)",
        pasteCompanyPh: "Company (optional)",
        pasteApplyPh: "Apply link (optional)",
        pasteLangAuto: "Language: Auto",
        pasteLangEn: "Language: English",
        pasteLangDe: "Language: German",
        pasteTooShort: "Please paste a longer job description (at least 200 characters recommended).",
        pasteTooLong: "Job description is too long. Please shorten it (max 20,000 characters).",
        pasteNotSupported: "Your backend does not support tailoring from pasted job descriptions yet. Implement /me/cv/tailor_from_text in your Worker.",
        jobToTailorLbl: "Job to tailor",
        openJobsBtn: "Open Jobs",
        btnViewDesc: "View description",
        btnCopyDesc: "Copy description",
        templateLbl: "Template",
        atsHintLine: "ATS-safe formatting = simple headings, no tables/columns, easy-to-parse structure.",
        tailorStrengthLbl: "Tailoring strength",
        light: "Light",
        balanced: "Balanced",
        aggressive: "Aggressive",
        gen: "Generate tailored CV",
        genAgain: "Generate again",
        stepsTitle: "What we tailor (step-by-step)",
        stepsIntro: "This is what happens when you click “Generate”:",
        s1: "Extract job keywords",
        s2: "Align summary & bullets",
        s3: "Keep ATS-safe structure",
        s4: "Compute ATS match",
        s5: "Prepare preview & export",
        truthHint: "We stay truthful: we never invent experience or certifications. We only rephrase / reorder based on your uploaded CV + profile.",
        pipelineTitle: "Pipeline status",

        tailoredTitle: "Tailored CV",
        outHint: "Generate a CV to see preview and ATS match.",
        kpiAts: "ATS match",
        atsHint: "Calculated from keyword coverage (used vs missing).",
        kpiUsed: "Keywords used",
        kpiUsedHint: "Found in your tailored CV.",
        kpiMissing: "Keywords missing",
        kpiMissingHint: "Click a missing keyword to add it (truthfully).",
        tabPreview: "Preview",
        tabText: "Text",
        copy: "Copy",
        download: "Download .txt",
        print: "Print / PDF",

        atsKwTitle: "ATS keywords",
        undo: "Undo",
        reset: "Reset",
        copyMissing: "Copy missing",
        atsKwHint: "These keywords are extracted from the job description. Click a missing keyword to add it to your CV (truthfully) and improve your ATS match.",
        usedLbl: "Used",
        missingLbl: "Missing",
        debugTitle: "Debug details",

        kwH: "Add keyword",
        kwSub: "Add missing keywords — only if they are truly accurate.",
        close: "Close",
        kwTruthLbl: "I confirm this keyword is true for me.",
        kwTruthNote: "We don’t invent experience. If it’s not true, don’t add it.",
        kwWhereLbl: "Where should it appear?",
        kwWhereNote: "Skills is usually the safest ATS option without creating new claims.",
        kwLangLbl: "Language",
        kwLangNote: "Auto matches your CV language. Choose German if your CV is in German.",
        kwModeLbl: "Insert mode",
        kwModeAi: "AI wording",
        kwModeQuick: "Quick (no AI)",
        kwModeNote: "AI tries to integrate the keyword naturally. If your backend has no AI endpoint, we automatically fall back to smart templates.",
        kwSkillsGroupLbl: "Which skill area?",
        kwSkillsGroupNote: "We add the keyword in consistent casing and style.",
        kwExpRoleLbl: "Which role?",
        kwExpHowLbl: "How to insert?",
        kwExpHowNote: "Rewriting is most natural and stays close to your real statements.",
        kwExpBulletLbl: "Which bullet?",
        kwNoteLbl: "Short note (important for new bullet)",
        kwNoteHelp: "Example: “Facilitated client workshops”, “Implemented OKRs”, “Built SQL reports”. Keeps it 100% truthful.",
        kwPreviewLbl: "Preview",
        kwPreviewNote: "You can always use Undo/Reset.",
        kwCancel: "Cancel",
        kwApply: "Apply",

        pickJob: "Pick a job first.",
        needCv: "Generate a CV first.",
        truthRequired: "Please confirm the keyword is true for you.",
        needDoc: "This action needs the structured CV view (Preview). Please generate again.",
        noteRequired: "Please add a short note describing how you actually used this keyword (for a new bullet).",
        aiFallback: "AI endpoint not available — used smart template instead.",
        added: "Applied ✓",
        copied: "Copied ✓"
      }
    };

    function guessUiLang(){
      return "en"; // Keep the interface in English
    }

    function t(key){
      return (I18N[uiLang] && I18N[uiLang][key]) || (I18N.en[key]) || key;
    }

    function applyUiTexts(){
      uiLang = guessUiLang();
      // top
      $("subTitle").textContent = t("subTitle");
      $("setupTitle").textContent = t("setupTitle");

      // Job source (queue vs paste)
      $("jobSourceLbl").textContent = t("jobSourceLbl");
      $("srcQueue").textContent = t("sourceJobs");
      $("srcPaste").textContent = t("sourcePaste");
      $("jobSourceHint").textContent = t("jobSourceHint");

      $("pasteJobLbl").textContent = t("pasteJobLbl");
      $("pasteDescLbl").textContent = t("pasteDescLbl");
      $("pasteHint").textContent = t("pasteHint");
      $("pasteTitle").setAttribute("placeholder", t("pasteTitlePh"));
      $("pasteCompany").setAttribute("placeholder", t("pasteCompanyPh"));
      $("pasteApply").setAttribute("placeholder", t("pasteApplyPh"));

      const langSel = $("pasteLangHint");
      if(langSel && langSel.options && langSel.options.length >= 3){
        langSel.options[0].textContent = t("pasteLangAuto");
        langSel.options[1].textContent = t("pasteLangEn");
        langSel.options[2].textContent = t("pasteLangDe");
      }

      $("jobToTailorLbl").textContent = t("jobToTailorLbl");
      $("openJobsBtn").textContent = t("openJobsBtn");
      $("btnViewDesc").textContent = t("btnViewDesc");
      $("btnCopyDesc").textContent = t("btnCopyDesc");
      $("templateLbl").textContent = t("templateLbl");
      $("atsHintLine").textContent = t("atsHintLine");
      $("tailorStrengthLbl").textContent = t("tailorStrengthLbl");
      $("pillLight").textContent = t("light");
      $("pillBalanced").textContent = t("balanced");
      $("pillAggressive").textContent = t("aggressive");
      $("btnGenerate").textContent = t("gen");
      $("btnGenerateAgain").textContent = t("genAgain");

      $("stepsTitle").textContent = t("stepsTitle");
      $("stepsIntro").textContent = t("stepsIntro");
      $("s1").textContent = t("s1");
      $("s2").textContent = t("s2");
      $("s3").textContent = t("s3");
      $("s4").textContent = t("s4");
      $("s5").textContent = t("s5");
      $("truthHint").textContent = t("truthHint");
      $("pipelineTitle").textContent = t("pipelineTitle");

      $("tailoredTitle").textContent = t("tailoredTitle");
      // outHint is dynamic, leave default value for now
      $("kpiAts").textContent = t("kpiAts");
      $("atsHint").textContent = t("atsHint");
      $("kpiUsed").textContent = t("kpiUsed");
      $("kpiUsedHint").textContent = t("kpiUsedHint");
      $("kpiMissing").textContent = t("kpiMissing");
      $("kpiMissingHint").textContent = t("kpiMissingHint");

      $("tabPreview").textContent = t("tabPreview");
      $("tabText").textContent = t("tabText");
      $("btnCopy").textContent = t("copy");
      $("btnDownload").textContent = t("download");
      $("btnPrint").textContent = t("print");

      $("atsKwTitle").textContent = t("atsKwTitle");
      $("btnUndoEdit").textContent = t("undo");
      $("btnResetEdits").textContent = t("reset");
      $("btnCopyMissing").textContent = t("copyMissing");
      $("atsKwHint").textContent = t("atsKwHint");
      $("usedLbl").textContent = t("usedLbl");
      $("missingLbl").textContent = t("missingLbl");
      $("debugTitle").textContent = t("debugTitle");

      // Keyword modal
      $("kwH").textContent = t("kwH");
      $("kwSub").textContent = t("kwSub");
      $("kwClose").textContent = t("close");
      $("kwTruthLbl").textContent = t("kwTruthLbl");
      $("kwTruthNote").textContent = t("kwTruthNote");
      $("kwWhereLbl").textContent = t("kwWhereLbl");
      $("kwWhereNote").textContent = t("kwWhereNote");
      $("kwLangLbl").textContent = t("kwLangLbl");
      $("kwLangNote").textContent = t("kwLangNote");
      $("kwModeLbl").textContent = t("kwModeLbl");
      $("kwModeAi").textContent = t("kwModeAi");
      $("kwModeQuick").textContent = t("kwModeQuick");
      $("kwModeNote").textContent = t("kwModeNote");
      $("kwSkillsGroupLbl").textContent = t("kwSkillsGroupLbl");
      $("kwSkillsGroupNote").textContent = t("kwSkillsGroupNote");
      $("kwExpRoleLbl").textContent = t("kwExpRoleLbl");
      $("kwExpHowLbl").textContent = t("kwExpHowLbl");
      $("kwExpHowNote").textContent = t("kwExpHowNote");
      $("kwExpBulletLbl").textContent = t("kwExpBulletLbl");
      $("kwNoteLbl").textContent = t("kwNoteLbl");
      $("kwNoteHelp").textContent = t("kwNoteHelp");
      $("kwPreviewLbl").textContent = t("kwPreviewLbl");
      $("kwPreviewNote").textContent = t("kwPreviewNote");
      $("kwCancel").textContent = t("kwCancel");
      $("kwApply").textContent = t("kwApply");
    }

    /* -------------------------
       Helpers
       ------------------------- */
    function showError(msg){ H.showTopError("errorTop", msg || ""); }
    function setBadge(id, cls, txt){ H.setBadge(id, cls, txt); }
    function setText(id, txt){ const el = $(id); if (el) el.textContent = (txt == null) ? "" : String(txt); }

    function qs(name){
      try{ return new URL(window.location.href).searchParams.get(name); }
      catch{ return null; }
    }

    function joinNonEmpty(arr, sep){
      return (arr || []).map(x => String(x || "").trim()).filter(Boolean).join(sep);
    }
    function asStringArr(arr, max=999){
      if(!Array.isArray(arr)) return [];
      return arr.map(x => String(x || "").trim()).filter(Boolean).slice(0, max);
    }

    // Small, stable hash for caching pasted descriptions in localStorage
    function fnv1a(str){
      let h = 0x811c9dc5;
      const s = String(str || "");
      for(let i=0;i<s.length;i++){
        h ^= s.charCodeAt(i);
        h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
      }
      return ("00000000" + h.toString(16)).slice(-8);
    }

    function getPasteDesc(){
      return String($("pasteDesc")?.value || "").trim();
    }

    function getActiveJobMeta(){
      if(jobSource === "paste"){
        const title = String($("pasteTitle")?.value || "").trim();
        const company_name = String($("pasteCompany")?.value || "").trim();
        const apply_url = applyUrlSafe(String($("pasteApply")?.value || "").trim());
        return {
          title: title || (uiLang==="de" ? "Eingefügter Job" : "Pasted job"),
          company_name,
          apply_url
        };
      }
      return {
        title: String(selectedJob?.title || "").trim(),
        company_name: String(selectedJob?.company_name || "").trim(),
        apply_url: applyUrlSafe(selectedJob?.apply_url || "")
      };
    }

    function loadJobSource(){
      try{
        const v = String(localStorage.getItem("cvstudio_job_source") || "").trim();
        jobSource = (v === "paste") ? "paste" : "queue";
      }catch(_){
        jobSource = "queue";
      }
    }

    function loadPasteDraft(){
      try{
        const raw = localStorage.getItem("cvstudio_paste_draft");
        if(!raw) return;
        const obj = JSON.parse(raw);
        if(!obj) return;
        pasteDraft = {
          title: String(obj.title||""),
          company: String(obj.company||""),
          apply: String(obj.apply||""),
          lang_hint: String(obj.lang_hint||"auto"),
          desc: String(obj.desc||"")
        };
      }catch(_){}
    }

    function savePasteDraft(){
      try{
        pasteDraft = {
          title: String($("pasteTitle")?.value || ""),
          company: String($("pasteCompany")?.value || ""),
          apply: String($("pasteApply")?.value || ""),
          lang_hint: String($("pasteLangHint")?.value || "auto"),
          desc: String($("pasteDesc")?.value || "")
        };
        localStorage.setItem("cvstudio_paste_draft", JSON.stringify({ ...pasteDraft, at: Date.now() }));
      }catch(_){}
    }

    function applyPasteDraftToInputs(){
      try{
        $("pasteTitle").value = pasteDraft.title || "";
        $("pasteCompany").value = pasteDraft.company || "";
        $("pasteApply").value = pasteDraft.apply || "";
        $("pasteLangHint").value = pasteDraft.lang_hint || "auto";
        $("pasteDesc").value = pasteDraft.desc || "";
      }catch(_){}
    }

    function setJobSource(mode){
      jobSource = (mode === "paste") ? "paste" : "queue";
      try{ localStorage.setItem("cvstudio_job_source", jobSource); }catch(_){}

      $("srcQueue")?.classList.toggle("active", jobSource === "queue");
      $("srcPaste")?.classList.toggle("active", jobSource === "paste");

      $("queueBox").style.display = jobSource === "queue" ? "" : "none";
      $("pasteBox").style.display = jobSource === "paste" ? "" : "none";

      refreshModeUi();

      if(jobSource === "queue"){
        // refresh selection UI
        try{ onJobChange(); }catch(_){}
      }else{
        // update quality and enablement
        try{ updatePasteQuality(); }catch(_){}
      }
    }

    function refreshModeUi(){
      if(jobSource === "queue"){
        const ok = !!selectedJob;
        $("btnGenerate").disabled = !ok;
        $("btnGenerateAgain").disabled = !ok;
        $("btnViewDesc").disabled = !ok;
        $("btnCopyDesc").disabled = !ok;
        return;
      }

      // paste mode
      const desc = getPasteDesc();
      const len = desc.length;

      // allow generation at >=120 chars, recommend >=200
      const ok = len >= 120;

      $("btnGenerate").disabled = !ok;
      $("btnGenerateAgain").disabled = !ok;

      const hasAny = len > 0;
      $("btnViewDesc").disabled = !hasAny;
      $("btnCopyDesc").disabled = !hasAny;
    }

    function updatePasteQuality(){
      const desc = getPasteDesc();
      const pill = $("pasteQualityPill");
      const label = $("pasteQuality");

      const len = desc.length;
      const words = desc ? desc.split(/\s+/).filter(Boolean).length : 0;
      const lines = desc ? desc.split(/\n/).length : 0;

      // heuristics (English + German)
      const hasReq = /(requirements|qualifications|what you.*bring|we (are )?looking for|must have|you should|anforderungen|qualifikation|du bringst|wir suchen|solltest)/i.test(desc);
      const hasResp = /(responsibilities|what you.*do|your role|tasks|aufgaben|deine aufgaben|verantwortlichkeiten)/i.test(desc);

      let status = "warn";
      let msg = "";

      if(len < 50){
        msg = "Paste the full job posting for best results.";
      }else if(len < 200){
        msg = `Looks short (${len} chars). Include Responsibilities + Requirements for best tailoring.`;
      }else{
        status = "good";
        msg = `Looks good: ${len} chars · ${words} words · ${lines} lines` + ((hasReq || hasResp) ? "" : " (Tip: include requirements/tasks)");
      }

      if(pill){
        pill.classList.toggle("good", status === "good");
        pill.classList.toggle("warn", status !== "good");
        pill.textContent = status === "good" ? "Good" : "Needs more";
      }
      if(label) label.textContent = msg;

      // cache key for local storage outputs (not a security hash, just a stable key)
      const tpl = String($("tplSelect")?.value || "professional").trim().toLowerCase();
      const s = (strengthValue()?.key) || "balanced";
      const langHint = String($("pasteLangHint")?.value || "auto");
      pasteCacheKey = "cvstudio_last_" + "paste_" + fnv1a(desc + "|" + tpl + "|" + s + "|" + langHint);

      refreshModeUi();
    }

    function deepCopy(obj){
      try{ return JSON.parse(JSON.stringify(obj)); }catch(_){ return null; }
    }

    function formatLoc(j){
      const parts = [];
      if (j.city) parts.push(j.city);
      if (j.region && j.region !== j.city) parts.push(j.region);
      if (j.country) parts.push(j.country);
      return parts.filter(Boolean).join(", ");
    }

    function applyUrlSafe(url){
      const u = String(url || "").trim();
      if (!u) return "";
      if (/^https?:\/\//i.test(u)) return u;
      return "https://" + u.replace(/^\/+/, "");
    }

    function isLikelyGerman(lang){
      const l = String(lang || "").toLowerCase();
      return l.startsWith("de");
    }

    /* Keyword casing + matching */
    const ACRONYMS = new Set([
      "API","APIs","SQL","AWS","GCP","AZURE","KPI","KPIs","OKR","OKRs","CRM","ERP","ETL","CI/CD","CI","CD","SaaS","B2B","B2C","GDPR","DSGVO","HR","UX","UI","QA","SEO","SEA"
    ]);

    function normalizeSpaces(s){ return String(s||"").replace(/\s+/g," ").trim(); }

    function titleCaseWord(w){
      if(!w) return w;
      const up = w.toUpperCase();
      if(ACRONYMS.has(up)) return up;
      // keep words that already contain uppercase letters or digits
      if(/[A-ZÄÖÜ]/.test(w)) return w;
      return w.charAt(0).toUpperCase() + w.slice(1);
    }

    function prettyKeyword(raw, lang){
      const k = normalizeSpaces(raw);
      if(!k) return k;

      // If it looks like an acronym, upper it
      if(k.length <= 5 && /^[a-z0-9\/\-\+]+$/.test(k) && /[a-z]/.test(k)){
        const up = k.toUpperCase();
        if(ACRONYMS.has(up)) return up;
      }

      // If mostly lowercase, apply title-ish case
      const lowerRatio = (k.match(/[a-zäöü]/g)||[]).length / Math.max(1,(k.match(/[a-zA-ZÄÖÜäöü]/g)||[]).length);
      if(lowerRatio > 0.75){
        const parts = k.split(" ").map(p => {
          // handle hyphenated
          return p.split("-").map(titleCaseWord).join("-");
        });
        return parts.join(" ");
      }
      return k;
    }

    function normForMatch(s){
      // lower, remove punctuation -> spaces, collapse
      const str = String(s||"").toLowerCase();
      try{
        return str.replace(/[^\p{L}\p{N}]+/gu, " ").trim().replace(/\s+/g, " ");
      }catch(_){
        return str.replace(/[^a-z0-9äöüß]+/g, " ").trim().replace(/\s+/g, " ");
      }
    }


    function tokenizeForScore(s){
      const n = normForMatch(s);
      return n ? n.split(" ").filter(Boolean) : [];
    }

    function scoreBulletForKeyword(bullet, keyword){
      const b = tokenizeForScore(bullet);
      const k = tokenizeForScore(keyword);
      if(!b.length || !k.length) return 0;
      const bSet = new Set(b);
      let hit = 0;
      for(const t of k){
        if(bSet.has(t)) hit += 2;
      }
      const kwNorm = normForMatch(keyword);
      const bNorm = normForMatch(bullet);
      if(kwNorm && bNorm.includes(kwNorm)) hit += 6;
      // Prefer medium-length bullets (not too short, not too long)
      const len = String(bullet||"").length;
      if(len >= 40 && len <= 140) hit += 1;
      return hit;
    }

    function pickBestBulletIndex(keyword, bullets){
      let best = 0;
      let bestScore = -1;
      bullets.forEach((b, i) => {
        const s = scoreBulletForKeyword(b, keyword);
        if(s > bestScore){
          bestScore = s;
          best = i;
        }
      });
      return { index: best, score: bestScore };
    }

    function isToolLikeKeyword(keyword){
      const k = normForMatch(keyword);
      return ["sql","excel","power bi","tableau","jira","confluence","sap","aws","gcp","azure","python","r","looker","snowflake","dbt","airflow","kpi","okr","crm"].some(x => k === x);
    }

    function pickBestRoleAndBullet(keyword){
      const exp = Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [];
      let best = { expIdx: 0, bulletIdx: 0, score: -1 };
      exp.forEach((e, expIdx) => {
        const bullets = asStringArr(e?.bullets, 50);
        const r = pickBestBulletIndex(keyword, bullets);
        if(r.score > best.score){
          best = { expIdx, bulletIdx: r.index, score: r.score };
        }
      });
      return best;
    }
    function keywordInText(keyword, text){
      const k = normForMatch(keyword);
      const ttxt = normForMatch(text);
      if(!k) return false;
      return ttxt.includes(k);
    }

    /* Deterministic variation (no randomness across refreshes) */
    function hashString(s){
      const str = String(s||"");
      let h = 2166136261;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0);
    }
    function pick(arr, seed){
      if(!arr.length) return "";
      const i = (seed % arr.length);
      return arr[i];
    }

    function localRewriteBullet(bullet, keyword, lang){
      const b = String(bullet||"").trim();
      const kw = prettyKeyword(keyword, lang);
      if(!b) return kw;
      if(keywordInText(keyword, b) || keywordInText(kw, b)) return b;

      const de = isLikelyGerman(lang);
      const seed = hashString(keyword + "|" + b + "|" + lang);

      const phrasesDe = [
        "mit Fokus auf " + kw,
        "unter Einsatz von " + kw,
        "unter Anwendung von " + kw,
        "inklusive " + kw,
        "in Bezug auf " + kw
      ];
      const phrasesEn = [
        "with a focus on " + kw,
        "using " + kw,
        "leveraging " + kw,
        "including " + kw,
        "related to " + kw
      ];
      const phrase = pick(de ? phrasesDe : phrasesEn, seed);

      // Choose joiner
      const joinersDe = [" – ", "; ", ", "];
      const joinersEn = [" – ", "; ", ", "];
      const joiner = pick(de ? joinersDe : joinersEn, seed + 7);

      // If bullet ends with punctuation, keep
      const end = b.slice(-1);
      const base = /[.!?]$/.test(end) ? b.slice(0,-1) : b;

      return base + joiner + phrase + ".";
    }

    function localAppendKeyword(bullet, keyword, lang){
      // Append (smaller change than rewrite)
      const b = String(bullet||"").trim();
      const kw = prettyKeyword(keyword, lang);
      if(!b) return kw;
      if(keywordInText(keyword, b) || keywordInText(kw, b)) return b;

      const de = isLikelyGerman(lang);
      const seed = hashString(keyword + "|" + b + "|" + lang);

      const tailsDe = [
        "(inkl. " + kw + ")",
        "(Fokus: " + kw + ")",
        "(mit " + kw + ")"
      ];
      const tailsEn = [
        "(incl. " + kw + ")",
        "(focus: " + kw + ")",
        "(with " + kw + ")"
      ];
      const tail = pick(de ? tailsDe : tailsEn, seed);

      // If already ends with punctuation, add space then tail, else add " " then tail.
      if(/[.!?]$/.test(b)) return b + " " + tail;
      return b + " " + tail;
    }

    function localNewBullet(keyword, note, lang){
      const kw = prettyKeyword(keyword, lang);
      const n = normalizeSpaces(note);
      const de = isLikelyGerman(lang);
      const seed = hashString(keyword + "|" + note + "|" + lang);

      if(n){
        const templatesDe = [
          "Anwendung von " + kw + " (z. B. " + n + ").",
          n + " – mit Fokus auf " + kw + ".",
          "Umsetzung von " + kw + " im Kontext von " + n + "."
        ];
        const templatesEn = [
          "Applied " + kw + " (e.g., " + n + ").",
          n + " – with a focus on " + kw + ".",
          "Implemented " + kw + " in the context of " + n + "."
        ];
        return pick(de ? templatesDe : templatesEn, seed);
      }

      // If no note, be conservative
      return de
        ? ("Erfahrung mit " + kw + ".")
        : ("Experience with " + kw + ".");
    }

    /* -------------------------
       API helpers
       ------------------------- */
    async function apiGet(path){
      const res = await fetch(API_BASE + path, {
        method:"GET",
        headers:{ Authorization: "Bearer " + session.access_token }
      });
      const txt = await res.text().catch(()=> "");
      let json = null;
      try{ json = txt ? JSON.parse(txt) : null; }catch{ json = { raw: txt }; }
      if(!res.ok){
        const msg = path + " failed: " + res.status + " " + (json?.error || json?.details || json?.message || txt);
        const err = new Error(msg);
        err.status = res.status;
        err.body = json;
        throw err;
      }
      return json;
    }

    async function apiPostJson(path, body){
      const res = await fetch(API_BASE + path, {
        method:"POST",
        headers:{
          Authorization: "Bearer " + session.access_token,
          "content-type":"application/json"
        },
        body: JSON.stringify(body || {})
      });
      const txt = await res.text().catch(()=> "");
      let json = null;
      try{ json = txt ? JSON.parse(txt) : null; }catch{ json = { raw: txt }; }
      if(!res.ok){
        const msg = path + " failed: " + res.status + " " + (json?.error || json?.details || json?.message || txt);
        const err = new Error(msg);
        err.status = res.status;
        err.body = json;
        throw err;
      }
      return json;
    }

    function isEndpointMissing(err){
      const s = Number(err?.status || 0);
      return s === 404 || s === 405;
    }

    function extractTextFromAiResponse(res){
      if(!res) return "";
      if(typeof res.rewritten_bullet === "string") return res.rewritten_bullet;
      if(typeof res.new_bullet === "string") return res.new_bullet;
      if(typeof res.text === "string") return res.text;
      if(typeof res.bullet === "string") return res.bullet;
      if(typeof res.output === "string") return res.output;
      if(res.result){
        const r = res.result;
        return r.rewritten_bullet || r.new_bullet || r.text || r.bullet || r.output || "";
      }
      return "";
    }

    async function tryAiRewriteOrCraft({ mode, keyword, lang, current_bullet, note, context }){
      // mode: "rewrite" | "new"
      const endpoints = [
        "/me/cv/keyword_polish",
        "/me/cv/keyword_boost",
        "/me/cv/keyword_inject",
        "/me/cv/keyword_insert"
      ];

      const payloadBase = {
        job_id: String(selectedJob?.id || ""),
        keyword: String(keyword || ""),
        language: String(lang || ""),
        lang: String(lang || ""),
        ui_language: String(uiLang || ""),
        mode: String(mode || ""),
        current_bullet: String(current_bullet || ""),
        note: String(note || ""),
        context: context || {}
      };

      for(const ep of endpoints){
        try{
          const res = await apiPostJson(ep, payloadBase);
          const out = extractTextFromAiResponse(res);
          if(out && String(out).trim()) return { ok:true, text:String(out).trim(), endpoint:ep };
        }catch(e){
          if(isEndpointMissing(e)) continue;
          // if endpoint exists but fails (401/500), don't silently swallow:
          throw e;
        }
      }
      return { ok:false, text:"", endpoint:"" };
    }

    /* -------------------------
       Tailor strength
       ------------------------- */
    function strengthValue(){
      const v = Number($("strengthRange").value);
      if (v === 0) return { key:"light", label:t("light"), help: uiLang==="de"
        ? "Kleine Verbesserungen, nah an deinem Original."
        : "Small improvements, keeps wording close to your original." };
      if (v === 2) return { key:"strong", label:t("aggressive"), help: uiLang==="de"
        ? "Stärkeres Rewriting für besseren Fit (immer noch wahrheitsgemäß)."
        : "Rewrites more strongly to highlight fit and align with job language (still truthful)." };
      return { key:"balanced", label:t("balanced"), help: uiLang==="de"
        ? "Verbessert Summary & Bullets ohne zu viel umzuschreiben."
        : "Improves summary and bullets to match the job, without over-rewriting." };
    }

    function setStrengthUi(){
      const v = Number($("strengthRange").value);
      const s = strengthValue();
      setText("strengthBadge", s.label);
      setText("strengthHint", s.help);

      const pills = $("strengthPills")?.querySelectorAll(".miniPill") || [];
      pills.forEach(p => p.classList.toggle("active", Number(p.getAttribute("data-s")) === v));

      try{ localStorage.setItem("cv_strength", String(v)); }catch{}
      if(jobSource === "paste"){
        try{ updatePasteQuality(); }catch(_){ }
      }else{
        try{ refreshModeUi(); }catch(_){ }
      }
    }

    function setTemplateUi(){
      try{ localStorage.setItem("cv_template", String($("tplSelect").value || "professional")); }catch{}
      if(jobSource === "paste"){
        try{ updatePasteQuality(); }catch(_){ }
      }
    }

    function markSteps(state){
      const ids = ["s1","s2","s3","s4","s5"];
      ids.forEach(id => {
        const el = $(id);
        if(!el) return;
        el.style.fontWeight = "750";
        el.style.color = "rgba(17,19,24,.72)";
      });

      if(state === "idle"){ setBadge("stepsBadge", "", uiLang==="de" ? "Bereit" : "Ready"); return; }
      if(state === "running"){ setBadge("stepsBadge", "warn", uiLang==="de" ? "Generiere…" : "Generating…"); return; }
      if(state === "done"){
        setBadge("stepsBadge", "good", uiLang==="de" ? "Fertig" : "Done");
        ids.forEach(id => {
          const el = $(id); if(!el) return;
          el.style.color = "#0a3d1f";
          el.style.fontWeight = "900";
        });
        return;
      }
      if(state === "error"){ setBadge("stepsBadge", "bad", uiLang==="de" ? "Fehlgeschlagen" : "Failed"); return; }
    }

    function setOutputEnabled(enabled){
      $("btnCopy").disabled = !enabled;
      $("btnDownload").disabled = !enabled;
      $("btnPrint").disabled = !enabled;
      $("btnCopyMissing").disabled = !enabled;
      $("btnUndoEdit").disabled = !enabled;
      $("btnResetEdits").disabled = !enabled;
    }

    function updateUndoResetButtons(){
      const hasBase = !!baseSnapshot;
      $("btnResetEdits").disabled = !hasBase;
      $("btnUndoEdit").disabled = !(historyStack && historyStack.length);
    }

    /* -------------------------
       ATS score rendering
       ------------------------- */
    function computeAtsScore(used, missing){
      const u = Array.isArray(used) ? used.length : 0;
      const m = Array.isArray(missing) ? missing.length : 0;
      if(u + m <= 0) return null;
      return Math.round((u / (u + m)) * 100);
    }

    function renderKeywords(){
      const used = Array.isArray(lastUsed) ? lastUsed : [];
      const miss = Array.isArray(lastMissing) ? lastMissing : [];

      $("chipsUsed").innerHTML = used.length
        ? used.slice(0, 120).map(k => `<span class="chip good" title="${H.escapeHtml(k)}">${H.escapeHtml(prettyKeyword(k,lastLang))}</span>`).join("")
        : `<span class="hint">—</span>`;

      $("chipsMissing").innerHTML = miss.length
        ? miss.slice(0, 120).map(k => {
            const disp = prettyKeyword(k,lastLang);
            return `<button type="button" class="chip chipBtn warn" data-kw="${H.escapeHtml(k)}" title="${H.escapeHtml(k)}">
              <span style="min-width:0;overflow:hidden;text-overflow:ellipsis">${H.escapeHtml(disp)}</span>
              <span class="chipPlus" aria-hidden="true">＋</span>
            </button>`;
          }).join("")
        : `<span class="hint">—</span>`;

      setText("kwUsedCount", used.length ? String(used.length) : "0");
      setText("kwMissCount", miss.length ? String(miss.length) : "0");

      const score = computeAtsScore(used, miss);
      if(score == null){
        setText("atsScore", "—");
        $("atsBar").style.width = "0%";
      }else{
        setText("atsScore", score + "%");
        $("atsBar").style.width = score + "%";
      }
    }

    function recomputeCoverageFromCurrentText(){
      const text = $("cvText").value || "";
      const all = Array.isArray(atsKeywordsAll) && atsKeywordsAll.length
        ? atsKeywordsAll
        : Array.from(new Set([...(lastUsed||[]), ...(lastMissing||[])].map(x=>String(x||"").trim()).filter(Boolean)));

      const used = [];
      const miss = [];
      for(const kw of all){
        if(keywordInText(kw, text)) used.push(kw);
        else miss.push(kw);
      }
      lastUsed = used;
      lastMissing = miss;
      renderKeywords();
    }

    /* -------------------------
       CV doc formatting (ported from dashboard)
       ------------------------- */
    function cvLabels(lang){
      const de = isLikelyGerman(lang);
      return de ? {
        summary: "Profil",
        experience: "Experience",
        education: "Ausbildung",
        achievements: "Erfolge",
        skills: "Skills",
        courses: "Kurse",
        interests: "Interessen",
        languages: "Languagen"
      } : {
        summary: "Profile",
        experience: "Experience",
        education: "Education",
        achievements: "Key achievements",
        skills: "Skills",
        courses: "Courses",
        interests: "Interests",
        languages: "Languages"
      };
    }

    function ul(items){
      const arr = asStringArr(items, 999);
      if(!arr.length) return "";
      return `<ul class="cvUl">${arr.map(x => `<li>${H.escapeHtml(x)}</li>`).join("")}</ul>`;
    }

    function sec(title, inner){
      if(!inner || !String(inner).trim()) return "";
      return `<div class="cvSection"><div class="cvSectionTitle">${H.escapeHtml(title)}</div>${inner}</div>`;
    }

    function item(title, sub, meta, bullets){
      const t = String(title || "").trim();
      const s = String(sub || "").trim();
      const m = String(meta || "").trim();
      const b = asStringArr(bullets, 12);

      const parts = [];
      parts.push(`<div class="cvItem">`);
      if(t) parts.push(`<div class="cvItemTitle">${H.escapeHtml(t)}</div>`);
      if(s) parts.push(`<div class="cvItemSub">${H.escapeHtml(s)}</div>`);
      if(m) parts.push(`<div class="cvMetaLine">${H.escapeHtml(m)}</div>`);
      if(b.length) parts.push(ul(b));
      parts.push(`</div>`);
      return parts.join("");
    }

    function cvDocToPreviewHtml(doc, lang){
      const L = cvLabels(lang);
      const name = String(doc?.name || "YOUR NAME");
      const role = String(doc?.target_role || (isLikelyGerman(lang) ? "Die Rolle, auf die du dich bewirbst" : "The role you are applying for"));

      const c = doc?.contact || {};
      const contactLine = joinNonEmpty([c.phone, c.email, c.linkedin, c.portfolio, c.location], " · ");

      const summary = asStringArr(doc?.summary, 8);
      const exp = Array.isArray(doc?.experience) ? doc.experience : [];
      const edu = Array.isArray(doc?.education) ? doc.education : [];
      const ach = asStringArr(doc?.key_achievements, 10);

      const skills = doc?.skills || {};
      const skillGroups = Array.isArray(skills?.groups) ? skills.groups : [];
      const addSkills = asStringArr(skills?.additional, 24);

      const courses = asStringArr(doc?.courses, 12);
      const interests = asStringArr(doc?.interests, 12);
      const langs = asStringArr(doc?.languages, 12);

      const summaryHtml = summary.length ? `<p class="cvPara">${H.escapeHtml(summary.join(" "))}</p>` : "";

      const expHtml = exp.map(e => {
        const title = e?.title || "";
        const sub = joinNonEmpty([e?.company, e?.location], " · ");
        const meta = joinNonEmpty([e?.start, e?.end], " – ");
        return item(title, sub, meta, e?.bullets);
      }).join("");

      const eduHtml = edu.map(e => {
        const title = joinNonEmpty([e?.degree, e?.field], " · ");
        const sub = joinNonEmpty([e?.school, e?.location], " · ");
        const meta = joinNonEmpty([e?.start, e?.end], " – ");
        return item(title, sub, meta, e?.bullets);
      }).join("");

      const skillsInner = [
        skillGroups.map(g => {
          const label = String(g?.label || "").trim();
          const items = asStringArr(g?.items, 30);
          if(!items.length) return "";
          const line = label ? `${H.escapeHtml(label)}: ${H.escapeHtml(items.join(", "))}` : H.escapeHtml(items.join(", "));
          return `<div class="cvSkillLine">${line}</div>`;
        }).join(""),
        addSkills.length ? `<div class="cvSkillLine">${H.escapeHtml(addSkills.join(", "))}</div>` : ""
      ].join("");

      const coursesInner = courses.length ? `<div class="cvPara">${H.escapeHtml(courses.join(" · "))}</div>` : "";
      const interestsInner = interests.length ? `<div class="cvPara">${H.escapeHtml(interests.join(" · "))}</div>` : "";
      const langsInner = langs.length ? `<div class="cvPara">${H.escapeHtml(langs.join(" · "))}</div>` : "";

      return [
        `<div class="cvPreview">`,
        `<div class="cvName">${H.escapeHtml(name)}</div>`,
        `<div class="cvRole">${H.escapeHtml(role)}</div>`,
        contactLine ? `<div class="cvContact">${H.escapeHtml(contactLine)}</div>` : ``,
        sec(L.summary, summaryHtml),
        sec(L.experience, expHtml),
        sec(L.education, eduHtml),
        sec(L.achievements, ul(ach)),
        sec(L.skills, skillsInner),
        sec(L.courses, coursesInner),
        sec(L.interests, interestsInner),
        sec(L.languages, langsInner),
        `</div>`,
      ].join("");
    }

    function cvDocToPlainText(doc, lang){
      const L = cvLabels(lang);
      const lines = [];
      const name = String(doc?.name || "").trim();
      const role = String(doc?.target_role || "").trim();
      const c = doc?.contact || {};
      const contactLine = joinNonEmpty([c.phone, c.email, c.linkedin, c.portfolio, c.location], " · ");

      if(name) lines.push(name);
      if(role) lines.push(role);
      if(contactLine) lines.push(contactLine);
      if(lines.length) lines.push("");

      const summary = asStringArr(doc?.summary, 8);
      if(summary.length){
        lines.push(L.summary.toUpperCase());
        lines.push(summary.join(" "));
        lines.push("");
      }

      const exp = Array.isArray(doc?.experience) ? doc.experience : [];
      if(exp.length){
        lines.push(L.experience.toUpperCase());
        for(const e of exp){
          const t = String(e?.title || "").trim();
          const sub = joinNonEmpty([e?.company, e?.location], " · ");
          const meta = joinNonEmpty([e?.start, e?.end], " – ");
          if(t) lines.push(t);
          if(sub) lines.push(sub);
          if(meta) lines.push(meta);
          const b = asStringArr(e?.bullets, 12);
          for(const bb of b) lines.push("- " + bb);
          lines.push("");
        }
      }

      const edu = Array.isArray(doc?.education) ? doc.education : [];
      if(edu.length){
        lines.push(L.education.toUpperCase());
        for(const e of edu){
          const t = joinNonEmpty([e?.degree, e?.field], " · ");
          const sub = joinNonEmpty([e?.school, e?.location], " · ");
          const meta = joinNonEmpty([e?.start, e?.end], " – ");
          if(t) lines.push(t);
          if(sub) lines.push(sub);
          if(meta) lines.push(meta);
          const b = asStringArr(e?.bullets, 8);
          for(const bb of b) lines.push("- " + bb);
          lines.push("");
        }
      }

      const ach = asStringArr(doc?.key_achievements, 10);
      if(ach.length){
        lines.push(L.achievements.toUpperCase());
        for(const a of ach) lines.push("- " + a);
        lines.push("");
      }

      const skills = doc?.skills || {};
      const groups = Array.isArray(skills?.groups) ? skills.groups : [];
      const addSkills = asStringArr(skills?.additional, 24);
      const skillLines = [];
      for(const g of groups){
        const label = String(g?.label || "").trim();
        const items = asStringArr(g?.items, 30);
        if(!items.length) continue;
        skillLines.push(label ? (label + ": " + items.join(", ")) : items.join(", "));
      }
      if(addSkills.length) skillLines.push(addSkills.join(", "));
      if(skillLines.length){
        lines.push(L.skills.toUpperCase());
        for(const s of skillLines) lines.push(s);
        lines.push("");
      }

      const courses = asStringArr(doc?.courses, 12);
      if(courses.length){
        lines.push(L.courses.toUpperCase());
        lines.push(courses.join(" · "));
        lines.push("");
      }

      const interests = asStringArr(doc?.interests, 12);
      if(interests.length){
        lines.push(L.interests.toUpperCase());
        lines.push(interests.join(" · "));
        lines.push("");
      }

      const langs = asStringArr(doc?.languages, 12);
      if(langs.length){
        lines.push(L.languages.toUpperCase());
        lines.push(langs.join(" · "));
        lines.push("");
      }

      return lines.join("\n").trim() + "\n";
    }

    function cvTextToPrintableHtml(title, text){
      const safeTitle = H.escapeHtml(title || "Curriculum Vitae");
      const safeText = H.escapeHtml(String(text || "").trim());
      return `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${safeTitle}</title>
<style>
  @page{ size:A4; margin:14mm 14mm 14mm 14mm; }
  body{ margin:0; padding:0; font-family: Arial, Helvetica, sans-serif; color:#111318; }
  .cvPaper{ max-width:820px; margin:0 auto; padding:0; }
  h1{ font-size:18px; margin:0 0 10px 0; }
  pre{ white-space:pre-wrap; font-size:12.5px; line-height:1.45; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
</style>
</head>
<body>
  <div class="cvPaper">
    <h1>${safeTitle}</h1>
    <pre>${safeText}</pre>
  </div>
</body>
</html>`;
    }

    function cvDocToPrintableHtml(cvDoc, lang, title){
      const css = `
        @page{ size:A4; margin:14mm 14mm 14mm 14mm; }
        body{ margin:0; padding:0; font-family: Arial, Helvetica, sans-serif; color:#111318; }
        .cvPaper{ max-width:820px; margin:0 auto; }
        .cvName{ font-size:34px; font-weight:900; letter-spacing:-.6px; color:#111318; }
        .cvRole{ margin-top:2px; font-size:14px; font-weight:800; color:#3b3f46; }
        .cvContact{ margin-top:6px; font-size:12.5px; color:#3b3f46; }
        .cvSection{ margin-top:16px; }
        .cvSectionTitle{ font-size:14px; font-weight:900; letter-spacing:.04em; text-transform:uppercase; border-bottom:3px solid #111318; padding-bottom:6px; margin:0 0 8px 0; }
        .cvItem{ margin-top:10px; }
        .cvItemTitle{ font-size:13.5px; font-weight:900; }
        .cvItemSub{ margin-top:2px; font-size:12.5px; font-weight:800; color:#3b3f46; }
        .cvMetaLine{ margin-top:2px; font-size:12.5px; color:#3b3f46; }
        .cvUl{ margin:6px 0 0 18px; padding:0; }
        .cvUl li{ margin:0 0 3px 0; font-size:13px; }
        .cvPara{ font-size:13px; line-height:1.45; margin:0; }
        .cvSkillLine{ font-size:13px; line-height:1.45; margin:2px 0; }
      `;

      const safeTitle = H.escapeHtml(title || "Curriculum Vitae");
      const bodyHtml = cvDocToPreviewHtml(cvDoc, lang).replace('<div class="cvPreview">', '<div class="cvPaper">');

      return `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${safeTitle}</title>
<style>${css}</style>
</head>
<body>
${bodyHtml}
</body>
</html>`;
    }

    function printHtml(html){
      const blob = new Blob([html], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      let iframe = document.getElementById('printFrame');
      if(!iframe){
        iframe = document.createElement('iframe');
        iframe.id = 'printFrame';
        iframe.style.position='fixed';
        iframe.style.right='0';
        iframe.style.bottom='0';
        iframe.style.width='1px';
        iframe.style.height='1px';
        iframe.style.opacity='0';
        iframe.style.pointerEvents='none';
        document.body.appendChild(iframe);
      }
      iframe.onload = () => {
        try{
          iframe.contentWindow.focus();
          iframe.contentWindow.print();
        }catch(_){}
        setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){} }, 1500);
      };
      iframe.src = url;
    }

    /* -------------------------
       Tabs + rendering
       ------------------------- */
    function setTabs(which){
      const isPreview = which === "preview";
      const isText = which === "text";
      const isChanges = which === "changes";

      $("tabPreview").classList.toggle("active", isPreview);
      $("tabText").classList.toggle("active", isText);
      $("tabChanges").classList.toggle("active", isChanges);

      $("cvPreviewWrap").style.display = isPreview ? "" : "none";
      $("cvTextWrap").style.display = isText ? "" : "none";
      $("cvChangesWrap").style.display = isChanges ? "" : "none";

      if(isChanges){
        renderChangesView();
      }
    }

    /* -------------------------
       Changes / Diff view
       ------------------------- */
    function normText(t){
      return String(t || "")
        .replace(/\r\n/g, "\n")
        .replace(/[ \t]+/g, " ")
        .trim();
    }

    function splitLines(t){
      const s = String(t || "").replace(/\r\n/g,"\n");
      // Keep empty lines (important for CV structure)
      return s.split("\n");
    }

    // Simple LCS-based line diff: returns [{type:"same"|"add"|"del", line:string}]
    function diffLinesLcs(aText, bText){
      const A = splitLines(aText);
      const B = splitLines(bText);

      const n = A.length;
      const m = B.length;

      // Fast paths
      if(n === 0 && m === 0) return [];
      if(n === 0) return B.map(line => ({ type:"add", line }));
      if(m === 0) return A.map(line => ({ type:"del", line }));

      // DP table (n+1) x (m+1)
      // Keep it as Uint16Array per row for memory (CVs are small enough)
      const dp = Array.from({length: n+1}, () => new Uint16Array(m+1));

      for(let i=n-1; i>=0; i--){
        const row = dp[i];
        const rowNext = dp[i+1];
        for(let j=m-1; j>=0; j--){
          if(A[i] === B[j]) row[j] = rowNext[j+1] + 1;
          else row[j] = Math.max(rowNext[j], row[j+1]);
        }
      }

      const out = [];
      let i = 0, j = 0;
      while(i < n && j < m){
        if(A[i] === B[j]){
          out.push({ type:"same", line: A[i] });
          i++; j++;
        }else{
          const down = dp[i+1][j];
          const right = dp[i][j+1];
          if(down >= right){
            out.push({ type:"del", line: A[i] });
            i++;
          }else{
            out.push({ type:"add", line: B[j] });
            j++;
          }
        }
      }
      while(i < n){ out.push({ type:"del", line: A[i++] }); }
      while(j < m){ out.push({ type:"add", line: B[j++] }); }
      return out;
    }

    function countAddedSignals(diff){
      const added = diff.filter(d => d.type === "add").map(d => d.line).join("\n");
      const del = diff.filter(d => d.type === "del").map(d => d.line).join("\n");

      // Numbers/metrics (often risky if introduced without proof)
      const numRe = /\b\d{1,3}(?:[.,]\d{1,2})?(?:%|k|K|m|M)?\b/g;
      const addedNums = (added.match(numRe) || []).length;

      // Certification / qualification-like tokens (heuristic)
      const certTokens = [
        "PMP","PRINCE2","ITIL","AWS","AZ-","GCP","Google Cloud","Scrum Master","CSM","PSM",
        "CFA","CPA","CIPP","CISSP","OSCP","ISTQB","TOGAF","SAP Certified","MBA"
      ];
      let certHits = 0;
      for(const tok of certTokens){
        const re = new RegExp(String(tok).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
        if(re.test(added)) certHits += 1;
      }

      // Seniority inflation (heuristic)
      const seniorityHits = (added.match(/\b(Senior|Lead|Head of|Principal)\b/gi) || []).length;

      // Language claims (heuristic)
      const langClaimHits = (added.match(/\b(native|fluent|C2|C1|B2)\b/gi) || []).length;

      // How many lines changed
      const addLines = diff.filter(d => d.type === "add" && String(d.line||"").trim()).length;
      const delLines = diff.filter(d => d.type === "del" && String(d.line||"").trim()).length;

      return { addedNums, certHits, seniorityHits, langClaimHits, addLines, delLines, addedText: added, deletedText: del };
    }

    function assessReviewRisk(diff){
      const s = countAddedSignals(diff);
      let score = 0;

      if(s.addedNums > 0) score += 2;
      if(s.certHits > 0) score += 2;
      if(s.seniorityHits > 0) score += 1;
      if(s.langClaimHits > 0) score += 1;
      if(s.addLines + s.delLines > 18) score += 1;

      let level = "Low";
      let cls = "good";
      if(score >= 4){ level = "High"; cls = "bad"; }
      else if(score >= 2){ level = "Medium"; cls = "warn"; }

      // Confidence is inverse of risk score (simple)
      const confidence = Math.max(10, Math.min(100, 100 - score * 18));

      const notes = [];
      if(s.addedNums > 0) notes.push("New numbers/metrics detected");
      if(s.certHits > 0) notes.push("New certifications/qualifications detected");
      if(s.seniorityHits > 0) notes.push("Seniority wording changes detected");
      if(s.langClaimHits > 0) notes.push("Language proficiency claims detected");
      if(!notes.length) notes.push("Mostly wording/keyword changes");

      return { level, cls, confidence, notes, signals: s };
    }

    function fmtDelta(delta){
      if(delta == null || isNaN(delta)) return "";
      if(delta > 0) return `(+${delta})`;
      if(delta < 0) return `(${delta})`;
      return "(±0)";
    }

    function buildDocChanges(baseDoc, curDoc){
      const changes = [];
      if(!baseDoc || !curDoc) return changes;

      // Summary (array -> string compare)
      const baseSummary = Array.isArray(baseDoc.summary) ? baseDoc.summary.join(" ").trim() : String(baseDoc.summary||"").trim();
      const curSummary = Array.isArray(curDoc.summary) ? curDoc.summary.join(" ").trim() : String(curDoc.summary||"").trim();
      if(normText(baseSummary) !== normText(curSummary)){
        changes.push({
          id: "summary",
          kind: "summary",
          title: "Profile",
          meta: "Summary paragraph",
          before: baseSummary,
          after: curSummary
        });
      }

      // Experience bullets
      const baseExp = Array.isArray(baseDoc.experience) ? baseDoc.experience : [];
      const curExp = Array.isArray(curDoc.experience) ? curDoc.experience : [];
      const expN = Math.max(baseExp.length, curExp.length);

      for(let i=0; i<expN; i++){
        const be = baseExp[i] || null;
        const ce = curExp[i] || null;
        if(!be && !ce) continue;

        const label = [ce?.title || be?.title || "Role", ce?.company || be?.company || ""].filter(Boolean).join(" @ ").trim();
        const bBullets = Array.isArray(be?.bullets) ? be.bullets : [];
        const cBullets = Array.isArray(ce?.bullets) ? ce.bullets : [];
        const bn = bBullets.length;
        const cn = cBullets.length;
        const n = Math.max(bn, cn);

        for(let j=0; j<n; j++){
          const bb = (bBullets[j] == null) ? null : String(bBullets[j]);
          const cb = (cBullets[j] == null) ? null : String(cBullets[j]);
          if(bb === cb) continue;

          // Ignore trailing empty differences
          if(normText(bb) === "" && normText(cb) === "") continue;

          changes.push({
            id: `exp:${i}:${j}`,
            kind: "exp_bullet",
            expIndex: i,
            bulletIndex: j,
            title: "Experience",
            meta: `${label} • Bullet ${j+1}`,
            before: bb,
            after: cb
          });
        }
      }

      // Skills (groups + additional)
      const bSkills = baseDoc.skills || {};
      const cSkills = curDoc.skills || {};

      const bGroups = Array.isArray(bSkills.groups) ? bSkills.groups : [];
      const cGroups = Array.isArray(cSkills.groups) ? cSkills.groups : [];

      // map by label (case-insensitive), fallback to index
      const mapByLabel = (arr) => {
        const map = new Map();
        arr.forEach((g, idx) => {
          const key = String(g?.label || ("#"+idx)).trim().toLowerCase();
          map.set(key, { g, idx });
        });
        return map;
      };
      const bMap = mapByLabel(bGroups);
      const cMap = mapByLabel(cGroups);
      const allKeys = new Set([...bMap.keys(), ...cMap.keys()]);

      for(const key of allKeys){
        const bg = bMap.get(key)?.g || null;
        const cg = cMap.get(key)?.g || null;
        const label = String(cg?.label || bg?.label || "Skills").trim();
        const bItems = Array.isArray(bg?.items) ? bg.items.map(x=>String(x||"").trim()).filter(Boolean) : [];
        const cItems = Array.isArray(cg?.items) ? cg.items.map(x=>String(x||"").trim()).filter(Boolean) : [];

        // Compare as sets (order doesn't matter)
        const bSet = new Set(bItems.map(x=>x.toLowerCase()));
        const cSet = new Set(cItems.map(x=>x.toLowerCase()));
        const added = cItems.filter(x => !bSet.has(x.toLowerCase()));
        const removed = bItems.filter(x => !cSet.has(x.toLowerCase()));
        if(added.length || removed.length){
          changes.push({
            id: `skillsGroup:${key}`,
            kind: "skills_group",
            groupKey: key,
            groupLabel: label,
            title: "Skills",
            meta: label ? `Group: ${label}` : "Skill group",
            before: bItems.join(", "),
            after: cItems.join(", "),
            tags: [
              ...(added.length ? [`Added: ${added.slice(0,6).join(", ")}${added.length>6?"…":""}`] : []),
              ...(removed.length ? [`Removed: ${removed.slice(0,6).join(", ")}${removed.length>6?"…":""}`] : [])
            ]
          });
        }
      }

      const bAdd = Array.isArray(bSkills.additional) ? bSkills.additional.map(x=>String(x||"").trim()).filter(Boolean) : [];
      const cAdd = Array.isArray(cSkills.additional) ? cSkills.additional.map(x=>String(x||"").trim()).filter(Boolean) : [];
      const bAddSet = new Set(bAdd.map(x=>x.toLowerCase()));
      const cAddSet = new Set(cAdd.map(x=>x.toLowerCase()));
      const addAdded = cAdd.filter(x => !bAddSet.has(x.toLowerCase()));
      const addRemoved = bAdd.filter(x => !cAddSet.has(x.toLowerCase()));
      if(addAdded.length || addRemoved.length){
        changes.push({
          id: "skillsAdditional",
          kind: "skills_additional",
          title: "Skills",
          meta: "Additional skills line",
          before: bAdd.join(", "),
          after: cAdd.join(", "),
          tags: [
            ...(addAdded.length ? [`Added: ${addAdded.slice(0,6).join(", ")}${addAdded.length>6?"…":""}`] : []),
            ...(addRemoved.length ? [`Removed: ${addRemoved.slice(0,6).join(", ")}${addRemoved.length>6?"…":""}`] : [])
          ]
        });
      }

      return changes;
    }

    function detectManualTextEdits(){
      if(!lastCvDoc) return false;
      const docText = cvDocToPlainText(lastCvDoc, lastLang);
      const curText = $("cvText").value || "";
      return normText(docText) !== normText(curText);
    }

    function renderChangesView(){
      // If no baseline, show empty
      if(!baseSnapshot){
        $("changeKpis").innerHTML = `<span class="hint">Generate a CV to review changes.</span>`;
        $("changeCards").innerHTML = "";
        $("diffBox").textContent = "—";
        $("trustBar").style.width = "0%";
        $("trustHint").textContent = "—";
        $("btnCopyChangeSummary").disabled = true;
        $("btnUndoFromChanges").disabled = true;
        $("btnResetFromChanges").disabled = true;
        $("btnSyncTextToDoc").style.display = "none";
        return;
      }

      // Enable buttons
      $("btnCopyChangeSummary").disabled = false;
      $("btnUndoFromChanges").disabled = $("btnUndoEdit")?.disabled ?? false;
      $("btnResetFromChanges").disabled = $("btnResetEdits")?.disabled ?? false;

      const baseAts = computeAtsScore(baseSnapshot.used, baseSnapshot.missing);
      const curAts = computeAtsScore(lastUsed, lastMissing);

      const baseMiss = Array.isArray(baseSnapshot.missing) ? baseSnapshot.missing.length : 0;
      const curMiss = Array.isArray(lastMissing) ? lastMissing.length : 0;
      const missDelta = baseMiss - curMiss;

      const baseUsed = Array.isArray(baseSnapshot.used) ? baseSnapshot.used.length : 0;
      const curUsed = Array.isArray(lastUsed) ? lastUsed.length : 0;
      const usedDelta = curUsed - baseUsed;

      // Build diffs
      const baseText = String(baseSnapshot.cv_text || "");
      const curText = String($("cvText").value || "");
      const diff = diffLinesLcs(baseText, curText);

      // Risk
      const risk = assessReviewRisk(diff);
      $("trustBar").style.width = String(risk.confidence) + "%";
      $("trustHint").textContent = `Review risk: ${risk.level}. ${risk.notes.join(" · ")}.`;

      // Manual edits detection
      const manual = detectManualTextEdits();
      if(manual){
        $("btnSyncTextToDoc").style.display = "";
      }else{
        $("btnSyncTextToDoc").style.display = "none";
      }

      // KPIs
      const kpis = [];
      if(baseAts != null && curAts != null){
        const delta = curAts - baseAts;
        kpis.push(`<span class="changePill ${delta>=0 ? "good":"warn"}">ATS: ${baseAts}% → ${curAts}% ${fmtDelta(delta)}</span>`);
      }else if(curAts != null){
        kpis.push(`<span class="changePill">ATS: ${curAts}%</span>`);
      }else{
        kpis.push(`<span class="changePill">ATS: —</span>`);
      }

      kpis.push(`<span class="changePill ${missDelta>0 ? "good" : ""}">Missing keywords: ${baseMiss} → ${curMiss} ${fmtDelta(missDelta)}</span>`);
      kpis.push(`<span class="changePill ${usedDelta>0 ? "good" : ""}">Used keywords: ${baseUsed} → ${curUsed} ${fmtDelta(usedDelta)}</span>`);
      kpis.push(`<span class="changePill ${manual ? "warn" : ""}">${manual ? "Text edited manually" : "Text in sync"}</span>`);
      kpis.push(`<span class="changePill ${risk.cls}">Truth check: ${risk.level}</span>`);

      $("changeKpis").innerHTML = kpis.join("");

      // Structured doc changes (for per-bullet review)
      const docChanges = buildDocChanges(baseSnapshot.cv_doc, lastCvDoc);
      const showDocReview = !manual;

      if(!docChanges.length){
        $("changeCards").innerHTML = `<div class="hint">No structured changes detected.</div>`;
      }else{
        const baseMissingSet = new Set((baseSnapshot.missing || []).map(x => String(x||"").trim()).filter(Boolean));
        const cards = docChanges.slice(0, 120).map(ch => {
          const before = (ch.before == null) ? "" : String(ch.before);
          const after = (ch.after == null) ? "" : String(ch.after);

          // Tag any keywords newly introduced in this snippet
          const addedKws = [];
          const allKws = Array.isArray(atsKeywordsAll) ? atsKeywordsAll : [];
          for(const kw of allKws){
            if(!kw) continue;
            if(keywordInText(kw, after) && !keywordInText(kw, before)){
              const baseMissing = baseMissingSet.has(String(kw).trim());
              // prefer highlighting keywords that were missing at generation time
              if(baseMissing) addedKws.push(prettyKeyword(kw, lastLang));
              if(addedKws.length >= 6) break;
            }
          }

          const tags = [];
          if(addedKws.length) tags.push(`<span class="tag good">Added keywords: ${H.escapeHtml(addedKws.join(", "))}</span>`);
          if(Array.isArray(ch.tags)){
            for(const t of ch.tags.slice(0,3)){
              tags.push(`<span class="tag warn">${H.escapeHtml(String(t))}</span>`);
            }
          }

          const btn = showDocReview
            ? `<button class="btn small" type="button" data-revert-id="${H.escapeHtml(ch.id)}">Revert</button>`
            : `<button class="btn small" type="button" disabled title="Sync text to preview to enable per-change revert.">Revert</button>`;

          return `
            <div class="changeCard">
              <div class="changeCardTop">
                <div style="min-width:0">
                  <div class="changeTitle">${H.escapeHtml(ch.title)}</div>
                  <div class="changeMeta">${H.escapeHtml(ch.meta || "")}</div>
                </div>
                <div style="flex:0 0 auto; display:flex; gap:8px; align-items:center;">
                  ${btn}
                </div>
              </div>

              <div class="changeBody">
                <div class="changeBlock">
                  <div class="changeLabel">Before</div>
                  <div class="changeText">${H.escapeHtml(before || "—")}</div>
                </div>
                <div class="changeBlock">
                  <div class="changeLabel">After</div>
                  <div class="changeText">${H.escapeHtml(after || "—")}</div>
                  ${tags.length ? `<div class="changeTags">${tags.join("")}</div>` : ``}
                </div>
              </div>
            </div>
          `;
        }).join("");

        $("changeCards").innerHTML = cards;

        if(manual){
          $("changeCards").insertAdjacentHTML("afterbegin", `
            <div class="changeCard" style="border-color: rgba(255,179,0,.28); background: rgba(255,179,0,.06);">
              <div class="changeTitle">Heads up: Text tab edits are active</div>
              <div class="changeMeta">
                You edited the CV text manually. Preview is still based on the structured CV.
                If you want to revert changes per bullet safely, click “Sync text to preview”.
              </div>
            </div>
          `);
        }
      }

      // Render advanced diff
      const diffHtml = diff.slice(0, 1500).map(d => {
        const prefix = d.type === "add" ? "+ " : (d.type === "del" ? "- " : "  ");
        const cls = d.type === "add" ? "add" : (d.type === "del" ? "del" : "same");
        return `<span class="diffLine ${cls}">${H.escapeHtml(prefix + (d.line ?? ""))}</span>`;
      }).join("");

      $("diffBox").innerHTML = diffHtml ? `<div class="diffLines">${diffHtml}</div>` : "—";

      // Set hint
      const changedLines = diff.filter(d => d.type !== "same" && String(d.line||"").trim()).length;
      $("changesHint").textContent = changedLines
        ? `Review what changed since the last generation. (${changedLines} changed lines)`
        : "No textual changes since the last generation.";

      // Keep buttons state in sync with main Undo/Reset
      $("btnUndoFromChanges").disabled = $("btnUndoEdit")?.disabled ?? true;
      $("btnResetFromChanges").disabled = $("btnResetEdits")?.disabled ?? true;
    }

    function revertStructuredChange(changeId){
      if(!baseSnapshot || !baseSnapshot.cv_doc || !lastCvDoc) return;
      const manual = detectManualTextEdits();
      if(manual){
        showError("You edited the Text tab manually. Click “Sync text to preview” first to enable per-change revert safely.");
        return;
      }

      const baseDoc = baseSnapshot.cv_doc;
      const curDoc = lastCvDoc;

      // Find the matching change item (recompute)
      const changes = buildDocChanges(baseDoc, curDoc);
      const ch = changes.find(x => String(x.id) === String(changeId));
      if(!ch) return;

      // Save history
      historyStack.push(snapshotCurrent());
      updateUndoResetButtons();

      try{
        if(ch.kind === "summary"){
          curDoc.summary = deepCopy(baseDoc.summary);
        }else if(ch.kind === "exp_bullet"){
          const i = ch.expIndex;
          const j = ch.bulletIndex;
          const bExp = Array.isArray(baseDoc.experience) ? baseDoc.experience : [];
          const cExp = Array.isArray(curDoc.experience) ? curDoc.experience : [];
          if(!cExp[i]) return;

          const bBullets = Array.isArray(bExp[i]?.bullets) ? bExp[i].bullets : [];
          const cBullets = Array.isArray(cExp[i]?.bullets) ? cExp[i].bullets : [];

          const bb = (bBullets[j] == null) ? null : String(bBullets[j]);
          const cb = (cBullets[j] == null) ? null : String(cBullets[j]);

          if(bb == null && cb != null){
            // Added bullet -> remove
            cBullets.splice(j, 1);
          }else if(bb != null && cb == null){
            // Removed bullet -> insert back
            cBullets.splice(j, 0, bb);
          }else{
            // Edited -> restore
            cBullets[j] = bb;
          }

          cExp[i].bullets = cBullets;
          curDoc.experience = cExp;
        }else if(ch.kind === "skills_group"){
          const bSkills = baseDoc.skills || {};
          const cSkills = curDoc.skills || {};
          const bGroups = Array.isArray(bSkills.groups) ? bSkills.groups : [];
          const cGroups = Array.isArray(cSkills.groups) ? cSkills.groups : [];

          // locate group in current by key
          const key = String(ch.groupKey || "").trim().toLowerCase();
          const keyOf = (g, idx) => String(g?.label || ("#"+idx)).trim().toLowerCase();

          const bIdx = bGroups.findIndex((g, idx) => keyOf(g, idx) === key);
          const cIdx = cGroups.findIndex((g, idx) => keyOf(g, idx) === key);

          if(cIdx === -1){
            // nothing to revert
          }else if(bIdx === -1){
            // group did not exist in base -> remove group
            cGroups.splice(cIdx, 1);
          }else{
            // restore items to base
            cGroups[cIdx].items = deepCopy(bGroups[bIdx].items || []);
          }

          curDoc.skills = { ...(cSkills||{}), groups: cGroups };
        }else if(ch.kind === "skills_additional"){
          const bSkills = baseDoc.skills || {};
          const cSkills = curDoc.skills || {};
          curDoc.skills = { ...(cSkills||{}), additional: deepCopy(bSkills.additional || []) };
        }

        // Re-render + sync text to doc
        $("cvPreview").innerHTML = cvDocToPreviewHtml(curDoc, lastLang);
        $("cvText").value = cvDocToPlainText(curDoc, lastLang);

        // Keep keyword coverage in sync
        recomputeCoverageFromCurrentText();

        // Re-render changes view if active
        if($("tabChanges").classList.contains("active")){
          renderChangesView();
        }
      }catch(e){
        showError(e?.message || String(e));
      }
    }

    async function copyChangeSummary(){
      if(!baseSnapshot) return;
      const baseAts = computeAtsScore(baseSnapshot.used, baseSnapshot.missing);
      const curAts = computeAtsScore(lastUsed, lastMissing);

      const baseMiss = Array.isArray(baseSnapshot.missing) ? baseSnapshot.missing.length : 0;
      const curMiss = Array.isArray(lastMissing) ? lastMissing.length : 0;

      const baseUsed = Array.isArray(baseSnapshot.used) ? baseSnapshot.used.length : 0;
      const curUsed = Array.isArray(lastUsed) ? lastUsed.length : 0;

      const baseText = String(baseSnapshot.cv_text || "");
      const curText = String($("cvText").value || "");
      const diff = diffLinesLcs(baseText, curText);
      const risk = assessReviewRisk(diff);

      const lines = [];
      const jm = getActiveJobMeta();
      if(jm?.title) lines.push(`Job: ${jm.title}` + (jm.company_name ? ` · ${jm.company_name}` : ""));
      if(baseAts != null && curAts != null) lines.push(`ATS match: ${baseAts}% → ${curAts}%`);
      else if(curAts != null) lines.push(`ATS match: ${curAts}%`);

      lines.push(`Keywords used: ${baseUsed} → ${curUsed}`);
      lines.push(`Keywords missing: ${baseMiss} → ${curMiss}`);
      lines.push(`Truth check: ${risk.level}`);

      const topMissing = Array.isArray(lastMissing) ? lastMissing.slice(0, 10) : [];
      if(topMissing.length) lines.push(`Top missing keywords: ${topMissing.map(k => prettyKeyword(k,lastLang)).join(", ")}`);

      await copyTextToClipboard(lines.join("\n"));
      $("btnCopyChangeSummary").textContent = "Copied ✓";
      setTimeout(()=>{ $("btnCopyChangeSummary").textContent = "Copy summary"; }, 900);
    }

    async function copyDiffToClipboard(){
      if(!baseSnapshot) return;
      const baseText = String(baseSnapshot.cv_text || "");
      const curText = String($("cvText").value || "");
      const diff = diffLinesLcs(baseText, curText);

      const out = diff.map(d => {
        const prefix = d.type === "add" ? "+ " : (d.type === "del" ? "- " : "  ");
        return prefix + String(d.line ?? "");
      }).join("\n");

      await copyTextToClipboard(out);
      $("btnCopyDiff").textContent = "Copied ✓";
      setTimeout(()=>{ $("btnCopyDiff").textContent = "Copy diff"; }, 900);
    }

    function syncTextToPreview(){
      if(!lastCvDoc) return;
      $("cvText").value = cvDocToPlainText(lastCvDoc, lastLang);
      recomputeCoverageFromCurrentText();
      showError("");
      renderChangesView();
    }


    function setCvOutput({ text, doc, lang }){
      lastCvText = String(text || "").trim();
      lastCvDoc = doc || null;
      lastLang = lang || "en";

      // Preview
      if(lastCvDoc){
        $("cvPreview").innerHTML = cvDocToPreviewHtml(lastCvDoc, lastLang);
      }else{
        $("cvPreview").innerHTML = `<div class="hint">${uiLang==="de" ? "Keine strukturierte Preview verfügbar. Zeige Text." : "No structured preview available. Showing text only."}</div>`;
      }

      // Text view
      const textOut = lastCvDoc ? cvDocToPlainText(lastCvDoc, lastLang) : lastCvText;
      $("cvText").value = textOut || "";

      setOutputEnabled(!!(textOut && textOut.trim()));
      updateUndoResetButtons();
      if($("tabChanges")?.classList?.contains("active")){ try{ renderChangesView(); }catch(_){ } }
    }

    function snapshotCurrent(){
      return {
        at: Date.now(),
        cv_doc: deepCopy(lastCvDoc),
        cv_text: $("cvText").value || "",
        lang: lastLang,
        used: Array.isArray(lastUsed) ? [...lastUsed] : [],
        missing: Array.isArray(lastMissing) ? [...lastMissing] : [],
        all: Array.isArray(atsKeywordsAll) ? [...atsKeywordsAll] : []
      };
    }

    function restoreSnapshot(snap){
      if(!snap) return;
      lastCvDoc = deepCopy(snap.cv_doc);
      lastLang = snap.lang || lastLang || "en";
      $("cvText").value = String(snap.cv_text || "");
      lastUsed = Array.isArray(snap.used) ? snap.used : [];
      lastMissing = Array.isArray(snap.missing) ? snap.missing : [];
      atsKeywordsAll = Array.isArray(snap.all) ? snap.all : atsKeywordsAll;

      // rerender preview from doc if possible
      if(lastCvDoc) $("cvPreview").innerHTML = cvDocToPreviewHtml(lastCvDoc, lastLang);
      renderKeywords();
      updateUndoResetButtons();
    }

    /* -------------------------
       Queue loading
       ------------------------- */
    async function loadQueue(){
      const resp = await apiGet("/me/jobs/queue");
      jobs = Array.isArray(resp?.data) ? resp.data : [];
      const sel = $("jobSelect");
      sel.innerHTML = "";

      if(!jobs.length){
        sel.innerHTML = `<option value="">${uiLang==="de" ? "Keine Jobs in der Queue" : "No jobs in queue"}</option>`;
        setText("jobHint", uiLang==="de" ? "Keine Jobs gefunden. Öffne Jobs und lade neue Jobs." : "No jobs found. Go to Jobs and fetch new jobs.");
        setText("jobMeta", "");
        selectedJob = null;

        if(jobSource === "queue"){
          $("btnGenerate").disabled = true;
          $("btnGenerateAgain").disabled = true;
          $("btnViewDesc").disabled = true;
          $("btnCopyDesc").disabled = true;
        }else{
          // Paste mode can still be used even with an empty queue
          refreshModeUi();
        }
        return;
      }

      for(const j of jobs){
        const label = [j.title || (uiLang==="de" ? "Ohne Titel" : "Untitled"), j.company_name || (uiLang==="de" ? "Firma" : "Company")].filter(Boolean).join(" · ");
        const opt = document.createElement("option");
        opt.value = String(j.id);
        opt.textContent = label;
        sel.appendChild(opt);
      }

      const urlJobId = (qs("job_id") || "").trim();
      const storedJobId = (localStorage.getItem("cvstudio_selected_job_id") || "").trim();
      const preferred = urlJobId || storedJobId;

      if(preferred && jobs.some(j => String(j.id) === String(preferred))){
        sel.value = preferred;
      } else {
        sel.value = String(jobs[0].id);
      }

      await onJobChange();
    }

    async function onJobChange(){
      const jobId = $("jobSelect").value;
      selectedJob = jobs.find(j => String(j.id) === String(jobId)) || null;

      // If user is in paste mode, keep the queue selection in memory but don't change UI state.
      if(jobSource !== "queue"){
        return;
      }

      if(!selectedJob){
        setText("jobMeta", "");
        $("btnGenerate").disabled = true;
        $("btnGenerateAgain").disabled = true;
        $("btnViewDesc").disabled = true;
        $("btnCopyDesc").disabled = true;
        return;
      }

      try{ localStorage.setItem("cvstudio_selected_job_id", String(selectedJob.id)); }catch{}

      const meta = [
        selectedJob.company_name ? String(selectedJob.company_name) : null,
        formatLoc(selectedJob) || null
      ].filter(Boolean).join(" · ");

      setText("jobHint", (uiLang==="de" ? "Ausgewählt: " : "Selected: ") + (selectedJob.title || (uiLang==="de" ? "Job" : "Job")));
      setText("jobMeta", meta ? meta : "");

      $("btnGenerate").disabled = false;
      $("btnGenerateAgain").disabled = false;
      $("btnViewDesc").disabled = false;
      $("btnCopyDesc").disabled = false;

      // Restore last from localStorage for this job (best effort)
      try{
        const key = "cvstudio_last_" + String(selectedJob.id);
        const raw = localStorage.getItem(key);
        if(raw){
          const obj = JSON.parse(raw);
          if(obj && (obj.cv_doc || obj.cv_text)){
            lastUsed = Array.isArray(obj.used) ? obj.used : [];
            lastMissing = Array.isArray(obj.missing) ? obj.missing : [];
            atsKeywordsAll = Array.isArray(obj.all) ? obj.all : Array.from(new Set([...(lastUsed||[]), ...(lastMissing||[])]));

            renderKeywords();

            setCvOutput({ text: obj.cv_text || "", doc: obj.cv_doc || null, lang: obj.lang || obj.language || "en" });
            setBadge("outStatus","good", uiLang==="de" ? "Bereit (lokal)" : "Ready (local)");
            setText("outModel","Model: —");
            setText("outHint", uiLang==="de"
              ? "Letzten CV von diesem Gerät geladen. Generiere neu für ein frisches Ergebnis."
              : "Loaded your last tailored CV from this device. Generate to refresh from server."
            );

            baseSnapshot = snapshotCurrent();
            historyStack = [];
            updateUndoResetButtons();
          }
        }
      }catch(_){}
    }

    function buildTailorPayload(){
      // IMPORTANT: keep payload minimal to avoid breaking strict backends
      const tpl = String($("tplSelect").value || "professional").trim().toLowerCase();
      const s = strengthValue();
      return { job_id: String(selectedJob?.id || ""), template: tpl, strength: s.key };
    }

    /* -------------------------
       Generate
       ------------------------- */
    async function generate(){
      showError("");

      if(jobSource === "paste"){
        await generateFromPaste();
        return;
      }

      if(!selectedJob){
        showError(t("pickJob"));
        return;
      }

      markSteps("running");
      setBadge("outStatus", "warn", uiLang==="de" ? "Generiere…" : "Generating…");
      setText("outHint", uiLang==="de" ? "Dein CV wird erstellt…" : "Generating your tailored CV…");
      setText("debugBox", "—");
      setBadge("pipeBadge", "warn", uiLang==="de" ? "Arbeite…" : "Working…");

      $("btnGenerate").disabled = true;
      $("btnGenerateAgain").disabled = true;

      try{
        const payload = buildTailorPayload();
        const res = await apiPostJson("/me/cv/tailor", payload);

        if(!res || res.ok !== true){
          throw new Error(res?.error || "CV tailoring failed");
        }

        const r = res.result || {};
        const text = String(r.cv_text || "").trim();
        const doc = r.cv_doc || null;
        const lang = r.language || "en";

        lastUsed = Array.isArray(r.ats_keywords_used) ? r.ats_keywords_used : [];
        lastMissing = Array.isArray(r.ats_keywords_missing) ? r.ats_keywords_missing : [];
        atsKeywordsAll = Array.from(new Set([...(lastUsed||[]), ...(lastMissing||[])].map(x=>String(x||"").trim()).filter(Boolean)));

        lastDebug = {
          cached: !!res.cached,
          cache_age_seconds: res.cache_age_seconds ?? null,
          model: r.model || null,
          prompt_version: r.prompt_version || null,
          language: lang || null,
          desc_cache_status: r.desc_cache_status || null,
          cv_clean_status: r.cv_clean_status || null,
          cv_clean_model: r.cv_clean_model || null,
          cv_structured_status: r.cv_structured_status || null,
          cv_structured_model: r.cv_structured_model || null
        };

        renderKeywords();
        setCvOutput({ text, doc, lang });

        // Reset edit history on each new generation
        baseSnapshot = snapshotCurrent();
        historyStack = [];
        updateUndoResetButtons();

        setBadge("outStatus", "good", res.cached ? (uiLang==="de" ? "Bereit (cached)" : "Ready (cached)") : (uiLang==="de" ? "Bereit" : "Ready"));
        setText("outModel", "Model: " + (r.model || "—"));
        setText("outHint", res.cached
          ? (uiLang==="de"
            ? "Cached Ergebnis geladen. Ändere die Stärke, um eine neue Version zu erstellen."
            : "Loaded cached result. Change strength to create a different version.")
          : (uiLang==="de"
            ? "Neuer Tailored CV erstellt. Bitte prüfen und exportieren."
            : "Generated a new tailored CV. Review and export below.")
        );
        markSteps("done");

        const lines = [
          "Job description: " + String(r.desc_cache_status || "—"),
          "CV clean: " + String(r.cv_clean_status || "—") + (r.cv_clean_model ? (" (" + r.cv_clean_model + ")") : ""),
          "CV structured: " + String(r.cv_structured_status || "—") + (r.cv_structured_model ? (" (" + r.cv_structured_model + ")") : ""),
          res.cached ? ("Cache: used (" + String(res.cache_age_seconds || "0") + "s old)") : "Cache: generated"
        ];
        $("pipeBox").textContent = lines.join("\n");
        setBadge("pipeBadge", "good", "OK");

        $("debugBox").textContent = JSON.stringify({ ok:true, ...lastDebug }, null, 2);

        // Save last output locally (best effort)
        try{
          const key = "cvstudio_last_" + String(payload.job_id);
          localStorage.setItem(key, JSON.stringify({
            at: Date.now(),
            payload,
            cv_text: $("cvText").value || "",
            cv_doc: lastCvDoc,
            lang: lastLang,
            used: lastUsed,
            missing: lastMissing,
            all: atsKeywordsAll,
            debug: lastDebug
          }));
        }catch(_){}
      }catch(e){
        markSteps("error");
        setBadge("outStatus","bad", uiLang==="de" ? "Fehler" : "Failed");
        setBadge("pipeBadge","bad", uiLang==="de" ? "Fehler" : "Failed");
        showError(e?.message || String(e));
        $("debugBox").textContent = JSON.stringify({ ok:false, error: e?.message || String(e) }, null, 2);
        setText("outHint", uiLang==="de" ? "Generierung fehlgeschlagen. Prüfe CV Upload und Jobbeschreibung." : "Failed to generate. Check your CV upload and job description availability.");
      }finally{
        $("btnGenerate").disabled = false;
        $("btnGenerateAgain").disabled = false;
      }
    }

    
    function isMissingEndpointError(e){
      const msg = String(e?.message || e || "");
      return /failed:\s*404\b/.test(msg) || /failed:\s*405\b/.test(msg);
    }

    function buildTailorFromTextPayload(){
      // keep payload minimal + explicit; backend should treat job_description as untrusted text
      const tpl = String($("tplSelect").value || "professional").trim().toLowerCase();
      const s = strengthValue();

      const job_title = String($("pasteTitle")?.value || "").trim();
      const company_name = String($("pasteCompany")?.value || "").trim();
      const apply_url = applyUrlSafe(String($("pasteApply")?.value || "").trim());
      const language_hint = String($("pasteLangHint")?.value || "auto").trim().toLowerCase();
      const job_description = getPasteDesc();

      return {
        template: tpl,
        strength: s.key,
        job_title,
        company_name,
        apply_url,
        language_hint,
        job_description
      };
    }

    async function generateFromPaste(){
      showError("");

      const desc = getPasteDesc();

      if(desc.length > 20000){
        showError(t("pasteTooLong"));
        return;
      }
      if(desc.length < 120){
        // We allow small texts in UI, but tailoring quality drops sharply below this.
        showError(t("pasteTooShort"));
        return;
      }

      markSteps("running");
      setBadge("outStatus", "warn", uiLang==="de" ? "Generiere…" : "Generating…");
      setText("outHint", uiLang==="de" ? "Dein CV wird erstellt…" : "Generating your tailored CV…");
      setText("debugBox", "—");
      setBadge("pipeBadge", "warn", uiLang==="de" ? "Arbeite…" : "Working…");

      $("btnGenerate").disabled = true;
      $("btnGenerateAgain").disabled = true;

      try{
        const payload = buildTailorFromTextPayload();

        // Try common endpoint names (so you can roll this out without changing the frontend again)
        const endpoints = [
          "/me/cv/tailor_from_text",
          "/me/cv/tailor-from-text",
          "/me/cv/tailor_text"
        ];

        let res = null;
        let usedEndpoint = null;

        for(const ep of endpoints){
          try{
            res = await apiPostJson(ep, payload);
            usedEndpoint = ep;
            break;
          }catch(e){
            if(isMissingEndpointError(e)) continue;
            throw e;
          }
        }

        // Optional fallback: create a temporary job on the backend, then call the existing tailor endpoint.
        // Implement one of these endpoints if you prefer that architecture.
        if(!res){
          const createEndpoints = [
            "/me/jobs/create_from_text",
            "/me/jobs/import_text",
            "/me/jobs/create_from_desc",
            "/me/jobs/create_from_description"
          ];

          const createPayload = {
            title: payload.job_title || "Pasted job",
            company_name: payload.company_name || "",
            apply_url: payload.apply_url || "",
            description: payload.job_description,
            language_hint: payload.language_hint || "auto",
            source: "pasted"
          };

          for(const ep of createEndpoints){
            try{
              const r0 = await apiPostJson(ep, createPayload);
              const tmpJobId = r0?.job_id || r0?.id || r0?.data?.id || r0?.job?.id || r0?.result?.job_id || null;
              if(tmpJobId){
                usedEndpoint = ep + " + /me/cv/tailor";
                res = await apiPostJson("/me/cv/tailor", { job_id: String(tmpJobId), template: payload.template, strength: payload.strength });
                break;
              }
            }catch(e){
              if(isMissingEndpointError(e)) continue;
              throw e;
            }
          }
        }

        if(!res){
          throw new Error(t("pasteNotSupported"));
        }

        if(!res || res.ok !== true){
          throw new Error(res?.error || "CV tailoring failed");
        }

        const r = res.result || {};
        const text = String(r.cv_text || "").trim();
        const doc = r.cv_doc || null;
        const lang = r.language || payload.language_hint || "en";

        lastUsed = Array.isArray(r.ats_keywords_used) ? r.ats_keywords_used : [];
        lastMissing = Array.isArray(r.ats_keywords_missing) ? r.ats_keywords_missing : [];
        atsKeywordsAll = Array.from(new Set([...(lastUsed||[]), ...(lastMissing||[])].map(x=>String(x||"").trim()).filter(Boolean)));

        lastDebug = {
          cached: !!res.cached,
          cache_age_seconds: res.cache_age_seconds ?? null,
          model: r.model || null,
          prompt_version: r.prompt_version || null,
          language: lang || null,
          job_source: "paste",
          tailor_endpoint: usedEndpoint || "unknown",
          desc_cache_status: r.desc_cache_status || "pasted",
          cv_clean_status: r.cv_clean_status || null,
          cv_clean_model: r.cv_clean_model || null,
          cv_structured_status: r.cv_structured_status || null,
          cv_structured_model: r.cv_structured_model || null
        };

        renderKeywords();
        setCvOutput({ text, doc, lang });

        // Reset edit history on each new generation
        baseSnapshot = snapshotCurrent();
        historyStack = [];
        updateUndoResetButtons();

        setBadge("outStatus", "good", res.cached ? (uiLang==="de" ? "Bereit (cached)" : "Ready (cached)") : (uiLang==="de" ? "Bereit" : "Ready"));
        setText("outModel", "Model: " + (r.model || "—"));
        setText("outHint", res.cached
          ? (uiLang==="de"
            ? "Cached Ergebnis geladen. Ändere die Stärke, um eine neue Version zu erstellen."
            : "Loaded cached result. Change strength to create a different version.")
          : (uiLang==="de"
            ? "Neuer Tailored CV erstellt. Bitte prüfen und exportieren."
            : "Generated a new tailored CV. Review and export below.")
        );
        markSteps("done");

        const lines = [
          "Job description: pasted",
          "Tailor endpoint: " + String(usedEndpoint || "—"),
          "CV clean: " + String(r.cv_clean_status || "—") + (r.cv_clean_model ? (" (" + r.cv_clean_model + ")") : ""),
          "CV structured: " + String(r.cv_structured_status || "—") + (r.cv_structured_model ? (" (" + r.cv_structured_model + ")") : ""),
          res.cached ? ("Cache: used (" + String(res.cache_age_seconds || "0") + "s old)") : "Cache: generated"
        ];
        $("pipeBox").textContent = lines.join("\n");
        setBadge("pipeBadge", "good", "OK");

        $("debugBox").textContent = JSON.stringify({ ok:true, ...lastDebug }, null, 2);

        // Save last output locally (best effort)
        try{
          const key = pasteCacheKey || ("cvstudio_last_paste_" + fnv1a(desc));
          localStorage.setItem(key, JSON.stringify({
            at: Date.now(),
            payload,
            cv_text: $("cvText").value || "",
            cv_doc: lastCvDoc,
            lang: lastLang,
            used: lastUsed,
            missing: lastMissing,
            all: atsKeywordsAll,
            debug: lastDebug
          }));
        }catch(_){}
      }catch(e){
        markSteps("error");
        setBadge("outStatus","bad", uiLang==="de" ? "Fehler" : "Failed");
        setBadge("pipeBadge","bad", uiLang==="de" ? "Fehler" : "Failed");
        showError(e?.message || String(e));
        $("debugBox").textContent = JSON.stringify({ ok:false, error: e?.message || String(e) }, null, 2);
        setText("outHint", uiLang==="de" ? "Generierung fehlgeschlagen. Prüfe Jobbeschreibung." : "Failed to generate. Check your pasted job description.");
      }finally{
        refreshModeUi();
      }
    }


    /* -------------------------
       Description modal
       ------------------------- */
    async function openDescModal(){
      showError("");

      const jm = getActiveJobMeta();

      if(jobSource === "queue" && !selectedJob){
        showError(t("pickJob"));
        return;
      }

      H.showModal("descModal");
      $("descH").textContent = jm.title || (uiLang==="de" ? "Jobbeschreibung" : "Job description");

      const loc = (jobSource === "queue" && selectedJob) ? formatLoc(selectedJob) : "";
      $("descMeta").textContent = [jm.company_name || "", loc].filter(Boolean).join(" · ");

      $("descText").textContent = uiLang==="de" ? "Lade…" : "Loading…";
      $("descOpen").setAttribute("href", "#");
      $("descCopy").textContent = t("copy");
      selectedDesc = "";
      selectedApplyUrl = applyUrlSafe(jm.apply_url);

      if(selectedApplyUrl){
        $("descOpen").setAttribute("href", selectedApplyUrl);
        $("descOpen").classList.remove("ghost");
      }else{
        $("descOpen").setAttribute("href", "#");
        $("descOpen").classList.add("ghost");
      }

      // Paste mode: show pasted text immediately (no API call)
      if(jobSource === "paste"){
        const txt = getPasteDesc();
        selectedDesc = txt || (uiLang==="de" ? "(Keine Beschreibung eingefügt.)" : "(No description pasted.)");
        $("descText").textContent = selectedDesc;
        return;
      }

      try{
        const resp = await apiGet("/me/jobs/description?job_id=" + encodeURIComponent(String(selectedJob.id)));
        const job = resp?.job || null;
        const txt = String(job?.description_full || job?.description || "").trim();
        selectedDesc = txt || (uiLang==="de" ? "(Keine Beschreibung verfügbar.)" : "(No description available.)");
        $("descText").textContent = selectedDesc;
      }catch(e){
        $("descText").textContent = (uiLang==="de" ? "Beschreibung konnte nicht geladen werden." : "Failed to load description.") + "\n\n" + (e?.message || String(e));
      }
    }


    async function copyTextToClipboard(txt){
      const text = String(txt || "");
      if(!text) return;
      try{
        await navigator.clipboard.writeText(text);
      }catch(_){
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        try{ document.execCommand("copy"); }catch{}
        document.body.removeChild(ta);
      }
    }

    async function copyDesc(){
      if(jobSource === "paste"){
        const d = getPasteDesc();
        if(!d) return;
        await copyTextToClipboard(d);
        return;
      }

      if(!selectedDesc){
        await openDescModal();
        return;
      }
      await copyTextToClipboard(selectedDesc);
    }

    /* -------------------------
       Copy / Download / Print
       ------------------------- */
    async function copyCv(){
      const txt = $("cvText").value || "";
      if(!txt.trim()) return;
      await copyTextToClipboard(txt);
      $("btnCopy").textContent = t("copied");
      setTimeout(()=>{ $("btnCopy").textContent = t("copy"); }, 900);
    }

    function downloadTxt(){
      const txt = $("cvText").value || "";
      if(!txt.trim()) return;

      const jm = getActiveJobMeta();
      const title = (jm?.title ? String(jm.title).slice(0, 60) : "tailored_cv");
      const safe = title.replace(/[^a-z0-9\-\_ ]/gi, "").trim().replace(/\s+/g, "_") || "tailored_cv";
      const filename = safe + ".txt";

      const blob = new Blob([txt], { type:"text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function printPdf(){
      const jm = getActiveJobMeta();
      const jobTitle = jm?.title ? String(jm.title) : "Curriculum Vitae";
      const html = (lastCvDoc)
        ? cvDocToPrintableHtml(lastCvDoc, lastLang, jobTitle)
        : cvTextToPrintableHtml(jobTitle, $("cvText").value || "");
      printHtml(html);
    }

    async function copyMissing(){
      const miss = Array.isArray(lastMissing) ? lastMissing : [];
      if(!miss.length) return;
      const text = miss.map(k => prettyKeyword(k,lastLang)).join(", ");
      await copyTextToClipboard(text);
      $("btnCopyMissing").textContent = t("copied");
      setTimeout(()=>{ $("btnCopyMissing").textContent = t("copyMissing"); }, 900);
    }

    /* -------------------------
       Keyword booster (modal)
       ------------------------- */
    function setKwMode(mode){
      kwMode = mode === "quick" ? "quick" : "ai";
      const btns = $("kwModeToggle").querySelectorAll("button");
      btns.forEach(b => b.classList.toggle("active", b.getAttribute("data-mode") === kwMode));

      // Show/hide AI recommendation box
      const recoBox = $("kwAiRecoBox");
      if(recoBox) recoBox.style.display = (kwMode === "ai") ? "" : "none";

      // If user switches to AI while modal is open, refresh recommendation (non-blocking)
      if(kwMode === "ai" && activeKeywordRaw && lastCvDoc){
        const ready = (($("kwSkillGroup")?.options?.length || 0) > 0) || (($("kwExpRole")?.options?.length || 0) > 0);
        if(ready){
          try{ aiRecommendPlacement({ force:false, source:"mode" }); }catch(_){}
        }
      }

      updateKwPreview();
    }

    function chosenKwLang(){
      const v = String($("kwLang").value || "auto");
      if(v === "de" || v === "en") return v;
      // auto
      return isLikelyGerman(lastLang) ? "de" : "en";
    }

    function fillSkillGroups(){
      const sel = $("kwSkillGroup");
      sel.innerHTML = "";
      const groups = Array.isArray(lastCvDoc?.skills?.groups) ? lastCvDoc.skills.groups : [];
      groups.forEach((g, idx) => {
        const label = String(g?.label || "").trim() || (uiLang==="de" ? ("Gruppe " + (idx+1)) : ("Group " + (idx+1)));
        const opt = document.createElement("option");
        opt.value = "group:" + idx;
        opt.textContent = label;
        sel.appendChild(opt);
      });
      // additional bucket
      const opt2 = document.createElement("option");
      opt2.value = "additional";
      opt2.textContent = uiLang==="de" ? "Weitere Skills" : "Additional skills";
      sel.appendChild(opt2);

      if(sel.options.length) sel.value = sel.options[0].value;
    }

    function fillExperienceRoles(){
      const sel = $("kwExpRole");
      sel.innerHTML = "";
      const exp = Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [];
      exp.forEach((e, idx) => {
        const title = joinNonEmpty([e?.title, e?.company], " · ") || (uiLang==="de" ? ("Station " + (idx+1)) : ("Role " + (idx+1)));
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = title;
        sel.appendChild(opt);
      });
      if(sel.options.length) sel.value = "0";
      fillBulletsForSelectedRole();
    }

    function fillBulletsForSelectedRole(){
      const expIdx = Number($("kwExpRole").value || "0");
      const e = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[expIdx] || null;
      const bullets = asStringArr(e?.bullets, 50);

      const sel = $("kwExpBullet");
      sel.innerHTML = "";
      bullets.forEach((b, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = (String(b).length > 70 ? (String(b).slice(0,70) + "…") : String(b));
        sel.appendChild(opt);
      });

      if(sel.options.length){
        sel.value = "0";
        $("kwBulletPreview").textContent = bullets[0] || "—";
      }else{
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = uiLang==="de" ? "Keine Bullets vorhanden" : "No bullets available";
        sel.appendChild(opt);
        $("kwBulletPreview").textContent = uiLang==="de" ? "Diese Station hat noch keine Bullets." : "This role has no bullets.";
      }
    }

    
    // -------------------------
    // AI recommendation (best placement)
    // -------------------------
    function clearKwAiReco(){
      kwAiReco = null;
      kwAiRecoKey = "";
      kwAiKeywordPretty = "";
      try{ setBadge("kwAiRecoBadge","", "—"); }catch(_){}
      try{ setText("kwAiRecoText", "—"); }catch(_){}
    }

    function setKwAiRecoLoading(){
      setBadge("kwAiRecoBadge","warn", uiLang==="de" ? "Denke…" : "Thinking…");
      setText("kwAiRecoText", uiLang==="de"
        ? "Finde das beste Placement und erstelle einen Vorschlag…"
        : "Finding the best placement and drafting a suggestion…"
      );
    }

    function setKwAiRecoError(msg){
      setBadge("kwAiRecoBadge","warn", uiLang==="de" ? "Nicht verfügbar" : "Unavailable");
      setText("kwAiRecoText", msg || (uiLang==="de"
        ? "Du kannst weiterhin Auto-pick oder Skills nutzen."
        : "You can still use Auto-pick or add it under Skills."
      ));
    }

    function slimCvDocForSuggest(doc){
      if(!doc || typeof doc !== "object") return null;

      const exp = Array.isArray(doc.experience) ? doc.experience : [];
      const expOut = exp.slice(0, 10).map((e) => ({
        title: String(e?.title || "").trim(),
        company: String(e?.company || "").trim(),
        bullets: asStringArr(e?.bullets, 10).map(b => String(b).trim().slice(0, 260))
      }));

      const skills = (doc.skills && typeof doc.skills === "object") ? doc.skills : {};
      const groups = Array.isArray(skills.groups) ? skills.groups : [];
      const groupsOut = groups.slice(0, 10).map((g) => ({
        label: String(g?.label || "").trim(),
        items: asStringArr(g?.items, 25).map(x => String(x).trim().slice(0, 80))
      }));

      const additionalOut = asStringArr(skills.additional, 60).map(x => String(x).trim().slice(0, 80));

      return { experience: expOut, skills: { groups: groupsOut, additional: additionalOut } };
    }

    function getAiRecoCacheKey(keyword, lang){
      const base = String(lastDebug?.input_hash || lastDebug?.hash || "");
      const src = String(jobSource || "queue");
      return [normForMatch(keyword), base, String(lang||""), src].join("|");
    }

    function roleLabelByIndex(expIdx){
      const e = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[Number(expIdx)||0] || null;
      return e ? (joinNonEmpty([e?.title, e?.company], " · ") || "") : "";
    }

    function skillGroupLabelByKey(groupKey){
      if(groupKey === "additional") return uiLang==="de" ? "Weitere Skills" : "Additional skills";
      const s = String(groupKey || "");
      if(s.startsWith("group:")){
        const idx = Number(s.split(":")[1] || "0");
        const g = (Array.isArray(lastCvDoc?.skills?.groups) ? lastCvDoc.skills.groups : [])[idx] || null;
        return String(g?.label || "").trim() || (uiLang==="de" ? ("Gruppe " + (idx+1)) : ("Group " + (idx+1)));
      }
      return uiLang==="de" ? "Skills" : "Skills";
    }

    function applyAiRecoToModalUi(reco){
      if(!reco) return;

      const target = String(reco.target || "").toLowerCase() === "experience" ? "experience" : "skills";
      $("kwTarget").value = target;
      updateKwTargetUi();

      if(target === "skills"){
        const sg = String(reco.skill_group || reco.skillGroup || "additional");
        if($("kwSkillGroup") && [...$("kwSkillGroup").options].some(o => o.value === sg)){
          $("kwSkillGroup").value = sg;
        }else{
          $("kwSkillGroup").value = "additional";
        }
      }else{
        const expIdx = Number(reco.exp_index ?? reco.expIdx ?? 0);
        const bulletIdx = Number(reco.bullet_index ?? reco.bulletIdx ?? 0);

        $("kwExpRole").value = String(Math.max(0, expIdx));
        fillBulletsForSelectedRole();

        if($("kwExpBullet") && [...$("kwExpBullet").options].some(o => o.value === String(bulletIdx))){
          $("kwExpBullet").value = String(bulletIdx);
        }else{
          $("kwExpBullet").value = "0";
        }

        $("kwExpHow").value = "rewrite";
        updateKwExpHowUi();

        const e = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[Number($("kwExpRole").value||0)] || null;
        const bullets = asStringArr(e?.bullets, 50);
        const i = Number($("kwExpBullet").value || "0");
        $("kwBulletPreview").textContent = bullets[i] || "—";
      }

      updateKwPreview();
    }

    function renderAiRecoBox(reco, lang){
      if(!reco){ clearKwAiReco(); return; }

      const conf = (typeof reco.confidence === "number") ? reco.confidence
        : (typeof reco.confidence_score === "number") ? reco.confidence_score
        : null;

      const confTxt = (conf != null && conf >= 0 && conf <= 1) ? (" • " + Math.round(conf*100) + "%") : "";
      setBadge("kwAiRecoBadge","good", (uiLang==="de" ? "Empfohlen" : "Recommended") + confTxt);

      const reason = String(reco.reason || "").trim();
      const target = String(reco.target || "").toLowerCase() === "experience" ? "experience" : "skills";

      if(target === "experience"){
        const expIdx = Number(reco.exp_index ?? reco.expIdx ?? 0);
        const bulletIdx = Number(reco.bullet_index ?? reco.bulletIdx ?? 0);
        const role = roleLabelByIndex(expIdx) || (uiLang==="de" ? "Experience" : "Experience");
        const rb = String(reco.rewritten_bullet || reco.rewrite || "").trim();

        const header = `Experience → ${role} (Bullet ${bulletIdx+1})`;
        const lines = [
          header,
          reason ? ("Reason: " + reason) : "",
          rb ? ("Suggested rewrite: " + rb) : ""
        ].filter(Boolean);

        setText("kwAiRecoText", lines.join("\n"));
      }else{
        const sg = String(reco.skill_group || reco.skillGroup || "additional");
        const groupLbl = skillGroupLabelByKey(sg);
        const item = String(reco.skill_item || reco.skillItem || prettyKeyword(activeKeywordRaw, lang)).trim();

        const header = `Skills → ${groupLbl}`;
        const lines = [
          header,
          reason ? ("Reason: " + reason) : "",
          item ? ("Suggested skill: " + item) : ""
        ].filter(Boolean);

        setText("kwAiRecoText", lines.join("\n"));
      }
    }

    async function tryAiSuggestPlacement({ keyword, lang, cv_doc, context }){
      const endpoints = [
        "/me/cv/keyword_suggest",
        "/me/cv/keyword_recommend"
      ];

      const payload = {
        keyword: String(keyword || ""),
        language: String(lang || ""),
        lang: String(lang || ""),
        cv_doc: cv_doc || null,
        context: context || {}
      };

      for(const ep of endpoints){
        try{
          const res = await apiPostJson(ep, payload);
          // expected: { ok:true, recommendation:{...}, keyword_pretty?:string }
          const keywordPretty = String(
            res?.keyword_pretty
              || res?.keywordPretty
              || res?.result?.keyword_pretty
              || res?.result?.keywordPretty
              || ""
          ).trim();

          const reco = res?.recommendation || res?.result?.recommendation || res?.result || res;
          if(reco && typeof reco === "object"){
            // Sometimes backend returns { recommendation:{...} } or a flat object
            const r = reco.recommendation || reco;
            if(r && (r.target || r.skill_group || r.exp_index != null)){
              return {
                ok: true,
                reco: r,
                endpoint: ep,
                keyword_pretty: keywordPretty,
                model: String(res?.model || res?.result?.model || ""),
                prompt_version: String(res?.prompt_version || res?.promptVersion || res?.result?.prompt_version || "")
              };
            }
          }
        }catch(e){
          if(isEndpointMissing(e)) continue;
          throw e;
        }
      }
      return { ok:false, reco:null, endpoint:"", keyword_pretty:"", model:"", prompt_version:"" };
    }

    async function aiRecommendPlacement({ force=false, source="auto" } = {}){
      if(!lastCvDoc || !activeKeywordRaw) return;
      if(kwMode !== "ai") return;

      const lang = chosenKwLang();
      const cacheKey = getAiRecoCacheKey(activeKeywordRaw, lang);
      kwAiRecoKey = cacheKey;

      // Cache hit
      if(!force && kwAiRecoCache.has(cacheKey)){
        const cached = kwAiRecoCache.get(cacheKey);
        kwAiReco = cached;
        kwAiKeywordPretty = String(cached?.keyword_pretty || "").trim();

        // If backend provided a nicer display, use it in the chip (does not change the raw keyword)
        if(kwAiKeywordPretty){
          activeKeywordDisplay = kwAiKeywordPretty;
          if($("kwChip")) $("kwChip").textContent = kwAiKeywordPretty;
        }

        applyAiRecoToModalUi(cached);
        renderAiRecoBox(cached, lang);
        return;
      }

      const token = ++kwAiRecoToken;
      setKwAiRecoLoading();

      try{
        const ctx = {
          target_language: lang,
          cv_language: lastLang,
          job: getActiveJobMeta(),
          source: source
        };

        const slim = slimCvDocForSuggest(lastCvDoc);
        const out = await tryAiSuggestPlacement({ keyword: activeKeywordRaw, lang, cv_doc: slim, context: ctx });

        if(token !== kwAiRecoToken) return; // stale

        if(out.ok && out.reco){
          const packed = Object.assign({}, out.reco);
          if(out.keyword_pretty) packed.keyword_pretty = out.keyword_pretty;

          kwAiReco = packed;
          kwAiKeywordPretty = String(out.keyword_pretty || packed.keyword_pretty || "").trim();
          kwAiRecoCache.set(cacheKey, packed);

          // If backend provided a nicer display, use it in the chip (does not change the raw keyword)
          if(kwAiKeywordPretty){
            activeKeywordDisplay = kwAiKeywordPretty;
            if($("kwChip")) $("kwChip").textContent = kwAiKeywordPretty;
          }

          applyAiRecoToModalUi(packed);
          renderAiRecoBox(packed, lang);
          updateKwPreview();
        }else{
          clearKwAiReco();
          setKwAiRecoError(uiLang==="de" ? "Keine Empfehlung verfügbar." : "No recommendation available.");
        }
      }catch(e){
        if(token !== kwAiRecoToken) return;
        clearKwAiReco();
        setKwAiRecoError((uiLang==="de" ? "AI Empfehlung fehlgeschlagen." : "AI recommendation failed.") + " " + (e?.message || String(e)));
      }
    }

function openKwModal(keywordRaw){
      showError("");
      if(!lastCvDoc && !($("cvText").value || "").trim()){
        showError(t("needCv"));
        return;
      }

      activeKeywordRaw = String(keywordRaw || "").trim();
      activeKeywordDisplay = prettyKeyword(activeKeywordRaw, lastLang);
      $("kwChip").textContent = activeKeywordDisplay || "—";
      $("kwTruth").checked = false;

      // Reset AI recommendation for this keyword
      try{ clearKwAiReco(); }catch(_){ }

      // Default language: auto (match CV language unless user overrides)
      $("kwLang").value = "auto";

      // Default mode: AI (best quality)
      setKwMode("ai");

      // Smart default target:
      // - Tool-like keywords (SQL/Excel/etc.) → Skills
      // - Otherwise → Experience (rewrite a bullet) if possible
      let recommendedTarget = "skills";
      if(lastCvDoc){
        recommendedTarget = isToolLikeKeyword(activeKeywordRaw) ? "skills" : "experience";
      }
      $("kwTarget").value = recommendedTarget;

      // Populate role/groups if doc available
      if(lastCvDoc){
        fillSkillGroups();
        fillExperienceRoles();

        // If we recommend Experience: auto-pick the best matching role + bullet
        if(recommendedTarget === "experience"){
          try{
            const best = pickBestRoleAndBullet(activeKeywordRaw);
            $("kwExpRole").value = String(best.expIdx || 0);
            fillBulletsForSelectedRole();
            $("kwExpBullet").value = String(best.bulletIdx || 0);
            // Update bullet preview text
            const e = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[Number(best.expIdx||0)] || null;
            const bullets = asStringArr(e?.bullets, 50);
            $("kwBulletPreview").textContent = bullets[Number(best.bulletIdx||0)] || "—";
            // Default experience action = rewrite (best)
            $("kwExpHow").value = "rewrite";
          }catch(_){}
        }
      }else{
        // if no doc, force skills box only (text-only)
        $("kwTarget").value = "skills";
      }

      // Show/hide boxes
      updateKwTargetUi();
      updateKwPreview();

      H.showModal("kwModal");

      // AI recommends best placement + draft rewrite (non-blocking)
      if(kwMode === "ai" && lastCvDoc){
        try{ aiRecommendPlacement({ force:false, source:"open" }); }catch(_){ }
      }
    }

    function closeKwModal(){
      H.hideModal("kwModal");
      activeKeywordRaw = "";
      activeKeywordDisplay = "";
      $("kwResultPreview").textContent = "—";
      $("kwNote").value = "";

      // Cancel any in-flight AI recommendation and reset UI
      try{ kwAiRecoToken += 1; }catch(_){ }
      try{ clearKwAiReco(); }catch(_){ }
    }

    function updateKwTargetUi(){
      const target = String($("kwTarget").value || "skills");
      const hasDoc = !!lastCvDoc;

      $("kwSkillsBox").style.display = (target === "skills") ? "" : "none";
      $("kwExpBox").style.display = (target === "experience" && hasDoc) ? "" : "none";

      if(target === "experience" && !hasDoc){
        // can't do experience insert without doc
        $("kwTarget").value = "skills";
        $("kwSkillsBox").style.display = "";
        $("kwExpBox").style.display = "none";
      }

      updateKwExpHowUi();
    }

    function updateKwExpHowUi(){
      const how = String($("kwExpHow").value || "rewrite");
      const showPick = (how === "rewrite" || how === "append");
      $("kwBulletPickBox").style.display = showPick ? "" : "none";

      const showNote = (how === "new");
      $("kwNoteBox").style.display = showNote ? "" : "none";
      $("kwNewWarn").style.display = showNote ? "" : "none";

      updateKwPreview();
    }

    function buildKwPreviewText(){
      const target = String($("kwTarget").value || "skills");
      const lang = chosenKwLang();
      const kw = activeKeywordRaw;

      if(!kw) return "—";

      if(target === "skills"){
        const group = String($("kwSkillGroup").value || "additional");
        const dest = group === "additional"
          ? (uiLang==="de" ? "Weitere Skills" : "Additional skills")
          : ($("kwSkillGroup").selectedOptions?.[0]?.textContent || (uiLang==="de" ? "Skills" : "Skills"));

        // Prefer AI-prettified casing (e.g., "Power BI") when available for the same keyword+language
        let kwShow = prettyKeyword(kw, lang);
        try{
          const key = getAiRecoCacheKey(kw, lang);
          if(kwMode === "ai" && kwAiReco && kwAiRecoKey === key){
            const rTarget = String(kwAiReco.target || "").toLowerCase();
            if(rTarget === "skills"){
              const item = String(kwAiReco.skill_item || kwAiReco.skillItem || kwAiReco.keyword_pretty || kwAiKeywordPretty || "").trim();
              if(item) kwShow = item;
            }else{
              const pp = String(kwAiReco.keyword_pretty || kwAiKeywordPretty || "").trim();
              if(pp) kwShow = pp;
            }
          }
        }catch(_){}

        const verb = (lang==="de") ? "Füge hinzu:" : "Add:";
        return `${verb} ${kwShow} → ${dest}`;
      }

      // experience
      const expIdx = Number($("kwExpRole").value || "0");
      const exp = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[expIdx] || {};
      const roleName = joinNonEmpty([exp?.title, exp?.company], " · ") || (lang==="de" ? "Experience" : "Experience");
      const how = String($("kwExpHow").value || "rewrite");
      const bullets = asStringArr(exp?.bullets, 50);

      if(how === "new"){
        const note = $("kwNote").value || "";
        const b = (kwMode === "ai")
          ? localNewBullet(kw, note, lang) // AI preview might change, but good enough
          : localNewBullet(kw, note, lang);
        return (lang==="de")
          ? (`Neue Bullet bei ${roleName}:\n- ${b}`)
          : (`New bullet under ${roleName}:\n- ${b}`);
      }

      const bulletIdx = Number($("kwExpBullet").value || "0");
      const current = bullets[bulletIdx] || "";
      let rewritten = (how === "append")
        ? localAppendKeyword(current, kw, lang)
        : localRewriteBullet(current, kw, lang);

      // If we already have an AI recommendation for this exact bullet, show that draft (more accurate than templates)
      try{
        const key = getAiRecoCacheKey(kw, lang);
        if(kwMode === "ai" && kwAiReco && kwAiRecoKey === key && String(kwAiReco.target || "").toLowerCase() === "experience"){
          const reExp = Number(kwAiReco.exp_index ?? kwAiReco.expIdx ?? -1);
          const reBul = Number(kwAiReco.bullet_index ?? kwAiReco.bulletIdx ?? -1);
          const rb = String(kwAiReco.rewritten_bullet || kwAiReco.rewrite || "").trim();
          if(rb && reExp === expIdx && reBul === bulletIdx){
            rewritten = rb;
          }
        }
      }catch(_){}


      const label = (how === "append")
        ? (lang==="de" ? "Anhängen:" : "Append:")
        : (lang==="de" ? "Umformulieren:" : "Rewrite:");
      return `${label} ${roleName}\nALT: ${current}\nNEU: ${rewritten}`;
    }

    function updateKwPreview(){
      $("kwResultPreview").textContent = buildKwPreviewText();
    }

    async function applyKeyword(){
      showError("");
      if(!activeKeywordRaw){
        closeKwModal();
        return;
      }
      if(!$("kwTruth").checked){
        showError(t("truthRequired"));
        return;
      }

      const target = String($("kwTarget").value || "skills");
      const lang = chosenKwLang();
      const kwRaw = activeKeywordRaw;
      const kwDisp = prettyKeyword(kwRaw, lang);

      // Take history snapshot
      historyStack.push(snapshotCurrent());
      updateUndoResetButtons();

      try{
        if(target === "skills"){
          // Prefer AI-prettified casing for skills when available (saves a second AI call on Apply)
          let kwSkillAdd = kwDisp;
          try{
            const key = getAiRecoCacheKey(kwRaw, lang);
            if(kwMode === "ai" && kwAiReco && kwAiRecoKey === key){
              const rTarget = String(kwAiReco.target || "").toLowerCase();
              if(rTarget === "skills"){
                const item = String(kwAiReco.skill_item || kwAiReco.skillItem || kwAiReco.keyword_pretty || kwAiKeywordPretty || "").trim();
                if(item) kwSkillAdd = item;
              }else{
                const pp = String(kwAiReco.keyword_pretty || kwAiKeywordPretty || "").trim();
                if(pp) kwSkillAdd = pp;
              }
            }
          }catch(_){}

          if(!lastCvDoc){
            // text-only: just append to end as "Skills: ..."
            const txt = $("cvText").value || "";
            const addLine = (lang==="de") ? ("\nSKILLS\n" + kwSkillAdd + "\n") : ("\nSKILLS\n" + kwSkillAdd + "\n");
            $("cvText").value = (txt.trim() + "\n" + addLine).trim() + "\n";
          }else{
            const skillGroup = String($("kwSkillGroup").value || "additional");
            lastCvDoc.skills = lastCvDoc.skills || {};
            lastCvDoc.skills.groups = Array.isArray(lastCvDoc.skills.groups) ? lastCvDoc.skills.groups : [];
            lastCvDoc.skills.additional = Array.isArray(lastCvDoc.skills.additional) ? lastCvDoc.skills.additional : [];

            const ensureUniquePush = (arr, val) => {
              const exists = arr.some(x => normForMatch(x) === normForMatch(val));
              if(!exists) arr.push(val);
            };

            if(skillGroup.startsWith("group:")){
              const idx = Number(skillGroup.split(":")[1] || "0");
              const g = lastCvDoc.skills.groups[idx];
              if(g){
                g.items = Array.isArray(g.items) ? g.items : [];
                ensureUniquePush(g.items, kwSkillAdd);
              }else{
                ensureUniquePush(lastCvDoc.skills.additional, kwSkillAdd);
              }
            }else{
              ensureUniquePush(lastCvDoc.skills.additional, kwSkillAdd);
            }

            // Update text and preview
            $("cvPreview").innerHTML = cvDocToPreviewHtml(lastCvDoc, lastLang);
            $("cvText").value = cvDocToPlainText(lastCvDoc, lastLang);
          }

          recomputeCoverageFromCurrentText();
          updateKwPreview();
          closeKwModal();
          return;
        }

        // Experience
        if(!lastCvDoc){
          showError(t("needDoc"));
          return;
        }

        const expIdx = Number($("kwExpRole").value || "0");
        const how = String($("kwExpHow").value || "rewrite");

        lastCvDoc.experience = Array.isArray(lastCvDoc.experience) ? lastCvDoc.experience : [];
        const exp = lastCvDoc.experience[expIdx];
        if(!exp){
          showError(t("needDoc"));
          return;
        }
        exp.bullets = Array.isArray(exp.bullets) ? exp.bullets : [];

        let changed = false;
        let usedAi = false;
        let aiNote = "";

        if(how === "new"){
          const note = String($("kwNote").value || "").trim();
          if(!note || note.length < 4){
            showError(t("noteRequired"));
            return;
          }

          if(kwMode === "ai"){
            const ctx = {
              cv_language: lastLang,
              target_language: lang,
              role_title: exp?.title || "",
              company: exp?.company || "",
              job_title: selectedJob?.title || "",
              job_company: selectedJob?.company_name || ""
            };
            const ai = await tryAiRewriteOrCraft({
              mode: "new",
              keyword: kwRaw,
              lang,
              current_bullet: "",
              note,
              context: ctx
            });
            if(ai.ok){
              exp.bullets.unshift(ai.text);
              usedAi = true;
            }else{
              aiNote = t("aiFallback");
              exp.bullets.unshift(localNewBullet(kwRaw, note, lang));
            }
          }else{
            exp.bullets.unshift(localNewBullet(kwRaw, note, lang));
          }
          changed = true;
        } else {
          const bulletIdx = Number($("kwExpBullet").value || "0");
          const current = String(exp.bullets[bulletIdx] || "").trim();
          if(!current){
            // If no bullets, degrade to new with required note
            const note = String($("kwNote").value || "").trim();
            exp.bullets.unshift(localNewBullet(kwRaw, note, lang));
            changed = true;
          }else{
            if(kwMode === "ai" && (how === "rewrite" || how === "append")){
              // If AI already suggested a rewrite for this exact bullet, use it (saves an extra AI call)
              const recoText = (kwAiReco
                && kwAiRecoKey === getAiRecoCacheKey(kwRaw, lang)
                && String(kwAiReco.target || "").toLowerCase() === "experience"
                && Number(kwAiReco.exp_index ?? kwAiReco.expIdx ?? -1) === expIdx
                && Number(kwAiReco.bullet_index ?? kwAiReco.bulletIdx ?? -1) === bulletIdx)
                  ? String(kwAiReco.rewritten_bullet || kwAiReco.rewrite || "").trim()
                  : "";

              if(recoText){
                exp.bullets[bulletIdx] = recoText;
                usedAi = true;
                changed = true;
              }else{
              const ctx = {
                cv_language: lastLang,
                target_language: lang,
                role_title: exp?.title || "",
                company: exp?.company || "",
                job_title: selectedJob?.title || "",
                job_company: selectedJob?.company_name || "",
                intent: how
              };
              const ai = await tryAiRewriteOrCraft({
                mode: "rewrite",
                keyword: kwRaw,
                lang,
                current_bullet: current,
                note: "",
                context: ctx
              });
              if(ai.ok){
                exp.bullets[bulletIdx] = ai.text;
                usedAi = true;
                changed = true;
              }else{
                aiNote = t("aiFallback");
                exp.bullets[bulletIdx] = (how === "append")
                  ? localAppendKeyword(current, kwRaw, lang)
                  : localRewriteBullet(current, kwRaw, lang);
                changed = true;
              }
              }
            } else if(how === "append"){
              exp.bullets[bulletIdx] = localAppendKeyword(current, kwRaw, lang);
              changed = true;
            } else {
              exp.bullets[bulletIdx] = localRewriteBullet(current, kwRaw, lang);
              changed = true;
            }
          }
        }

        if(changed){
          $("cvPreview").innerHTML = cvDocToPreviewHtml(lastCvDoc, lastLang);
          $("cvText").value = cvDocToPlainText(lastCvDoc, lastLang);
          recomputeCoverageFromCurrentText();

          if(aiNote){
            // non-blocking: show as top info
            showError(aiNote);
          }
          closeKwModal();
        }
      }catch(e){
        // rollback snapshot
        const snap = historyStack.pop();
        restoreSnapshot(snap);
        showError(e?.message || String(e));
      }finally{
        updateUndoResetButtons();
        if($('tabChanges')?.classList?.contains('active')){ try{ renderChangesView(); }catch(_){ } }
        // Save edited output locally
        try{
          const key = "cvstudio_last_" + String(selectedJob?.id || "");
          localStorage.setItem(key, JSON.stringify({
            at: Date.now(),
            payload: buildTailorPayload(),
            cv_text: $("cvText").value || "",
            cv_doc: lastCvDoc,
            lang: lastLang,
            used: lastUsed,
            missing: lastMissing,
            all: atsKeywordsAll,
            debug: lastDebug
          }));
        }catch(_){}
      }
    }

    function undoEdit(){
      if(!historyStack.length) return;
      const snap = historyStack.pop();
      restoreSnapshot(snap);
      updateUndoResetButtons();
      if($("tabChanges")?.classList?.contains("active")){ try{ renderChangesView(); }catch(_){ } }
    }

    function resetEdits(){
      if(!baseSnapshot) return;
      historyStack = [];
      restoreSnapshot(baseSnapshot);
      updateUndoResetButtons();
      if($("tabChanges")?.classList?.contains("active")){ try{ renderChangesView(); }catch(_){ } }
    }

    /* -------------------------
       Auth + boot
       ------------------------- */
    async function loadStateAndNav(){
      setBadge("authBadge","warn", uiLang==="de" ? "Prüfe…" : "Checking…");

      session = await window.JobApplyAI.auth.getSession();
      if(!session || !session.user || !session.user.email){
        setBadge("authBadge","warn", uiLang==="de" ? "Abgemeldet" : "Signed out");
        window.location.replace("./signup.html");
        return;
      }

      $("navLogout").style.display = "";
      $("navSignIn").style.display = "none";
      setBadge("authBadge","good", uiLang==="de" ? "Angemeldet" : "Signed in");

      // Ensure customer exists (best effort)
      try{
        await window.JobApplyAI.auth.requireAuthAndCustomer({ redirectTo: "./signup.html" });
      }catch(_){}

      try{
        await window.JobApplyAI.auth.syncStateToLocalStorage(session);
      }catch(_){}
    }

    async function boot(){
      showError("");

      applyUiTexts();
      setStrengthUi();

      if(!window.JobApplyAI || !window.JobApplyAI.auth){
        showError("auth.js did not load. Ensure multipage/auth.js exists and is referenced as ./auth.js.");
        setBadge("authBadge","bad","Config error");
        return;
      }

      await loadStateAndNav();

      // restore saved template/strength
      try{
        const sv = localStorage.getItem("cv_strength");
        if(sv !== null && sv !== undefined && sv !== "") $("strengthRange").value = String(sv);
      }catch(_){}
      setStrengthUi();

      try{
        const tv = localStorage.getItem("cv_template");
        if(tv) $("tplSelect").value = tv;
      }catch(_){}
      setTemplateUi();

      // restore paste draft + job source (queue vs paste)
      loadJobSource();
      loadPasteDraft();
      applyPasteDraftToInputs();

      // apply initial mode UI
      setJobSource(jobSource);
      try{ updatePasteQuality(); }catch(_){}

      // load queue
      await loadQueue();

      // initial output state
      renderKeywords();
      setTabs("preview");
      markSteps("idle");
      setOutputEnabled(false);
      updateUndoResetButtons();
    }

    /* -------------------------
       Wire UI
       ------------------------- */
    $("jobSelect").addEventListener("change", onJobChange);

    // Job source (queue vs paste)
    $("sourcePills").addEventListener("click", (e) => {
      const p = e.target.closest(".miniPill");
      if(!p) return;
      const src = String(p.getAttribute("data-src") || "queue");
      setJobSource(src);
    });

    // Pasted job description inputs
    ["pasteTitle","pasteCompany","pasteApply"].forEach((id) => {
      const el = $(id);
      if(!el) return;
      el.addEventListener("input", () => {
        savePasteDraft();
        refreshModeUi();
      });
    });

    $("pasteLangHint").addEventListener("change", () => {
      savePasteDraft();
      updatePasteQuality();
    });

    $("pasteDesc").addEventListener("input", () => {
      savePasteDraft();
      updatePasteQuality();
    });

    $("strengthRange").addEventListener("input", setStrengthUi);
    $("strengthPills").addEventListener("click", (e) => {
      const p = e.target.closest(".miniPill");
      if(!p) return;
      $("strengthRange").value = String(p.getAttribute("data-s"));
      setStrengthUi();
    });

    $("tplSelect").addEventListener("change", setTemplateUi);

    $("btnAtsInfo").addEventListener("click", () => H.showModal("atsModal"));
    $("atsClose").addEventListener("click", () => H.hideModal("atsModal"));
    $("atsOk").addEventListener("click", () => H.hideModal("atsModal"));
    $("atsModal").addEventListener("click", (e) => { if(e.target && e.target.id === "atsModal") H.hideModal("atsModal"); });

    $("btnViewDesc").addEventListener("click", openDescModal);
    $("btnCopyDesc").addEventListener("click", async () => {
      try{
        await copyDesc();
        $("btnCopyDesc").textContent = t("copied");
        setTimeout(()=>{ $("btnCopyDesc").textContent = t("btnCopyDesc"); }, 900);
      }catch(_){}
    });

    $("descClose").addEventListener("click", () => H.hideModal("descModal"));
    $("descModal").addEventListener("click", (e) => { if(e.target && e.target.id === "descModal") H.hideModal("descModal"); });
    $("descCopy").addEventListener("click", async () => {
      if(!selectedDesc) return;
      await copyDesc();
      $("descCopy").textContent = t("copied");
      setTimeout(()=>{ $("descCopy").textContent = t("copy"); }, 900);
    });

    document.addEventListener("keydown", (e) => {
      if(e.key === "Escape"){
        H.hideModal("atsModal");
        H.hideModal("descModal");
        H.hideModal("kwModal");
      }
    });

    $("btnGenerate").addEventListener("click", generate);
    $("btnGenerateAgain").addEventListener("click", generate);

    $("tabPreview").addEventListener("click", () => setTabs("preview"));
    $("tabText").addEventListener("click", () => setTabs("text"));
    $("tabChanges").addEventListener("click", () => setTabs("changes"));

    $("btnCopy").addEventListener("click", () => copyCv());
    $("btnDownload").addEventListener("click", downloadTxt);
    $("btnPrint").addEventListener("click", printPdf);
    $("btnCopyMissing").addEventListener("click", copyMissing);

    // Track manual text edits -> recompute keyword coverage
    $("cvText").addEventListener("input", () => {
      // If user edits text manually, keep keywords in sync
      recomputeCoverageFromCurrentText();
      // We do not mutate doc here to avoid confusion; Preview stays as last doc.
      if($("tabChanges")?.classList?.contains("active")){ try{ renderChangesView(); }catch(_){ } }
    });

    // Keyword chips click
    $("chipsMissing").addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-kw]");
      if(!btn) return;
      const kw = btn.getAttribute("data-kw") || "";
      if(!kw) return;
      if(!lastCvDoc && !($("cvText").value||"").trim()){
        showError(t("needCv"));
        return;
      }
      openKwModal(kw);
    });

    // Undo / Reset
    $("btnUndoEdit").addEventListener("click", undoEdit);
    $("btnUndoFromChanges").addEventListener("click", () => { undoEdit(); renderChangesView(); });
    $("btnResetFromChanges").addEventListener("click", () => { resetEdits(); renderChangesView(); });
    $("btnCopyChangeSummary").addEventListener("click", copyChangeSummary);
    $("btnCopyDiff").addEventListener("click", copyDiffToClipboard);
    $("btnSyncTextToDoc").addEventListener("click", syncTextToPreview);

    // Change cards revert clicks (event delegation)
    $("changeCards").addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-revert-id]");
      if(!btn) return;
      const id = btn.getAttribute("data-revert-id") || "";
      if(!id) return;
      revertStructuredChange(id);
    });

    $("btnResetEdits").addEventListener("click", resetEdits);

    // Keyword modal wiring
    $("kwClose").addEventListener("click", closeKwModal);
    $("kwCancel").addEventListener("click", closeKwModal);
    $("kwModal").addEventListener("click", (e) => { if(e.target && e.target.id === "kwModal") closeKwModal(); });

    $("kwTarget").addEventListener("change", () => { updateKwTargetUi(); updateKwPreview(); });
    $("kwLang").addEventListener("change", () => {
      updateKwPreview();
      if(kwMode === "ai" && activeKeywordRaw && lastCvDoc){
        try{ aiRecommendPlacement({ force:true, source:"lang" }); }catch(_){ }
      }
    });

    $("kwAiRecoRefresh").addEventListener("click", () => {
      if(kwMode === "ai" && activeKeywordRaw && lastCvDoc){
        try{ aiRecommendPlacement({ force:true, source:"refresh" }); }catch(_){ }
      }
    });

    $("kwModeToggle").addEventListener("click", (e) => {
      const b = e.target.closest("button[data-mode]");
      if(!b) return;
      setKwMode(b.getAttribute("data-mode"));
    });

    $("kwSkillGroup").addEventListener("change", updateKwPreview);
    $("kwExpRole").addEventListener("change", () => { fillBulletsForSelectedRole(); updateKwPreview(); });
    $("kwExpHow").addEventListener("change", updateKwExpHowUi);
    $("kwExpBullet").addEventListener("change", () => {
      const expIdx = Number($("kwExpRole").value || "0");
      const exp = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[expIdx] || null;
      const bullets = asStringArr(exp?.bullets, 50);
      const i = Number($("kwExpBullet").value || "0");
      $("kwBulletPreview").textContent = bullets[i] || "—";
      updateKwPreview();
    });
    
    $("kwAutoPick").addEventListener("click", () => {
      if(!lastCvDoc || !activeKeywordRaw) return;
      const best = pickBestRoleAndBullet(activeKeywordRaw);
      $("kwExpRole").value = String(best.expIdx || 0);
      fillBulletsForSelectedRole();
      $("kwExpBullet").value = String(best.bulletIdx || 0);
      const e = (Array.isArray(lastCvDoc?.experience) ? lastCvDoc.experience : [])[Number(best.expIdx||0)] || null;
      const bullets = asStringArr(e?.bullets, 50);
      $("kwBulletPreview").textContent = bullets[Number(best.bulletIdx||0)] || "—";
      const badge = $("kwAutoPickBadge");
      if(badge){
        badge.textContent = (best.score != null && best.score >= 0) ? ("Score " + best.score) : "—";
        badge.className = "badge " + ((best.score || 0) >= 4 ? "good" : "warn");
      }
      updateKwPreview();
    });
$("kwNote").addEventListener("input", updateKwPreview);
    $("kwApply").addEventListener("click", applyKeyword);

    // Logout
    $("navLogout").addEventListener("click", async () => {
      try{
        await window.JobApplyAI.auth.logout("./index.html");
      }catch(_){
        window.location.href = "./index.html";
      }
    });

    // Initial view
    setTabs("preview");
    markSteps("idle");

    window.addEventListener("load", () => {
      boot().catch((e) => {
        showError(e?.message || String(e));
        setBadge("authBadge","bad","Error");
      });
    });

  })();
  </script>
</body>
</html>
